"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER3 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t2 = exports2.tokens = {};
    var R2 = 0;
    function tok(n) {
      t2[n] = R2++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i3 = 0; i3 < safeRegexReplacements.length; i3++) {
        var token = safeRegexReplacements[i3][0];
        var max2 = safeRegexReplacements[i3][1];
        value = value.split(token + "*").join(token + "{0," + max2 + "}").split(token + "+").join(token + "{1," + max2 + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t2.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t2.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t2.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t2.MAINVERSION] = "(" + src[t2.NUMERICIDENTIFIER] + ")\\.(" + src[t2.NUMERICIDENTIFIER] + ")\\.(" + src[t2.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t2.MAINVERSIONLOOSE] = "(" + src[t2.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t2.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t2.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t2.PRERELEASEIDENTIFIER] = "(?:" + src[t2.NUMERICIDENTIFIER] + "|" + src[t2.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t2.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t2.NUMERICIDENTIFIERLOOSE] + "|" + src[t2.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t2.PRERELEASE] = "(?:-(" + src[t2.PRERELEASEIDENTIFIER] + "(?:\\." + src[t2.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t2.PRERELEASELOOSE] = "(?:-?(" + src[t2.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t2.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t2.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t2.BUILD] = "(?:\\+(" + src[t2.BUILDIDENTIFIER] + "(?:\\." + src[t2.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t2.FULLPLAIN] = "v?" + src[t2.MAINVERSION] + src[t2.PRERELEASE] + "?" + src[t2.BUILD] + "?";
    src[t2.FULL] = "^" + src[t2.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t2.LOOSEPLAIN] = "[v=\\s]*" + src[t2.MAINVERSIONLOOSE] + src[t2.PRERELEASELOOSE] + "?" + src[t2.BUILD] + "?";
    tok("LOOSE");
    src[t2.LOOSE] = "^" + src[t2.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t2.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t2.XRANGEIDENTIFIERLOOSE] = src[t2.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t2.XRANGEIDENTIFIER] = src[t2.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t2.XRANGEPLAIN] = "[v=\\s]*(" + src[t2.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t2.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t2.XRANGEIDENTIFIER] + ")(?:" + src[t2.PRERELEASE] + ")?" + src[t2.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t2.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t2.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t2.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t2.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t2.PRERELEASELOOSE] + ")?" + src[t2.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t2.XRANGE] = "^" + src[t2.GTLT] + "\\s*" + src[t2.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t2.XRANGELOOSE] = "^" + src[t2.GTLT] + "\\s*" + src[t2.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t2.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t2.COERCERTL] = new RegExp(src[t2.COERCE], "g");
    safeRe[t2.COERCERTL] = new RegExp(makeSafeRe(src[t2.COERCE]), "g");
    tok("LONETILDE");
    src[t2.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t2.TILDETRIM] = "(\\s*)" + src[t2.LONETILDE] + "\\s+";
    re[t2.TILDETRIM] = new RegExp(src[t2.TILDETRIM], "g");
    safeRe[t2.TILDETRIM] = new RegExp(makeSafeRe(src[t2.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t2.TILDE] = "^" + src[t2.LONETILDE] + src[t2.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t2.TILDELOOSE] = "^" + src[t2.LONETILDE] + src[t2.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t2.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t2.CARETTRIM] = "(\\s*)" + src[t2.LONECARET] + "\\s+";
    re[t2.CARETTRIM] = new RegExp(src[t2.CARETTRIM], "g");
    safeRe[t2.CARETTRIM] = new RegExp(makeSafeRe(src[t2.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t2.CARET] = "^" + src[t2.LONECARET] + src[t2.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t2.CARETLOOSE] = "^" + src[t2.LONECARET] + src[t2.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t2.COMPARATORLOOSE] = "^" + src[t2.GTLT] + "\\s*(" + src[t2.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t2.COMPARATOR] = "^" + src[t2.GTLT] + "\\s*(" + src[t2.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t2.COMPARATORTRIM] = "(\\s*)" + src[t2.GTLT] + "\\s*(" + src[t2.LOOSEPLAIN] + "|" + src[t2.XRANGEPLAIN] + ")";
    re[t2.COMPARATORTRIM] = new RegExp(src[t2.COMPARATORTRIM], "g");
    safeRe[t2.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t2.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t2.HYPHENRANGE] = "^\\s*(" + src[t2.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t2.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t2.HYPHENRANGELOOSE] = "^\\s*(" + src[t2.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t2.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t2.STAR] = "(<|>)?=?\\s*\\*";
    for (i2 = 0; i2 < R2; i2++) {
      debug(i2, src[i2]);
      if (!re[i2]) {
        re[i2] = new RegExp(src[i2]);
        safeRe[i2] = new RegExp(makeSafeRe(src[i2]));
      }
    }
    var i2;
    exports2.parse = parse6;
    function parse6(version3, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 !== "string") {
        return null;
      }
      if (version3.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t2.LOOSE] : safeRe[t2.FULL];
      if (!r.test(version3)) {
        return null;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version3, options) {
      var v = parse6(version3, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version3, options) {
      var s3 = parse6(version3.trim().replace(/^[=v]+/, ""), options);
      return s3 ? s3.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version3, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version3 instanceof SemVer) {
        if (version3.loose === options.loose) {
          return version3;
        } else {
          version3 = version3.version;
        }
      } else if (typeof version3 !== "string") {
        throw new TypeError("Invalid Version: " + version3);
      }
      if (version3.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version3, options);
      }
      debug("SemVer", version3, options);
      this.options = options;
      this.loose = !!options.loose;
      var m3 = version3.trim().match(options.loose ? safeRe[t2.LOOSE] : safeRe[t2.FULL]);
      if (!m3) {
        throw new TypeError("Invalid Version: " + version3);
      }
      this.raw = version3;
      this.major = +m3[1];
      this.minor = +m3[2];
      this.patch = +m3[3];
      if (this.major > MAX_SAFE_INTEGER3 || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER3 || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER3 || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m3[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m3[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER3) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m3[5] ? m3[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i3 = 0;
      do {
        var a3 = this.prerelease[i3];
        var b2 = other.prerelease[i3];
        debug("prerelease compare", i3, a3, b2);
        if (a3 === void 0 && b2 === void 0) {
          return 0;
        } else if (b2 === void 0) {
          return 1;
        } else if (a3 === void 0) {
          return -1;
        } else if (a3 === b2) {
          continue;
        } else {
          return compareIdentifiers(a3, b2);
        }
      } while (++i3);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i3 = 0;
      do {
        var a3 = this.build[i3];
        var b2 = other.build[i3];
        debug("prerelease compare", i3, a3, b2);
        if (a3 === void 0 && b2 === void 0) {
          return 0;
        } else if (b2 === void 0) {
          return 1;
        } else if (a3 === void 0) {
          return -1;
        } else if (a3 === b2) {
          continue;
        } else {
          return compareIdentifiers(a3, b2);
        }
      } while (++i3);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i3 = this.prerelease.length;
            while (--i3 >= 0) {
              if (typeof this.prerelease[i3] === "number") {
                this.prerelease[i3]++;
                i3 = -2;
              }
            }
            if (i3 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version3, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version3, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version22) {
      if (eq2(version1, version22)) {
        return null;
      } else {
        var v1 = parse6(version1);
        var v2 = parse6(version22);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a3, b2) {
      var anum = numeric.test(a3);
      var bnum = numeric.test(b2);
      if (anum && bnum) {
        a3 = +a3;
        b2 = +b2;
      }
      return a3 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b2 ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a3, b2) {
      return compareIdentifiers(b2, a3);
    }
    exports2.major = major;
    function major(a3, loose) {
      return new SemVer(a3, loose).major;
    }
    exports2.minor = minor;
    function minor(a3, loose) {
      return new SemVer(a3, loose).minor;
    }
    exports2.patch = patch;
    function patch(a3, loose) {
      return new SemVer(a3, loose).patch;
    }
    exports2.compare = compare;
    function compare(a3, b2, loose) {
      return new SemVer(a3, loose).compare(new SemVer(b2, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a3, b2) {
      return compare(a3, b2, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a3, b2, loose) {
      var versionA = new SemVer(a3, loose);
      var versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a3, b2, loose) {
      return compare(b2, a3, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a3, b2) {
        return exports2.compareBuild(a3, b2, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a3, b2) {
        return exports2.compareBuild(b2, a3, loose);
      });
    }
    exports2.gt = gt;
    function gt(a3, b2, loose) {
      return compare(a3, b2, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a3, b2, loose) {
      return compare(a3, b2, loose) < 0;
    }
    exports2.eq = eq2;
    function eq2(a3, b2, loose) {
      return compare(a3, b2, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a3, b2, loose) {
      return compare(a3, b2, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a3, b2, loose) {
      return compare(a3, b2, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a3, b2, loose) {
      return compare(a3, b2, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a3, op, b2, loose) {
      switch (op) {
        case "===":
          if (typeof a3 === "object")
            a3 = a3.version;
          if (typeof b2 === "object")
            b2 = b2.version;
          return a3 === b2;
        case "!==":
          if (typeof a3 === "object")
            a3 = a3.version;
          if (typeof b2 === "object")
            b2 = b2.version;
          return a3 !== b2;
        case "":
        case "=":
        case "==":
          return eq2(a3, b2, loose);
        case "!=":
          return neq(a3, b2, loose);
        case ">":
          return gt(a3, b2, loose);
        case ">=":
          return gte(a3, b2, loose);
        case "<":
          return lt(a3, b2, loose);
        case "<=":
          return lte(a3, b2, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t2.COMPARATORLOOSE] : safeRe[t2.COMPARATOR];
      var m3 = comp.match(r);
      if (!m3) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m3[1] !== void 0 ? m3[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m3[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m3[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version3) {
      debug("Comparator.test", version3, this.options.loose);
      if (this.semver === ANY || version3 === ANY) {
        return true;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version3, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range6(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range6(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range6;
    function Range6(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range6) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range6(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range6(range.value, options);
      }
      if (!(this instanceof Range6)) {
        return new Range6(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c2) {
        return c2.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range6.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range6.prototype.toString = function() {
      return this.range;
    };
    Range6.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t2.HYPHENRANGELOOSE] : safeRe[t2.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(safeRe[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, safeRe[t2.COMPARATORTRIM]);
      range = range.replace(safeRe[t2.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t2.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t2.COMPARATORLOOSE] : safeRe[t2.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range6.prototype.intersects = function(range, options) {
      if (!(range instanceof Range6)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range6(range, options).set.map(function(comp) {
        return comp.map(function(c2) {
          return c2.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t2.TILDELOOSE] : safeRe[t2.TILDE];
      return comp.replace(r, function(_, M3, m3, p, pr) {
        debug("tilde", comp, _, M3, m3, p, pr);
        var ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m3)) {
          ret = ">=" + M3 + ".0.0 <" + (+M3 + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M3 + "." + m3 + ".0 <" + M3 + "." + (+m3 + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M3 + "." + m3 + "." + p + "-" + pr + " <" + M3 + "." + (+m3 + 1) + ".0";
        } else {
          ret = ">=" + M3 + "." + m3 + "." + p + " <" + M3 + "." + (+m3 + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? safeRe[t2.CARETLOOSE] : safeRe[t2.CARET];
      return comp.replace(r, function(_, M3, m3, p, pr) {
        debug("caret", comp, _, M3, m3, p, pr);
        var ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m3)) {
          ret = ">=" + M3 + ".0.0 <" + (+M3 + 1) + ".0.0";
        } else if (isX(p)) {
          if (M3 === "0") {
            ret = ">=" + M3 + "." + m3 + ".0 <" + M3 + "." + (+m3 + 1) + ".0";
          } else {
            ret = ">=" + M3 + "." + m3 + ".0 <" + (+M3 + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M3 === "0") {
            if (m3 === "0") {
              ret = ">=" + M3 + "." + m3 + "." + p + "-" + pr + " <" + M3 + "." + m3 + "." + (+p + 1);
            } else {
              ret = ">=" + M3 + "." + m3 + "." + p + "-" + pr + " <" + M3 + "." + (+m3 + 1) + ".0";
            }
          } else {
            ret = ">=" + M3 + "." + m3 + "." + p + "-" + pr + " <" + (+M3 + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M3 === "0") {
            if (m3 === "0") {
              ret = ">=" + M3 + "." + m3 + "." + p + " <" + M3 + "." + m3 + "." + (+p + 1);
            } else {
              ret = ">=" + M3 + "." + m3 + "." + p + " <" + M3 + "." + (+m3 + 1) + ".0";
            }
          } else {
            ret = ">=" + M3 + "." + m3 + "." + p + " <" + (+M3 + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t2.XRANGELOOSE] : safeRe[t2.XRANGE];
      return comp.replace(r, function(ret, gtlt, M3, m3, p, pr) {
        debug("xRange", comp, ret, gtlt, M3, m3, p, pr);
        var xM = isX(M3);
        var xm = xM || isX(m3);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m3 = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M3 = +M3 + 1;
              m3 = 0;
              p = 0;
            } else {
              m3 = +m3 + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M3 = +M3 + 1;
            } else {
              m3 = +m3 + 1;
            }
          }
          ret = gtlt + M3 + "." + m3 + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M3 + ".0.0" + pr + " <" + (+M3 + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M3 + "." + m3 + ".0" + pr + " <" + M3 + "." + (+m3 + 1) + ".0" + pr;
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t2.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range6.prototype.test = function(version3) {
      if (!version3) {
        return false;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i3 = 0; i3 < this.set.length; i3++) {
        if (testSet(this.set[i3], version3, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version3, options) {
      for (var i3 = 0; i3 < set.length; i3++) {
        if (!set[i3].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (i3 = 0; i3 < set.length; i3++) {
          debug(set[i3].semver);
          if (set[i3].semver === ANY) {
            continue;
          }
          if (set[i3].semver.prerelease.length > 0) {
            var allowed = set[i3].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version3, range, options) {
      try {
        range = new Range6(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max2 = null;
      var maxSV = null;
      try {
        var rangeObj = new Range6(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max2 || maxSV.compare(v) === -1) {
            max2 = v;
            maxSV = new SemVer(max2, options);
          }
        }
      });
      return max2;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min2 = null;
      var minSV = null;
      try {
        var rangeObj = new Range6(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min2 || minSV.compare(v) === 1) {
            min2 = v;
            minSV = new SemVer(min2, options);
          }
        }
      });
      return min2;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range6(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i3 = 0; i3 < range.set.length; ++i3) {
        var comparators = range.set[i3];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range6(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version3, range, options) {
      return outside(version3, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version3, range, options) {
      return outside(version3, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version3, range, hilo, options) {
      version3 = new SemVer(version3, options);
      range = new Range6(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (var i3 = 0; i3 < range.set.length; ++i3) {
        var comparators = range.set[i3];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version3, options) {
      var parsed = parse6(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range6(r1, options);
      r2 = new Range6(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version3, options) {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      var match2 = null;
      if (!options.rtl) {
        match2 = version3.match(safeRe[t2.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t2.COERCERTL].exec(version3)) && (!match2 || match2.index + match2[0].length !== version3.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          safeRe[t2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t2.COERCERTL].lastIndex = -1;
      }
      if (match2 === null) {
        return null;
      }
      return parse6(match2[2] + "." + (match2[3] || "0") + "." + (match2[4] || "0"), options);
    }
  }
});

// node_modules/make-dir/index.js
var require_make_dir = __commonJS({
  "node_modules/make-dir/index.js"(exports2, module2) {
    "use strict";
    var fs4 = require("fs");
    var path2 = require("path");
    var { promisify: promisify2 } = require("util");
    var semver = require_semver();
    var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path2.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options) => {
      const defaults = {
        mode: 511,
        fs: fs4
      };
      return {
        ...defaults,
        ...options
      };
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    var makeDir2 = async (input2, options) => {
      checkPath(input2);
      options = processOptions(options);
      const mkdir2 = promisify2(options.fs.mkdir);
      const stat3 = promisify2(options.fs.stat);
      if (useNativeRecursiveOption && options.fs.mkdir === fs4.mkdir) {
        const pth = path2.resolve(input2);
        await mkdir2(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = async (pth) => {
        try {
          await mkdir2(pth, options.mode);
          return pth;
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path2.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path2.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await stat3(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error;
          }
          return pth;
        }
      };
      return make(path2.resolve(input2));
    };
    module2.exports = makeDir2;
    module2.exports.sync = (input2, options) => {
      checkPath(input2);
      options = processOptions(options);
      if (useNativeRecursiveOption && options.fs.mkdirSync === fs4.mkdirSync) {
        const pth = path2.resolve(input2);
        fs4.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path2.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path2.dirname(pth));
            return make(pth);
          }
          try {
            if (!options.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error;
          }
        }
        return pth;
      };
      return make(path2.resolve(input2));
    };
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs4 = require("fs");
    function checkPathExt(path2, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i2 = 0; i2 < pathext.length; i2++) {
        var p = pathext[i2].toLowerCase();
        if (p && path2.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat3, path2, options) {
      if (!stat3.isSymbolicLink() && !stat3.isFile()) {
        return false;
      }
      return checkPathExt(path2, options);
    }
    function isexe(path2, options, cb) {
      fs4.stat(path2, function(er, stat3) {
        cb(er, er ? false : checkStat(stat3, path2, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs4.statSync(path2), path2, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs4 = require("fs");
    function isexe(path2, options, cb) {
      fs4.stat(path2, function(er, stat3) {
        cb(er, er ? false : checkStat(stat3, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs4.statSync(path2), options);
    }
    function checkStat(stat3, options) {
      return stat3.isFile() && checkMode(stat3, options);
    }
    function checkMode(stat3, options) {
      var mod = stat3.mode;
      var uid = stat3.uid;
      var gid = stat3.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u2 = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u2 | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u2 && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports2, module2) {
    var fs4 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path2, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve6, reject) {
          isexe(path2, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve6(is);
            }
          });
        });
      }
      core(path2, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path2, options) {
      try {
        return core.sync(path2, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/lib/index.js
var require_lib = __commonJS({
  "node_modules/which/lib/index.js"(exports2, module2) {
    var isexe = require_isexe();
    var { join, delimiter, sep, posix: posix2 } = require("path");
    var isWindows3 = process.platform === "win32";
    var rSlash = new RegExp(`[${posix2.sep}${sep === posix2.sep ? "" : sep}]`.replace(/(\\)/g, "\\$1"));
    var rRel = new RegExp(`^\\.${rSlash.source}`);
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, {
      path: optPath = process.env.PATH,
      pathExt: optPathExt = process.env.PATHEXT,
      delimiter: optDelimiter = delimiter
    }) => {
      const pathEnv = cmd.match(rSlash) ? [""] : [
        ...isWindows3 ? [process.cwd()] : [],
        ...(optPath || "").split(optDelimiter)
      ];
      if (isWindows3) {
        const pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter);
        const pathExt = pathExtExe.split(optDelimiter);
        if (cmd.includes(".") && pathExt[0] !== "") {
          pathExt.unshift("");
        }
        return { pathEnv, pathExt, pathExtExe };
      }
      return { pathEnv, pathExt: [""] };
    };
    var getPathPart = (raw, cmd) => {
      const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
      const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
      return prefix + join(pathPart, cmd);
    };
    var which2 = async (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const envPart of pathEnv) {
        const p = getPathPart(envPart, cmd);
        for (const ext of pathExt) {
          const withExt = p + ext;
          const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    var whichSync = (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const pathEnvPart of pathEnv) {
        const p = getPathPart(pathEnvPart, cmd);
        for (const ext of pathExt) {
          const withExt = p + ext;
          const is = isexe.sync(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "node_modules/minimatch/lib/path.js"(exports2, module2) {
    var isWindows3 = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows3 ? { sep: "\\" } : { sep: "/" };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a3, b2, str) {
      if (a3 instanceof RegExp)
        a3 = maybeMatch(a3, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r = range(a3, b2, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a3.length, r[1]),
        post: str.slice(r[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m3 = str.match(reg);
      return m3 ? m3[0] : null;
    }
    balanced.range = range;
    function range(a3, b2, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a3);
      var bi = str.indexOf(b2, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        if (a3 === b2) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a3, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b2, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return str.split(",");
      var pre = m3.pre;
      var body = m3.body;
      var post = m3.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i2, y3) {
      return i2 <= y3;
    }
    function gte(i2, y3) {
      return i2 >= y3;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return [str];
      var pre = m3.pre;
      var post = m3.post.length ? expand(m3.post, false) : [""];
      if (/\$$/.test(m3.pre)) {
        for (var k2 = 0; k2 < post.length; k2++) {
          var expansion = pre + "{" + m3.body + "}" + post[k2];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m3.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m3.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m3.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m3.post.match(/,.*\}/)) {
            str = m3.pre + "{" + m3.body + escClose + m3.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m3.body.split(/\.\./);
        } else {
          n = parseCommaParts(m3.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m3.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x2 = numeric(n[0]);
          var y3 = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y3 < x2;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i2 = x2; test(i2, y3); i2 += incr) {
            var c2;
            if (isAlphaSequence) {
              c2 = String.fromCharCode(i2);
              if (c2 === "\\")
                c2 = "";
            } else {
              c2 = String(i2);
              if (pad) {
                var need = width - c2.length;
                if (need > 0) {
                  var z2 = new Array(need + 1).join("0");
                  if (i2 < 0)
                    c2 = "-" + z2 + c2.slice(1);
                  else
                    c2 = z2 + c2;
                }
              }
            }
            N.push(c2);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k2 = 0; k2 < post.length; k2++) {
            var expansion = pre + N[j] + post[k2];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    var minimatch3 = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch3;
    var path2 = require_path();
    minimatch3.sep = path2.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch3.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s3) => s3.split("").reduce((set, c2) => {
      set[c2] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch3.filter = (pattern, options = {}) => (p, i2, list) => minimatch3(p, pattern, options);
    var ext = (a3, b2 = {}) => {
      const t2 = {};
      Object.keys(a3).forEach((k2) => t2[k2] = a3[k2]);
      Object.keys(b2).forEach((k2) => t2[k2] = b2[k2]);
      return t2;
    };
    minimatch3.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch3;
      }
      const orig = minimatch3;
      const m3 = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m3.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m3.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m3.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m3.defaults = (options) => orig.defaults(ext(def, options));
      m3.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m3.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m3.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m3;
    };
    minimatch3.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch3.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch3.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s3) => s3.replace(/\\(.)/g, "$1");
    var charUnescape = (s3) => s3.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s3) => s3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s3) => s3.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s3) => s3.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s3, si, set2) => s3.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s3) => s3.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = !!options.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i2 = 0, c2; i2 < pattern.length && (c2 = pattern.charAt(i2)); i2++) {
          this.debug("%s	%s %s %j", pattern, i2, re, c2);
          if (escaping) {
            if (c2 === "/") {
              return false;
            }
            if (reSpecials[c2]) {
              re += "\\";
            }
            re += c2;
            escaping = false;
            continue;
          }
          switch (c2) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i2 + 1) === "-") {
                re += c2;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re, c2);
              if (inClass) {
                this.debug("  in class");
                if (c2 === "!" && i2 === classStart + 1)
                  c2 = "^";
                re += c2;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c2;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i2 - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c2;
                continue;
              }
              inClass = true;
              classStart = i2;
              reClassStart = re.length;
              re += c2;
              continue;
            case "]":
              if (i2 === classStart + 1 || !inClass) {
                re += "\\" + c2;
                continue;
              }
              cs = pattern.substring(classStart + 1, i2);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c2;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c2] && !(c2 === "^" && inClass)) {
                re += "\\";
              }
              re += c2;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t2 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t2 + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i2 = 0; i2 < openParensBefore; i2++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i2) => {
            if (p !== GLOBSTAR || pattern[i2 - 1] === GLOBSTAR) {
              return;
            }
            if (i2 === 0) {
              if (pattern.length > 1) {
                pattern[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i2 + 1];
              } else {
                pattern[i2] = twoStar;
              }
            } else if (i2 === pattern.length - 1) {
              pattern[i2 - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i2 - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i2 + 1];
              pattern[i2 + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options = this.options;
        if (path2.sep !== "/") {
          f = f.split(path2.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i2 = f.length - 1; i2 >= 0; i2--) {
          filename = f[i2];
          if (filename)
            break;
        }
        for (let i2 = 0; i2 < set.length; i2++) {
          const pattern = set[i2];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch3.defaults(def).Minimatch;
      }
    };
    minimatch3.Minimatch = Minimatch;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert2 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert2;
    for (const model of Object.keys(convert2)) {
      if (!("channels" in convert2[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert2[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert2[model].labels.length !== convert2[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert2[model];
      delete convert2[model].channels;
      delete convert2[model].labels;
      Object.defineProperty(convert2[model], "channels", { value: channels });
      Object.defineProperty(convert2[model], "labels", { value: labels });
    }
    convert2.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const min2 = Math.min(r, g, b2);
      const max2 = Math.max(r, g, b2);
      const delta = max2 - min2;
      let h3;
      let s3;
      if (max2 === min2) {
        h3 = 0;
      } else if (r === max2) {
        h3 = (g - b2) / delta;
      } else if (g === max2) {
        h3 = 2 + (b2 - r) / delta;
      } else if (b2 === max2) {
        h3 = 4 + (r - g) / delta;
      }
      h3 = Math.min(h3 * 60, 360);
      if (h3 < 0) {
        h3 += 360;
      }
      const l = (min2 + max2) / 2;
      if (max2 === min2) {
        s3 = 0;
      } else if (l <= 0.5) {
        s3 = delta / (max2 + min2);
      } else {
        s3 = delta / (2 - max2 - min2);
      }
      return [h3, s3 * 100, l * 100];
    };
    convert2.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h3;
      let s3;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const v = Math.max(r, g, b2);
      const diff = v - Math.min(r, g, b2);
      const diffc = function(c2) {
        return (v - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h3 = 0;
        s3 = 0;
      } else {
        s3 = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b2);
        if (r === v) {
          h3 = bdif - gdif;
        } else if (g === v) {
          h3 = 1 / 3 + rdif - bdif;
        } else if (b2 === v) {
          h3 = 2 / 3 + gdif - rdif;
        }
        if (h3 < 0) {
          h3 += 1;
        } else if (h3 > 1) {
          h3 -= 1;
        }
      }
      return [
        h3 * 360,
        s3 * 100,
        v * 100
      ];
    };
    convert2.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b2 = rgb[2];
      const h3 = convert2.rgb.hsl(rgb)[0];
      const w2 = 1 / 255 * Math.min(r, Math.min(g, b2));
      b2 = 1 - 1 / 255 * Math.max(r, Math.max(g, b2));
      return [h3, w2 * 100, b2 * 100];
    };
    convert2.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const k2 = Math.min(1 - r, 1 - g, 1 - b2);
      const c2 = (1 - r - k2) / (1 - k2) || 0;
      const m3 = (1 - g - k2) / (1 - k2) || 0;
      const y3 = (1 - b2 - k2) / (1 - k2) || 0;
      return [c2 * 100, m3 * 100, y3 * 100, k2 * 100];
    };
    function comparativeDistance(x2, y3) {
      return (x2[0] - y3[0]) ** 2 + (x2[1] - y3[1]) ** 2 + (x2[2] - y3[2]) ** 2;
    }
    convert2.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert2.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b2 = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
      const x2 = r * 0.4124 + g * 0.3576 + b2 * 0.1805;
      const y3 = r * 0.2126 + g * 0.7152 + b2 * 0.0722;
      const z2 = r * 0.0193 + g * 0.1192 + b2 * 0.9505;
      return [x2 * 100, y3 * 100, z2 * 100];
    };
    convert2.rgb.lab = function(rgb) {
      const xyz = convert2.rgb.xyz(rgb);
      let x2 = xyz[0];
      let y3 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y3 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l = 116 * y3 - 16;
      const a3 = 500 * (x2 - y3);
      const b2 = 200 * (y3 - z2);
      return [l, a3, b2];
    };
    convert2.hsl.rgb = function(hsl) {
      const h3 = hsl[0] / 360;
      const s3 = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s3 === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s3);
      } else {
        t2 = l + s3 - l * s3;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h3 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert2.hsl.hsv = function(hsl) {
      const h3 = hsl[0];
      let s3 = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s3;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s3 *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s3) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s3 / (l + s3);
      return [h3, sv * 100, v * 100];
    };
    convert2.hsv.rgb = function(hsv) {
      const h3 = hsv[0] / 60;
      const s3 = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h3) % 6;
      const f = h3 - Math.floor(h3);
      const p = 255 * v * (1 - s3);
      const q2 = 255 * v * (1 - s3 * f);
      const t2 = 255 * v * (1 - s3 * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t2, p];
        case 1:
          return [q2, v, p];
        case 2:
          return [p, v, t2];
        case 3:
          return [p, q2, v];
        case 4:
          return [t2, p, v];
        case 5:
          return [v, p, q2];
      }
    };
    convert2.hsv.hsl = function(hsv) {
      const h3 = hsv[0];
      const s3 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s3) * v;
      const lmin = (2 - s3) * vmin;
      sl = s3 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h3, sl * 100, l * 100];
    };
    convert2.hwb.rgb = function(hwb) {
      const h3 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h3);
      const v = 1 - bl;
      f = 6 * h3 - i2;
      if ((i2 & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b2;
      switch (i2) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b2 = wh;
          break;
        case 1:
          r = n;
          g = v;
          b2 = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b2 = n;
          break;
        case 3:
          r = wh;
          g = n;
          b2 = v;
          break;
        case 4:
          r = n;
          g = wh;
          b2 = v;
          break;
        case 5:
          r = v;
          g = wh;
          b2 = n;
          break;
      }
      return [r * 255, g * 255, b2 * 255];
    };
    convert2.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m3 = cmyk[1] / 100;
      const y3 = cmyk[2] / 100;
      const k2 = cmyk[3] / 100;
      const r = 1 - Math.min(1, c2 * (1 - k2) + k2);
      const g = 1 - Math.min(1, m3 * (1 - k2) + k2);
      const b2 = 1 - Math.min(1, y3 * (1 - k2) + k2);
      return [r * 255, g * 255, b2 * 255];
    };
    convert2.xyz.rgb = function(xyz) {
      const x2 = xyz[0] / 100;
      const y3 = xyz[1] / 100;
      const z2 = xyz[2] / 100;
      let r;
      let g;
      let b2;
      r = x2 * 3.2406 + y3 * -1.5372 + z2 * -0.4986;
      g = x2 * -0.9689 + y3 * 1.8758 + z2 * 0.0415;
      b2 = x2 * 0.0557 + y3 * -0.204 + z2 * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b2 = Math.min(Math.max(0, b2), 1);
      return [r * 255, g * 255, b2 * 255];
    };
    convert2.xyz.lab = function(xyz) {
      let x2 = xyz[0];
      let y3 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y3 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l = 116 * y3 - 16;
      const a3 = 500 * (x2 - y3);
      const b2 = 200 * (y3 - z2);
      return [l, a3, b2];
    };
    convert2.lab.xyz = function(lab) {
      const l = lab[0];
      const a3 = lab[1];
      const b2 = lab[2];
      let x2;
      let y3;
      let z2;
      y3 = (l + 16) / 116;
      x2 = a3 / 500 + y3;
      z2 = y3 - b2 / 200;
      const y22 = y3 ** 3;
      const x22 = x2 ** 3;
      const z22 = z2 ** 3;
      y3 = y22 > 8856e-6 ? y22 : (y3 - 16 / 116) / 7.787;
      x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x2 *= 95.047;
      y3 *= 100;
      z2 *= 108.883;
      return [x2, y3, z2];
    };
    convert2.lab.lch = function(lab) {
      const l = lab[0];
      const a3 = lab[1];
      const b2 = lab[2];
      let h3;
      const hr = Math.atan2(b2, a3);
      h3 = hr * 360 / 2 / Math.PI;
      if (h3 < 0) {
        h3 += 360;
      }
      const c2 = Math.sqrt(a3 * a3 + b2 * b2);
      return [l, c2, h3];
    };
    convert2.lch.lab = function(lch) {
      const l = lch[0];
      const c2 = lch[1];
      const h3 = lch[2];
      const hr = h3 / 360 * 2 * Math.PI;
      const a3 = c2 * Math.cos(hr);
      const b2 = c2 * Math.sin(hr);
      return [l, a3, b2];
    };
    convert2.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b2] = args;
      let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert2.hsv.ansi16 = function(args) {
      return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
    };
    convert2.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b2 = args[2];
      if (r === g && g === b2) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b2 / 255 * 5);
      return ansi;
    };
    convert2.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b2 = (color >> 2 & 1) * mult * 255;
      return [r, g, b2];
    };
    convert2.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b2 = rem % 6 / 5 * 255;
      return [r, g, b2];
    };
    convert2.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.hex.rgb = function(args) {
      const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      let colorString = match2[0];
      if (match2[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b2 = integer & 255;
      return [r, g, b2];
    };
    convert2.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const max2 = Math.max(Math.max(r, g), b2);
      const min2 = Math.min(Math.min(r, g), b2);
      const chroma = max2 - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r) {
        hue = (g - b2) / chroma % 6;
      } else if (max2 === g) {
        hue = 2 + (b2 - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert2.hsl.hcg = function(hsl) {
      const s3 = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c2 = l < 0.5 ? 2 * s3 * l : 2 * s3 * (1 - l);
      let f = 0;
      if (c2 < 1) {
        f = (l - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f * 100];
    };
    convert2.hsv.hcg = function(hsv) {
      const s3 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c2 = s3 * v;
      let f = 0;
      if (c2 < 1) {
        f = (v - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f * 100];
    };
    convert2.hcg.rgb = function(hcg) {
      const h3 = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c2 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h3 % 1 * 6;
      const v = hi % 1;
      const w2 = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg = (1 - c2) * g;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert2.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c2 + g * (1 - c2);
      let f = 0;
      if (v > 0) {
        f = c2 / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert2.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c2) + 0.5 * c2;
      let s3 = 0;
      if (l > 0 && l < 0.5) {
        s3 = c2 / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s3 = c2 / (2 * (1 - l));
      }
      return [hcg[0], s3 * 100, l * 100];
    };
    convert2.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c2 + g * (1 - c2);
      return [hcg[0], (v - c2) * 100, (1 - v) * 100];
    };
    convert2.hwb.hcg = function(hwb) {
      const w2 = hwb[1] / 100;
      const b2 = hwb[2] / 100;
      const v = 1 - b2;
      const c2 = v - w2;
      let g = 0;
      if (c2 < 1) {
        g = (v - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g * 100];
    };
    convert2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert2.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert2.gray.hsv = convert2.gray.hsl;
    convert2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert2.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        graph[models[i2]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
          const adjacent = adjacents[i2];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path2 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path2.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path2;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        const toModel = models[i2];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert2 = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i2 = 0; i2 < len; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert2[fromModel] = {};
      Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert2;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root2, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root2, createExporter(module2.exports)));
      } else {
        factory(createExporter(root2));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root2) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v) {
          return exports3[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d3[p] = b2[p];
      };
      __extends2 = function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest2 = function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
              t2[p[i2]] = s3[p[i2]];
          }
        return t2;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d3 = decorators[i2])
              r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
        return c2 > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve6) {
            resolve6(value);
          });
        }
        return new (P || (P = Promise))(function(resolve6, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve6(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f, y3, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
                return t2;
              if (y3 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y3 = 0;
            } finally {
              f = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m3, o) {
        for (var p in m3)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m3, p);
      };
      __createBinding2 = Object.create ? function(o, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m3, k2);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m3[k2];
      };
      __values2 = function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
        if (m3)
          return m3.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m3 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m3)
          return o;
        var i2 = m3.call(o), r, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
            ar.push(r.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r && !r.done && (m3 = i2["return"]))
              m3.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read2(arguments[i2]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s3 += arguments[i2].length;
        for (var r = Array(s3), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a3 = arguments[i2], j = 0, jl = a3.length; j < jl; j++, k2++)
            r[k2] = a3[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g[n])
            i2[n] = function(v) {
              return new Promise(function(a3, b2) {
                q2.push([n, v, a3, b2]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f) {
          i2[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o[Symbol.asyncIterator], i2;
        return m3 ? m3.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o[n] && function(v) {
            return new Promise(function(resolve6, reject) {
              v = o[n](v), settle(resolve6, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve6, reject, d3, v) {
          Promise.resolve(v).then(function(v2) {
            resolve6({ value: v2, done: d3 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding2(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// node_modules/p-map/index.js
var require_p_map = __commonJS({
  "node_modules/p-map/index.js"(exports2, module2) {
    "use strict";
    var pMap = (iterable, mapper, options) => new Promise((resolve6, reject) => {
      options = Object.assign({
        concurrency: Infinity
      }, options);
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      const { concurrency } = options;
      if (!(typeof concurrency === "number" && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const ret = [];
      const iterator2 = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator2.next();
        const i2 = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            resolve6(ret);
          }
          return;
        }
        resolvingCount++;
        Promise.resolve(nextItem.value).then((element) => mapper(element, i2)).then(
          (value) => {
            ret[i2] = value;
            resolvingCount--;
            next();
          },
          (error) => {
            isRejected = true;
            reject(error);
          }
        );
      };
      for (let i2 = 0; i2 < concurrency; i2++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
    module2.exports = pMap;
    module2.exports.default = pMap;
  }
});

// node_modules/p-filter/index.js
var require_p_filter = __commonJS({
  "node_modules/p-filter/index.js"(exports2, module2) {
    "use strict";
    var pMap = require_p_map();
    var pFilter3 = async (iterable, filterer, options) => {
      const values = await pMap(
        iterable,
        (element, index) => Promise.all([filterer(element, index), element]),
        options
      );
      return values.filter((value) => Boolean(value[0])).map((value) => value[1]);
    };
    module2.exports = pFilter3;
    module2.exports.default = pFilter3;
  }
});

// node_modules/command-exists/lib/command-exists.js
var require_command_exists = __commonJS({
  "node_modules/command-exists/lib/command-exists.js"(exports2, module2) {
    "use strict";
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var fs4 = require("fs");
    var path2 = require("path");
    var access = fs4.access;
    var accessSync = fs4.accessSync;
    var constants = fs4.constants || fs4;
    var isUsingWindows = process.platform == "win32";
    var fileNotExists = function(commandName, callback) {
      access(
        commandName,
        constants.F_OK,
        function(err) {
          callback(!err);
        }
      );
    };
    var fileNotExistsSync = function(commandName) {
      try {
        accessSync(commandName, constants.F_OK);
        return false;
      } catch (e2) {
        return true;
      }
    };
    var localExecutable = function(commandName, callback) {
      access(
        commandName,
        constants.F_OK | constants.X_OK,
        function(err) {
          callback(null, !err);
        }
      );
    };
    var localExecutableSync = function(commandName) {
      try {
        accessSync(commandName, constants.F_OK | constants.X_OK);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var commandExistsUnix = function(commandName, cleanedCommandName, callback) {
      fileNotExists(commandName, function(isFile) {
        if (!isFile) {
          var child = exec2(
            "command -v " + cleanedCommandName + " 2>/dev/null && { echo >&1 " + cleanedCommandName + "; exit 0; }",
            function(error, stdout, stderr) {
              callback(null, !!stdout);
            }
          );
          return;
        }
        localExecutable(commandName, callback);
      });
    };
    var commandExistsWindows = function(commandName, cleanedCommandName, callback) {
      if (!/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName)) {
        callback(null, false);
        return;
      }
      var child = exec2(
        "where " + cleanedCommandName,
        function(error) {
          if (error !== null) {
            callback(null, false);
          } else {
            callback(null, true);
          }
        }
      );
    };
    var commandExistsUnixSync = function(commandName, cleanedCommandName) {
      if (fileNotExistsSync(commandName)) {
        try {
          var stdout = execSync(
            "command -v " + cleanedCommandName + " 2>/dev/null && { echo >&1 " + cleanedCommandName + "; exit 0; }"
          );
          return !!stdout;
        } catch (error) {
          return false;
        }
      }
      return localExecutableSync(commandName);
    };
    var commandExistsWindowsSync = function(commandName, cleanedCommandName, callback) {
      if (!/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName)) {
        return false;
      }
      try {
        var stdout = execSync("where " + cleanedCommandName, { stdio: [] });
        return !!stdout;
      } catch (error) {
        return false;
      }
    };
    var cleanInput = function(s3) {
      if (/[^A-Za-z0-9_\/:=-]/.test(s3)) {
        s3 = "'" + s3.replace(/'/g, "'\\''") + "'";
        s3 = s3.replace(/^(?:'')+/g, "").replace(/\\'''/g, "\\'");
      }
      return s3;
    };
    if (isUsingWindows) {
      cleanInput = function(s3) {
        var isPathName = /[\\]/.test(s3);
        if (isPathName) {
          var dirname = '"' + path2.dirname(s3) + '"';
          var basename2 = '"' + path2.basename(s3) + '"';
          return dirname + ":" + basename2;
        }
        return '"' + s3 + '"';
      };
    }
    module2.exports = function commandExists2(commandName, callback) {
      var cleanedCommandName = cleanInput(commandName);
      if (!callback && typeof Promise !== "undefined") {
        return new Promise(function(resolve6, reject) {
          commandExists2(commandName, function(error, output) {
            if (output) {
              resolve6(commandName);
            } else {
              reject(error);
            }
          });
        });
      }
      if (isUsingWindows) {
        commandExistsWindows(commandName, cleanedCommandName, callback);
      } else {
        commandExistsUnix(commandName, cleanedCommandName, callback);
      }
    };
    module2.exports.sync = function(commandName) {
      var cleanedCommandName = cleanInput(commandName);
      if (isUsingWindows) {
        return commandExistsWindowsSync(commandName, cleanedCommandName);
      } else {
        return commandExistsUnixSync(commandName, cleanedCommandName);
      }
    };
  }
});

// node_modules/command-exists/index.js
var require_command_exists2 = __commonJS({
  "node_modules/command-exists/index.js"(exports2, module2) {
    module2.exports = require_command_exists();
  }
});

// node_modules/isbinaryfile/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/isbinaryfile/lib/index.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve6) {
          resolve6(value);
        });
      }
      return new (P || (P = Promise))(function(resolve6, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve6(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBinaryFileSync = exports2.isBinaryFile = void 0;
    var fs4 = require("fs");
    var util_1 = require("util");
    var statAsync = util_1.promisify(fs4.stat);
    var openAsync = util_1.promisify(fs4.open);
    var closeAsync = util_1.promisify(fs4.close);
    var MAX_BYTES = 512;
    var Reader = class {
      constructor(fileBuffer, size) {
        this.fileBuffer = fileBuffer;
        this.size = size;
        this.offset = 0;
        this.error = false;
      }
      hasError() {
        return this.error;
      }
      nextByte() {
        if (this.offset === this.size || this.hasError()) {
          this.error = true;
          return 255;
        }
        return this.fileBuffer[this.offset++];
      }
      next(len) {
        const n = new Array();
        for (let i2 = 0; i2 < len; i2++) {
          n[i2] = this.nextByte();
        }
        return n;
      }
    };
    function readProtoVarInt(reader) {
      let idx = 0;
      let varInt = 0;
      while (!reader.hasError()) {
        const b2 = reader.nextByte();
        varInt = varInt | (b2 & 127) << 7 * idx;
        if ((b2 & 128) === 0) {
          break;
        }
        idx++;
      }
      return varInt;
    }
    function readProtoMessage(reader) {
      const varInt = readProtoVarInt(reader);
      const wireType = varInt & 7;
      switch (wireType) {
        case 0:
          readProtoVarInt(reader);
          return true;
        case 1:
          reader.next(8);
          return true;
        case 2:
          const len = readProtoVarInt(reader);
          reader.next(len);
          return true;
        case 5:
          reader.next(4);
          return true;
      }
      return false;
    }
    function isBinaryProto(fileBuffer, totalBytes) {
      const reader = new Reader(fileBuffer, totalBytes);
      let numMessages = 0;
      while (true) {
        if (!readProtoMessage(reader) && !reader.hasError()) {
          return false;
        }
        if (reader.hasError()) {
          break;
        }
        numMessages++;
      }
      return numMessages > 0;
    }
    function isBinaryFile2(file, size) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (isString(file)) {
          const stat3 = yield statAsync(file);
          isStatFile(stat3);
          const fileDescriptor = yield openAsync(file, "r");
          const allocBuffer = Buffer.alloc(MAX_BYTES);
          return new Promise((fulfill, reject) => {
            fs4.read(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0, (err, bytesRead, _) => {
              closeAsync(fileDescriptor);
              if (err) {
                reject(err);
              } else {
                fulfill(isBinaryCheck(allocBuffer, bytesRead));
              }
            });
          });
        } else {
          if (size === void 0) {
            size = file.length;
          }
          return isBinaryCheck(file, size);
        }
      });
    }
    exports2.isBinaryFile = isBinaryFile2;
    function isBinaryFileSync(file, size) {
      if (isString(file)) {
        const stat3 = fs4.statSync(file);
        isStatFile(stat3);
        const fileDescriptor = fs4.openSync(file, "r");
        const allocBuffer = Buffer.alloc(MAX_BYTES);
        const bytesRead = fs4.readSync(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0);
        fs4.closeSync(fileDescriptor);
        return isBinaryCheck(allocBuffer, bytesRead);
      } else {
        if (size === void 0) {
          size = file.length;
        }
        return isBinaryCheck(file, size);
      }
    }
    exports2.isBinaryFileSync = isBinaryFileSync;
    function isBinaryCheck(fileBuffer, bytesRead) {
      if (bytesRead === 0) {
        return false;
      }
      let suspiciousBytes = 0;
      const totalBytes = Math.min(bytesRead, MAX_BYTES);
      if (bytesRead >= 3 && fileBuffer[0] === 239 && fileBuffer[1] === 187 && fileBuffer[2] === 191) {
        return false;
      }
      if (bytesRead >= 4 && fileBuffer[0] === 0 && fileBuffer[1] === 0 && fileBuffer[2] === 254 && fileBuffer[3] === 255) {
        return false;
      }
      if (bytesRead >= 4 && fileBuffer[0] === 255 && fileBuffer[1] === 254 && fileBuffer[2] === 0 && fileBuffer[3] === 0) {
        return false;
      }
      if (bytesRead >= 4 && fileBuffer[0] === 132 && fileBuffer[1] === 49 && fileBuffer[2] === 149 && fileBuffer[3] === 51) {
        return false;
      }
      if (totalBytes >= 5 && fileBuffer.slice(0, 5).toString() === "%PDF-") {
        return true;
      }
      if (bytesRead >= 2 && fileBuffer[0] === 254 && fileBuffer[1] === 255) {
        return false;
      }
      if (bytesRead >= 2 && fileBuffer[0] === 255 && fileBuffer[1] === 254) {
        return false;
      }
      for (let i2 = 0; i2 < totalBytes; i2++) {
        if (fileBuffer[i2] === 0) {
          return true;
        } else if ((fileBuffer[i2] < 7 || fileBuffer[i2] > 14) && (fileBuffer[i2] < 32 || fileBuffer[i2] > 127)) {
          if (fileBuffer[i2] > 193 && fileBuffer[i2] < 224 && i2 + 1 < totalBytes) {
            i2++;
            if (fileBuffer[i2] > 127 && fileBuffer[i2] < 192) {
              continue;
            }
          } else if (fileBuffer[i2] > 223 && fileBuffer[i2] < 240 && i2 + 2 < totalBytes) {
            i2++;
            if (fileBuffer[i2] > 127 && fileBuffer[i2] < 192 && fileBuffer[i2 + 1] > 127 && fileBuffer[i2 + 1] < 192) {
              i2++;
              continue;
            }
          }
          suspiciousBytes++;
          if (i2 >= 32 && suspiciousBytes * 100 / totalBytes > 10) {
            return true;
          }
        }
      }
      if (suspiciousBytes * 100 / totalBytes > 10) {
        return true;
      }
      if (suspiciousBytes > 1 && isBinaryProto(fileBuffer, totalBytes)) {
        return true;
      }
      return false;
    }
    function isString(x2) {
      return typeof x2 === "string";
    }
    function isStatFile(stat3) {
      if (!stat3.isFile()) {
        throw new Error(`Path provided was not a file!`);
      }
    }
  }
});

// node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "node_modules/is-docker/index.js"(exports2, module2) {
    "use strict";
    var fs4 = require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs4.statSync("/.dockerenv");
        return true;
      } catch (_) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs4.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_) {
        return false;
      }
    }
    module2.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "node_modules/is-wsl/index.js"(exports2, module2) {
    "use strict";
    var os3 = require("os");
    var fs4 = require("fs");
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os3.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs4.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module2.exports = isWsl;
    } else {
      module2.exports = isWsl();
    }
  }
});

// node_modules/define-lazy-prop/index.js
var require_define_lazy_prop = __commonJS({
  "node_modules/define-lazy-prop/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (object, propertyName, fn) => {
      const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define2(result);
          return result;
        },
        set(value) {
          define2(value);
        }
      });
      return object;
    };
  }
});

// node_modules/open/index.js
var require_open = __commonJS({
  "node_modules/open/index.js"(exports2, module2) {
    var path2 = require("path");
    var childProcess = require("child_process");
    var { promises: fs4, constants: fsConstants } = require("fs");
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker();
    var defineLazyProperty = require_define_lazy_prop();
    var localXdgOpenPath = path2.join(__dirname, "xdg-open");
    var { platform, arch } = process;
    var getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs4.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs4.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array, mapper) => {
      let latestError;
      for (const item of array) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    var baseOpen = async (options) => {
      options = {
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false,
        ...options
      };
      if (Array.isArray(options.app)) {
        return pTryEach(options.app, (singleApp) => baseOpen({
          ...options,
          app: singleApp
        }));
      }
      let { name: app, arguments: appArguments = [] } = options.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen({
          ...options,
          app: {
            name: appName,
            arguments: appArguments
          }
        }));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (options.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "\u2013ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options.target) {
            appArguments.unshift(options.target);
          }
        } else if (options.target) {
          encodedArguments.push(`"${options.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs4.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options.target) {
        cliArguments.push(options.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve6, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (options.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve6(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    var open2 = (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen({
        ...options,
        target
      });
    };
    var openApp = (name, options) => {
      if (typeof name !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen({
        ...options,
        app: {
          name,
          arguments: appArguments
        }
      });
    };
    function detectArchBinary(binary) {
      if (typeof binary === "string" || Array.isArray(binary)) {
        return binary;
      }
      const { [arch]: archBinary } = binary;
      if (!archBinary) {
        throw new Error(`${arch} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open2.apps = apps;
    open2.openApp = openApp;
    module2.exports = open2;
  }
});

// node_modules/pretty-bytes/index.js
var require_pretty_bytes = __commonJS({
  "node_modules/pretty-bytes/index.js"(exports2, module2) {
    "use strict";
    var BYTE_UNITS = [
      "B",
      "kB",
      "MB",
      "GB",
      "TB",
      "PB",
      "EB",
      "ZB",
      "YB"
    ];
    var BIBYTE_UNITS = [
      "B",
      "kiB",
      "MiB",
      "GiB",
      "TiB",
      "PiB",
      "EiB",
      "ZiB",
      "YiB"
    ];
    var BIT_UNITS = [
      "b",
      "kbit",
      "Mbit",
      "Gbit",
      "Tbit",
      "Pbit",
      "Ebit",
      "Zbit",
      "Ybit"
    ];
    var BIBIT_UNITS = [
      "b",
      "kibit",
      "Mibit",
      "Gibit",
      "Tibit",
      "Pibit",
      "Eibit",
      "Zibit",
      "Yibit"
    ];
    var toLocaleString = (number, locale2, options) => {
      let result = number;
      if (typeof locale2 === "string" || Array.isArray(locale2)) {
        result = number.toLocaleString(locale2, options);
      } else if (locale2 === true || options !== void 0) {
        result = number.toLocaleString(void 0, options);
      }
      return result;
    };
    module2.exports = (number, options) => {
      if (!Number.isFinite(number)) {
        throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
      }
      options = Object.assign({ bits: false, binary: false }, options);
      const UNITS = options.bits ? options.binary ? BIBIT_UNITS : BIT_UNITS : options.binary ? BIBYTE_UNITS : BYTE_UNITS;
      if (options.signed && number === 0) {
        return ` 0 ${UNITS[0]}`;
      }
      const isNegative = number < 0;
      const prefix = isNegative ? "-" : options.signed ? "+" : "";
      if (isNegative) {
        number = -number;
      }
      let localeOptions;
      if (options.minimumFractionDigits !== void 0) {
        localeOptions = { minimumFractionDigits: options.minimumFractionDigits };
      }
      if (options.maximumFractionDigits !== void 0) {
        localeOptions = Object.assign({ maximumFractionDigits: options.maximumFractionDigits }, localeOptions);
      }
      if (number < 1) {
        const numberString2 = toLocaleString(number, options.locale, localeOptions);
        return prefix + numberString2 + " " + UNITS[0];
      }
      const exponent = Math.min(Math.floor(options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3), UNITS.length - 1);
      number /= Math.pow(options.binary ? 1024 : 1e3, exponent);
      if (!localeOptions) {
        number = number.toPrecision(3);
      }
      const numberString = toLocaleString(Number(number), options.locale, localeOptions);
      const unit = UNITS[exponent];
      return prefix + numberString + " " + unit;
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(src_exports);

// ../coc-helper/lib/esm/index.js
var import_coc15 = require("coc.nvim");

// ../coc-helper/lib/esm/FloatingWindow.js
var import_coc11 = require("coc.nvim");

// ../coc-helper/lib/esm/notifier.js
var import_coc5 = require("coc.nvim");

// ../coc-helper/lib/esm/util/collection.js
var compactI = (arr) => arr.filter((it) => it !== void 0 && it !== null);

// ../coc-helper/lib/esm/util/config.js
var import_coc2 = require("coc.nvim");

// ../coc-helper/lib/esm/util/text.js
var import_coc = require("coc.nvim");

// ../coc-helper/lib/esm/util/env.js
var isWindows = process.platform === "win32";
var isMacintosh = process.platform === "darwin";
var isLinux = process.platform === "linux";
var isTest = process.env.NODE_ENV === "test";

// ../coc-helper/lib/esm/util/text.js
async function displayWidth(content) {
  return await import_coc.workspace.nvim.call("strdisplaywidth", [content]);
}

// ../coc-helper/lib/esm/util/log.js
var import_coc3 = require("coc.nvim");
var import_util = __toESM(require("util"));
var levelList = [
  "trace",
  "debug",
  "info",
  "warn",
  "error",
  "fatal",
  "off"
];
var levelErrorNum = levelList.indexOf("error");
function formatDate(date) {
  return `${date.toLocaleString()} ${date.getMilliseconds().toString().padStart(3, "0")}`;
}
var HelperLogger = class {
  constructor(channelName) {
    this.channelName = channelName;
    this.timeMarkers = /* @__PURE__ */ new Map();
    this.levelStatus = "trace";
    this.levelNumber = levelList.indexOf(this.levelStatus);
    this.appendLine = (line) => {
      this.outputChannel.appendLine(line);
    };
    this.appendErrorLine = (line) => {
      if (isTest) {
        console.error(line);
      } else {
        void import_coc3.window.showErrorMessage(line);
      }
    };
    this.log = (levelName, data) => {
      var _a, _b;
      const levelNum = levelList[levelName];
      if (levelNum < this.levelNumber) {
        return;
      }
      const prefix = `[${formatDate(new Date())}] [${levelName}]: `;
      if (data instanceof Error) {
        this.appendLine(`${prefix}${(_a = data.stack) !== null && _a !== void 0 ? _a : data.toString()}`);
        this.appendErrorLine(data.message);
        if (isTest) {
          console.error((_b = data.stack) !== null && _b !== void 0 ? _b : data.toString());
        }
        return;
      }
      this.appendLine(`${prefix}${data}`);
      if (levelNum > levelErrorNum) {
        this.appendErrorLine(data);
      }
    };
    this.trace = (line) => {
      this.log("trace", line);
    };
    this.debug = (line) => {
      this.log("debug", line);
    };
    this.info = (line) => {
      this.log("info", line);
    };
    this.warn = (line) => {
      this.log("warn", line);
    };
    this.error = (data) => {
      if (!(data instanceof Error)) {
        data = new Error(data);
      }
      this.log("error", data);
    };
    this.fatal = (data) => {
      this.log("fatal", data);
    };
    this.prettyPrint = (...data) => {
      this.info(prettyObject(...data));
      this.appendErrorLine(`[${formatDate(new Date())}] ${prettyObject(...data)}`);
    };
  }
  set level(level) {
    this.levelStatus = level;
    this.levelNumber = levelList[level];
  }
  get level() {
    return this.levelStatus;
  }
  dispose() {
    var _a;
    (_a = this.outputChannel_) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  get outputChannel() {
    if (!this.outputChannel_) {
      this.outputChannel_ = import_coc3.window.createOutputChannel(this.channelName);
    }
    return this.outputChannel_;
  }
  time(label = "default") {
    this.timeMarkers.set(label, new Date().valueOf());
  }
  timeElapsed(label = "default") {
    const time = this.timeMarkers.get(label);
    if (time !== void 0) {
      return new Date().valueOf() - time;
    }
  }
  timeLog(label = "default") {
    const time = this.timeElapsed(label);
    if (time !== void 0) {
      this.appendLine(`${label}: ${time} ms`);
    }
  }
  measureTime(task) {
    const time = new Date().valueOf();
    const result = task();
    if (result instanceof Promise) {
      return result.then((r) => {
        return [r, new Date().valueOf() - time];
      });
    }
    return [result, new Date().valueOf() - time];
  }
  measureTask(task, label = "default", level = "info") {
    const response = this.measureTime(task);
    if (!("then" in response)) {
      const [result, time] = response;
      this.log(level, `[measureTask] ${label}: ${time} ms`);
      return result;
    }
    return response.then(([result, time]) => {
      this.log(level, `${label}: ${time} ms`);
      return result;
    });
  }
  asyncCatch(fn) {
    return async (...args) => {
      try {
        return await fn(...args);
      } catch (e2) {
        this.error(e2);
      }
    };
  }
};
var helperLogger = new HelperLogger("coc-helper");
function prettyObject(...data) {
  return data.map((d3) => import_util.default.inspect(d3)).join(" ");
}

// ../coc-helper/lib/esm/_package.json
var package_default = {
  name: "coc-helper",
  version: "0.16.3",
  description: "Helpers for coc.nvim",
  module: "lib/esm/index.js",
  main: "lib/cjs/index.js",
  homepage: "https://github.com/weirongxu/coc-helper",
  repository: "git@github.com:weirongxu/coc-helper.git",
  author: "Weirong Xu <weirongxu.raidou@gmail.com>",
  license: "MIT",
  files: [
    "lib",
    "jest.config.js",
    "tests"
  ],
  scripts: {
    clean: "shx rm -rf lib",
    "copy:pkg": "shx cp package.json src/_package.json",
    "build:esm": "tsc -p ./tsconfig.prod.json --module es2020 --outDir lib/esm",
    "build:cjs": "tsc -p ./tsconfig.prod.json --module commonjs --outDir lib/cjs",
    build: "run-s clean copy:pkg build:esm build:cjs",
    lint: "eslint src --ext ts",
    prepare: "run-s clean build",
    unittest: "jest",
    test: "run-s copy:pkg lint unittest"
  },
  engines: {
    coc: "^0.0.77"
  },
  activationEvents: [
    "*"
  ],
  prettier: {
    singleQuote: true,
    printWidth: 80,
    semi: true,
    trailingComma: "all"
  },
  peerDependencies: {
    "coc.nvim": "*"
  },
  devDependencies: {
    "@chemzqm/neovim": "^6.1.1",
    "@raidou/eslint-config-base": "^1.6.0",
    "@types/eslint": "^8.4.10",
    "@types/jest": "^29.2.5",
    "@types/node": "^18.11.18",
    "@types/rimraf": "^3.0.2",
    "@types/uuid": "^9.0.0",
    "coc.nvim": "0.0.83-next.9",
    eslint: "^8.31.0",
    jest: "^29.3.1",
    log4js: "^6.7.1",
    "npm-run-all": "^4.1.5",
    prettier: "^2.8.2",
    shx: "^0.3.4",
    "ts-jest": "^29.0.4",
    typescript: "^4.9.4"
  },
  dependencies: {
    rimraf: "^3.0.2",
    uuid: "^9.0.0"
  }
};

// ../coc-helper/lib/esm/util/version.js
var version = package_default.version;
var versionName = version.replace(/[.-]/g, "_");

// ../coc-helper/lib/esm/util/vim.js
var import_coc4 = require("coc.nvim");
async function registerRuntimepath(context2) {
  const { nvim } = import_coc4.workspace;
  const extensionPath = context2.extensionPath;
  const paths = await nvim.runtimePaths;
  if (!paths.includes(extensionPath)) {
    await nvim.command(`execute 'noa set rtp+='.fnameescape('${extensionPath.replace(/'/g, "''")}')`);
  }
}

// ../coc-helper/lib/esm/notifier.js
var Notifier = class {
  static async run(notifier) {
    if (!notifier) {
      return;
    }
    if ("then" in notifier) {
      const awaitedNotifier = await notifier;
      if (awaitedNotifier) {
        return awaitedNotifier.run();
      }
    } else {
      return notifier.run();
    }
  }
  static notifyAll(lazyNotifies) {
    for (const n of lazyNotifies) {
      if (n) {
        n.notify();
      }
    }
  }
  static async runAll(notifierPromises) {
    const notifiers = await Promise.all(notifierPromises);
    import_coc5.workspace.nvim.pauseNotification();
    this.notifyAll(notifiers);
    return import_coc5.workspace.nvim.resumeNotification();
  }
  static combine(notifiers) {
    const compactedNotifiers = compactI(notifiers);
    if (compactedNotifiers.length < 1) {
      return Notifier.noop();
    }
    if (compactedNotifiers.length === 1) {
      return compactedNotifiers[0];
    }
    return compactedNotifiers.reduce((ret, cur) => ret.concat(cur), Notifier.noop());
  }
  static noop() {
    return this.create(() => {
    });
  }
  static create(notify) {
    return new Notifier(notify);
  }
  constructor(notify) {
    this.notifyFns = [];
    this.notifyFns.push(notify);
  }
  async run() {
    return Notifier.runAll([this]);
  }
  notify() {
    for (const fn of this.notifyFns) {
      fn();
    }
  }
  concat(notifier) {
    this.notifyFns.push(...notifier.notifyFns);
    return this;
  }
};

// ../coc-helper/lib/esm/modules/floating.js
var import_coc8 = require("coc.nvim");

// ../coc-helper/lib/esm/VimModule.js
var import_coc6 = require("coc.nvim");

// ../coc-helper/lib/esm/util/module.js
var globalModuleIdSym = Symbol("helper_module_max_id");
function getModuleId(key) {
  if (!(globalModuleIdSym in global)) {
    global[globalModuleIdSym] = {};
  }
  const moduleIds = global[globalModuleIdSym];
  if (!(key in moduleIds)) {
    moduleIds[key] = 0;
  }
  moduleIds[key] += 1;
  return moduleIds[key];
}

// ../coc-helper/lib/esm/VimModule.js
var mid = getModuleId("VimModule");
var globalKey = `coc_helper_module_m${mid}_v${versionName}`;
var globalVariable = `g:${globalKey}`;
var callFunc = `CocHelperCallFn_m${mid}_v${versionName}`;
var declareVar = `CocHelperCallVar_m${mid}_v${versionName}`;
function filterLineCont(content) {
  return content.replace(/\n\s*\\/g, "");
}
var VimModule = class {
  static async init(context2) {
    this.inited = true;
    await import_coc6.workspace.nvim.call("execute", `
        if !exists('${globalVariable}')
          let ${globalVariable} = {}
        endif

        function! ${callFunc}(module_key, method_name, args)
          try
            return call(${globalVariable}[a:module_key][a:method_name], a:args)
          catch
            let ex = v:exception
            let msg = printf('error when call %s.%s.%s, args: [%s]', '${globalVariable}', a:module_key, a:method_name, join(a:args, ','))
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction

        function! ${declareVar}(module_key, var_name, expression)
          try
            let ${globalVariable}[a:module_key][a:var_name] = eval(a:expression)
          catch
            let ex = v:exception
            let msg = printf('error when declare %s.%s.%s, expression: %s', '${globalVariable}', a:module_key, a:var_name, a:expression)
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction
      `);
    const queue = [...this.initQueue];
    while (queue.length) {
      const it = queue.shift();
      try {
        await it.fn(context2);
      } catch (error) {
        helperLogger.error(error);
      }
      if (this.initAfterQueue.length) {
        queue.push(...this.initAfterQueue);
        this.initAfterQueue = [];
      }
    }
  }
  static registerInit(description, fn) {
    if (!this.inited) {
      this.initQueue.push({ description, fn });
    } else {
      this.initAfterQueue.push({ description, fn });
    }
  }
  static create(moduleName, cb) {
    const id = getModuleId("VimModule.module");
    const moduleKey = `${id}_${moduleName}`;
    const vMod = new VimModule(moduleKey);
    let mod = void 0;
    function initedMod() {
      if (!mod) {
        mod = cb(vMod);
      }
      return mod;
    }
    VimModule.registerInit(`module ${moduleKey}`, async () => {
      await import_coc6.workspace.nvim.call("execute", `
          if !exists('${globalVariable}.${moduleKey}')
            let ${globalVariable}.${moduleKey} = {}
          endif
        `);
      initedMod();
    });
    return new Proxy({}, {
      get(_o, key) {
        return Reflect.get(initedMod(), key);
      },
      has(_o, key) {
        return key in initedMod();
      },
      ownKeys() {
        return Object.keys(initedMod());
      }
    });
  }
  constructor(moduleKey) {
    this.moduleKey = moduleKey;
  }
  registerInit(description, fn) {
    if (typeof description === "string") {
      return VimModule.registerInit(description, fn);
    } else {
      return this.registerInit("", description);
    }
  }
  fn(fnName, getContent) {
    const { nvim } = import_coc6.workspace;
    const name = `${globalVariable}.${this.moduleKey}.${fnName}`;
    const content = getContent({ name });
    this.registerInit(`fn ${name}`, async () => {
      helperLogger.debug(`declare fn ${name}`);
      await nvim.call("execute", [filterLineCont(content)]);
    });
    return {
      name,
      inlineCall: (argsExpression = "") => `${callFunc}('${this.moduleKey}', '${fnName}', [${argsExpression}])`,
      call: (...args) => {
        helperLogger.debug(`call ${name}`);
        return nvim.call(callFunc, [
          this.moduleKey,
          fnName,
          args
        ]);
      },
      callNotify: (...args) => {
        helperLogger.debug(`callNotify ${name}`);
        return nvim.call(callFunc, [this.moduleKey, fnName, args], true);
      },
      callNotifier: (...args) => {
        helperLogger.debug(`callNotifier ${name}`);
        return Notifier.create(() => {
          nvim.call(callFunc, [this.moduleKey, fnName, args], true);
        });
      }
    };
  }
  var(varName, expression) {
    const { nvim } = import_coc6.workspace;
    const name = `${globalVariable}.${this.moduleKey}.${varName}`;
    this.registerInit(`var ${name}`, async () => {
      helperLogger.debug(`declare var ${name}`);
      await nvim.call(declareVar, [
        this.moduleKey,
        varName,
        filterLineCont(expression)
      ]);
    });
    return {
      name,
      inline: name,
      get: () => {
        return nvim.eval(name);
      },
      set: async (expression2) => {
        await nvim.call(declareVar, [
          this.moduleKey,
          varName,
          filterLineCont(expression2)
        ]);
      },
      setNotify: (expression2) => {
        nvim.call(declareVar, [this.moduleKey, varName, filterLineCont(expression2)], true);
      },
      setNotifier: (expression2) => {
        return Notifier.create(() => {
          nvim.call(declareVar, [this.moduleKey, varName, filterLineCont(expression2)], true);
        });
      }
    };
  }
};
VimModule.inited = false;
VimModule.initQueue = [];
VimModule.initAfterQueue = [];

// ../coc-helper/lib/esm/modules/buf.js
var import_coc7 = require("coc.nvim");
var bufModule = VimModule.create("buf", (m3) => {
  const isNvim = import_coc7.workspace.isNvim;
  const createByName = m3.fn("create_by_name", ({ name }) => `
      function! ${name}(name) abort
        return bufadd(a:name)
      endfunction
    `);
  return {
    createByName,
    create: m3.fn("create", ({ name }) => isNvim ? `
          function! ${name}(...) abort
            let name = get(a:000, 0, '')
            if name is ''
              return nvim_create_buf(v:false, v:true)
            else
              return ${createByName.inlineCall("name")}
            endif
          endfunction
        ` : `
          function! ${name}(...) abort
            let name = get(a:000, 0, '')
            return ${createByName.inlineCall("name")}
          endfunction
        `)
  };
});

// ../coc-helper/lib/esm/modules/floating.js
var floatingModule = VimModule.create("float", (m3) => {
  const isNvim = import_coc8.workspace.isNvim;
  const initExecute = m3.fn("init_execute", ({ name }) => `
      function! ${name}(ctx, inited_execute) abort
        execute a:inited_execute
      endfunction
    `);
  const openWin = m3.fn("open_win", ({ name }) => isNvim ? `
        function! ${name}(bufnr, focus, win_config, win_hl, inited_execute) abort
          noau let winid = nvim_open_win(a:bufnr, a:focus, a:win_config)
          if !empty(a:win_hl)
            call nvim_win_set_option(winid, 'winhl', a:win_hl)
          endif
          if !empty(a:inited_execute)
            call ${initExecute.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}
          endif
          return winid
        endfunction
      ` : `
        function! ${name}(bufnr, focus, win_config, win_hl, inited_execute) abort
          let winid = popup_create(a:bufnr, a:win_config)
          call ${initExecute.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}

          return winid
        endfunction
      `);
  return {
    create: m3.fn("create", ({ name }) => isNvim ? `
            function! ${name}(name, inited_execute, has_border_buf, border_inited_execute) abort
              let bufnr = ${bufModule.create.inlineCall("a:name")}
              call ${initExecute.inlineCall("{'bufnr': bufnr}, a:inited_execute")}

              let border_bufnr = v:null
              if a:has_border_buf
                let border_bufnr = nvim_create_buf(v:false, v:true)
                call ${initExecute.inlineCall("{'bufnr': border_bufnr}, a:border_inited_execute")}
              endif
              return [bufnr, border_bufnr]
            endfunction
          ` : `
            function! ${name}(name, inited_execute, has_border_buf, border_inited_execute) abort
              let bufnr = ${bufModule.create.inlineCall("a:name")}
              call ${initExecute.inlineCall("{'bufnr': bufnr}, a:inited_execute")}
              return [bufnr, v:null]
            endfunction
          `),
    open: m3.fn("open", ({ name }) => `
        function! ${name}(bufnr, win_config, inited_execute, border_bufnr, border_win_config, border_inited_execute, focus, win_hl) abort
          let winid = ${openWin.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, a:inited_execute")}
          call setbufvar(a:bufnr, 'coc_helper_winid', winid)

          if a:border_bufnr
            let border_winid = ${openWin.inlineCall("a:border_bufnr, v:false, a:border_win_config, a:win_hl, a:border_inited_execute")}
            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)
          endif
        endfunction
      `),
    resume: m3.fn("resume", ({ name }) => `
        function! ${name}(bufnr, win_config, border_bufnr, border_win_config, focus, win_hl) abort
          let winid = ${openWin.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, ''")}
          call setbufvar(a:bufnr, 'coc_helper_winid', winid)

          if a:border_bufnr
            let border_winid = ${openWin.inlineCall("border_bufnr, v:false, a:border_win_config, a:win_hl, ''")}
            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)
          endif
        endfunction
      `),
    update: m3.fn("update", ({ name }) => isNvim ? `
          function! ${name}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort
            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
            if !winid
              return
            endif
            call nvim_win_set_config(winid, a:win_config)
            if !empty(a:win_hl)
              call nvim_win_set_option(winid, 'winhl', a:win_hl)
            endif
            if has('nvim')
              redraw!
            endif

            if a:border_bufnr
              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
              if border_winid
                call nvim_win_set_config(border_winid, a:border_win_config)
                if !empty(a:win_hl)
                  call nvim_win_set_option(border_winid, 'winhl', a:win_hl)
                endif
                if has('nvim')
                  redraw!
                endif
              endif
            endif
          endfunction
        ` : `
          function! ${name}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort
            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
            if !winid
              return
            endif
            call popup_setoptions(winid, a:win_config)
          endfunction
        `),
    winid: m3.fn("winid", ({ name }) => `
        function! ${name}(bufnr) abort
          let id = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
          let nr = win_id2win(id)
          return nr is 0 ? v:null : id
        endfunction
      `),
    borderWinid: m3.fn("border_winid", ({ name }) => `
        function! ${name}(bufnr) abort
          return getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
        endfunction
      `),
    close: m3.fn("close", ({ name }) => isNvim ? `
            function! ${name}(bufnr) abort
              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
              try
                if winid
                  call nvim_win_close(winid, v:true)
                endif
                if border_winid
                  call nvim_win_close(border_winid, v:true)
                endif
              catch
              endtry
            endfunction
          ` : `
            function! ${name}(bufnr) abort
              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
              try
                if winid
                  call popup_close(winid)
                endif
              catch
              endtry
            endfunction
          `)
  };
});

// ../coc-helper/lib/esm/modules/util.js
var import_coc9 = require("coc.nvim");
var utilModule = VimModule.create("util", (m3) => {
  const isNvim = import_coc9.workspace.isNvim;
  return {
    globalCursorPosition: m3.fn("global_cursor_position", ({ name }) => `
        function! ${name}()
          let nr = winnr()
          let [row, col] = win_screenpos(nr)
          return [row + winline() - 2, col + wincol() - 2]
        endfunction
      `),
    isFloat: m3.fn("is_float", ({ name }) => isNvim ? `
          function! ${name}(winnr) abort
            if !exists('*nvim_win_get_config')
              return v:false
            endif
            let winid = win_getid(a:winnr)
            return nvim_win_get_config(winid)['relative'] != ''
          endfunction
        ` : `
          function! ${name}(winnr) abort
            return v:false
          endfunction
        `),
    closeWinByBufnr: m3.fn("close_win_by_bufnr", ({ name }) => `
        if exists('*nvim_win_close')
          function! ${name}(bufnrs) abort
            for bufnr in a:bufnrs
              try
                let winid = bufwinid(bufnr)
                if winid >= 0
                  call nvim_win_close(winid, v:true)
                endif
              catch
              endtry
            endfor
          endfunction
        else
          function! ${name}(bufnrs) abort
            for bufnr in a:bufnrs
              try
                let winnr = bufwinnr(bufnr)
                if winnr >= 0
                  execute winnr . 'wincmd c'
                endif
              catch
              endtry
            endfor
          endfunction
        endif
      `),
    runCocCmd: m3.fn("run_coc_cmd", ({ name }) => `
        function! ${name}(name, ...) abort
          return call('CocAction', extend(['runCommand', a:name], a:000))
        endfunction
      `),
    runCocCmdAsync: m3.fn("run_coc_cmd_async", ({ name }) => `
        function! ${name}(name, ...) abort
          return call('CocActionAsync', extend(['runCommand', a:name], a:000))
        endfunction
      `)
  };
});

// ../coc-helper/lib/esm/FloatingUtil.js
var import_coc10 = require("coc.nvim");
var defaultBorderChars = ["\u2500", "\u2502", "\u2500", "\u2502", "\u250C", "\u2510", "\u2518", "\u2514"];
var defaultWinHl = "CocHelperNormalFloat";
var defaultWinHlNC = "CocHelperNormalFloatNC";
var defaultBorderWinHl = "CocHelperNormalFloatBorder";
var FloatingUtil = class {
  constructor(srcId) {
    this.srcId = srcId;
  }
  async createContext(options) {
    var _a, _b;
    return (_a = options.context) !== null && _a !== void 0 ? _a : {
      lines: import_coc10.workspace.env.lines,
      columns: import_coc10.workspace.env.columns - import_coc10.workspace.env.cmdheight - 1,
      globalCursorPosition: await utilModule.globalCursorPosition.call(),
      title: options.title ? {
        text: options.title,
        width: await displayWidth(options.title)
      } : { text: "", width: 0 },
      borderEnabled: !!options.border,
      border: this.extendEdges((_b = options.border) === null || _b === void 0 ? void 0 : _b.map((b2) => typeof b2 === "boolean" ? 1 : b2)),
      paddingEnabled: !!options.padding,
      padding: this.extendEdges(options.padding)
    };
  }
  getCenterPos(ctx, box) {
    const [, , width, height] = box;
    const top = Math.floor((ctx.lines - height) / 2);
    const left = Math.floor((ctx.columns - width) / 2);
    return [top, left];
  }
  getPosForAround(ctx, size, cursorPosition, preferAbove = false) {
    const columns = ctx.columns;
    const lines = ctx.lines - 1;
    const [width, height] = size;
    let [top, left] = cursorPosition;
    if (preferAbove) {
      if (top - height < 0) {
        top += 1;
      } else {
        top -= height;
      }
    } else {
      if (top + height >= lines) {
        top -= height;
      } else {
        top += 1;
      }
    }
    if (left + width >= columns) {
      left -= width - 1;
    }
    return [top, left];
  }
  extendEdges(edges) {
    var _a, _b, _c, _d;
    if (!edges) {
      return [0, 0, 0, 0];
    }
    const top = (_a = edges[0]) !== null && _a !== void 0 ? _a : 1;
    const right = (_b = edges[1]) !== null && _b !== void 0 ? _b : top;
    const bottom = (_c = edges[2]) !== null && _c !== void 0 ? _c : top;
    const left = (_d = edges[3]) !== null && _d !== void 0 ? _d : right;
    return [top, right, bottom, left];
  }
  changeBoxByEdgesList(box, edgesList) {
    let retBox = [...box];
    for (const edges of edgesList) {
      retBox = this.changeBoxByEdges(retBox, edges);
    }
    return retBox;
  }
  changeBoxByEdges(box, edges) {
    if (!edges) {
      return box;
    }
    const [wTop, wRight, wBottom, wLeft] = edges;
    let [top, left, width, height] = box;
    top -= wTop;
    left -= wLeft;
    width += wLeft + wRight;
    height += wTop + wBottom;
    return [top, left, width, height];
  }
  getBoxSizes(ctx, options, updateCursorPosition) {
    var _a, _b;
    const [top, left] = [(_a = options.top) !== null && _a !== void 0 ? _a : 0, (_b = options.left) !== null && _b !== void 0 ? _b : 0];
    const width = Math.max(options.width, ctx.title.width);
    const contentBox = [0, 0, width, options.height];
    const paddingBox = this.changeBoxByEdges(contentBox, ctx.padding);
    const borderBox = this.changeBoxByEdges(paddingBox, ctx.border);
    let fullPos;
    if (options.relative === "center") {
      fullPos = this.getCenterPos(ctx, borderBox);
    } else {
      const cursorPosition = !updateCursorPosition && this.storeCursorPosition ? this.storeCursorPosition : ctx.globalCursorPosition;
      if (options.relative === "cursor") {
        fullPos = cursorPosition;
      } else if (options.relative === "cursor-around") {
        fullPos = this.getPosForAround(ctx, [borderBox[2], borderBox[3]], cursorPosition);
      } else {
        fullPos = [top, left];
      }
      this.storeCursorPosition = cursorPosition;
    }
    [borderBox[0], borderBox[1]] = [fullPos[0], fullPos[1]];
    [paddingBox[0], paddingBox[1]] = [
      borderBox[0] + ctx.border[0],
      borderBox[1] + ctx.border[3]
    ];
    [contentBox[0], contentBox[1]] = [
      paddingBox[0] + ctx.padding[0],
      paddingBox[1] + ctx.padding[3]
    ];
    return {
      contentBox,
      paddingBox,
      borderBox
    };
  }
  vimWinConfig(ctx, options, updateCursorPosition) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const [top, left, width, height] = [
      (_a = options.top) !== null && _a !== void 0 ? _a : 0,
      (_b = options.left) !== null && _b !== void 0 ? _b : 0,
      options.width,
      options.height
    ];
    const config4 = {
      line: 0,
      col: 0,
      zindex: ((_c = options.borderOnly) !== null && _c !== void 0 ? _c : false) ? 1 : 100,
      minwidth: width,
      minheight: height,
      maxwidth: width,
      maxheight: height
    };
    if (options.relative === "center") {
      config4.pos = "center";
    } else {
      const cursorPosition = !updateCursorPosition && this.storeCursorPosition ? this.storeCursorPosition : ctx.globalCursorPosition;
      if (options.relative === "cursor") {
        [config4.line, config4.col] = cursorPosition;
      } else if (options.relative === "cursor-around") {
        const box = this.changeBoxByEdgesList([top, left, width, height], [ctx.padding, ctx.border]);
        [config4.line, config4.col] = this.getPosForAround(ctx, [box[2], box[3]], cursorPosition);
      } else {
        [config4.line, config4.col] = [top, left];
      }
      this.storeCursorPosition = cursorPosition;
      config4.line += 1;
      config4.col += 1;
    }
    const topOffset = (_d = options.topOffset) !== null && _d !== void 0 ? _d : 0;
    const leftOffset = (_e = options.leftOffset) !== null && _e !== void 0 ? _e : 0;
    config4.line += topOffset;
    config4.col += leftOffset;
    if (options.maxWidth) {
      config4.maxwidth = options.maxWidth;
    }
    if (options.maxHeight) {
      config4.maxheight = options.maxHeight;
    }
    config4.highlight = (_f = options.winHl) !== null && _f !== void 0 ? _f : defaultWinHl;
    if (options.padding) {
      config4.padding = options.padding;
    }
    if (ctx.borderEnabled) {
      config4.border = ctx.border;
      if (config4.border[0]) {
        if (ctx.title.width) {
          config4.title = ctx.title.text;
        }
        config4.close = "button";
      }
      config4.borderchars = (_g = options.borderChars) !== null && _g !== void 0 ? _g : defaultBorderChars;
      config4.borderhighlight = [(_h = options.borderWinHl) !== null && _h !== void 0 ? _h : defaultBorderWinHl];
    }
    return config4;
  }
  nvimWinConfig(ctx, options, updateCursorPosition) {
    var _a, _b, _c;
    const { contentBox, borderBox } = this.getBoxSizes(ctx, options, updateCursorPosition);
    const topOffset = (_a = options.topOffset) !== null && _a !== void 0 ? _a : 0;
    const leftOffset = (_b = options.leftOffset) !== null && _b !== void 0 ? _b : 0;
    const winConfig = {
      relative: "editor",
      row: contentBox[0] + topOffset,
      col: contentBox[1] + leftOffset,
      width: contentBox[2],
      height: contentBox[3],
      focusable: (_c = options.focusable) !== null && _c !== void 0 ? _c : true
    };
    let winConfigBorder;
    if (borderBox) {
      winConfigBorder = {
        relative: "editor",
        row: borderBox[0] + topOffset,
        col: borderBox[1] + leftOffset,
        width: borderBox[2],
        height: borderBox[3],
        focusable: false
      };
    }
    return [winConfig, winConfigBorder];
  }
  winConfig(ctx, options, updateCursorPosition = true) {
    return import_coc10.workspace.isVim ? [this.vimWinConfig(ctx, options, updateCursorPosition), void 0] : this.nvimWinConfig(ctx, options, updateCursorPosition);
  }
  getRenderBorderData(ctx, options, winOptions) {
    var _a, _b, _c, _d, _e, _f;
    const title = (_b = (_a = ctx.title) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    const titleWidth = (_d = (_c = ctx.title) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 0;
    if (!ctx.borderEnabled) {
      return;
    }
    const [bTop, bRight, bBottom, bLeft] = ctx.border;
    let [cTop, cRight, cBottom, cLeft, cTopleft, cTopright, cBotright, cBotleft] = (_e = options.borderChars) !== null && _e !== void 0 ? _e : defaultBorderChars;
    if (!bTop) {
      cTop = "";
    }
    if (!bRight) {
      cRight = "";
    }
    if (!bBottom) {
      cBottom = "";
    }
    if (!bLeft) {
      cLeft = "";
    }
    if (!bTop || !bLeft) {
      cTopleft = "";
    }
    if (!bTop || !bRight) {
      cTopright = "";
    }
    if (!bBottom || !bLeft) {
      cBotleft = "";
    }
    if (!bBottom || !bRight) {
      cBotright = "";
    }
    const width = winOptions[0];
    const height = winOptions[1];
    const spaceWidth = width - bLeft - bRight;
    const spaceHeight = height - bTop - bBottom;
    const lines = [];
    if (bTop) {
      lines.push(cTopleft + title + cTop.repeat(spaceWidth - titleWidth) + cTopright);
    }
    lines.push(...Array.from({ length: spaceHeight }, () => cLeft + " ".repeat(spaceWidth) + cRight));
    if (bBottom) {
      lines.push(cBotleft + cBottom.repeat(spaceWidth) + cBotright);
    }
    const highlights = [];
    const borderWinHl = (_f = options.borderWinHl) !== null && _f !== void 0 ? _f : defaultBorderWinHl;
    if (borderWinHl) {
      highlights.push({
        hlGroup: borderWinHl,
        line: 0,
        colStart: 0,
        colEnd: width
      });
      for (let l = 0, len = spaceHeight; l < len; l++) {
        if (bLeft) {
          highlights.push({
            hlGroup: borderWinHl,
            line: l + 1,
            colStart: 0,
            colEnd: bLeft
          });
        }
        if (bRight) {
          highlights.push({
            hlGroup: borderWinHl,
            line: l + 1,
            colStart: bLeft + spaceWidth,
            colEnd: width
          });
        }
      }
      if (bBottom) {
        highlights.push({
          hlGroup: borderWinHl,
          line: height - 1,
          colStart: 0,
          colEnd: width
        });
      }
    }
    return {
      lines,
      highlights
    };
  }
  renderBorderNotifier(buf, ctx, options, winOptions) {
    const renderData = this.getRenderBorderData(ctx, options, "width" in winOptions ? [winOptions.width, winOptions.height] : [winOptions.minwidth, winOptions.minheight]);
    if (!renderData) {
      return Notifier.noop();
    }
    const { lines, highlights } = renderData;
    return Notifier.create(() => {
      buf.setOption("modifiable", true, true);
      buf.setOption("readonly", false, true);
      void buf.setLines(lines, { start: 0, end: -1 }, true);
      buf.setOption("modifiable", false, true);
      buf.setOption("readonly", true, true);
      this.addHighlightsNotify(buf, highlights);
    });
  }
  nvimWinHl(options) {
    var _a, _b;
    if (import_coc10.workspace.isVim) {
      return "";
    }
    const arr = [];
    arr.push(`Normal:${(_a = options.winHl) !== null && _a !== void 0 ? _a : defaultWinHl}`);
    arr.push(`NormalNC:${(_b = options.winHlNC) !== null && _b !== void 0 ? _b : defaultWinHlNC}`);
    return arr.join(",");
  }
  addHighlightsNotify(buf, highlights) {
    for (const hl of highlights) {
      if (!hl.hlGroup || hl.line === void 0 || hl.colStart === void 0 || hl.colEnd === void 0) {
        continue;
      }
      buf.highlightRanges(this.srcId, hl.hlGroup, [
        import_coc10.Range.create(hl.line, hl.colStart, hl.line, hl.colEnd)
      ]);
    }
  }
};

// ../coc-helper/lib/esm/FloatingWindow.js
var FloatingWindow = class {
  static getInitedExecute(mode, options) {
    var _a, _b, _c, _d;
    let initedExecute = (_b = (_a = options.initedExecute) === null || _a === void 0 ? void 0 : _a.call(options, FloatingWindow.initedContextVars.create)) !== null && _b !== void 0 ? _b : "";
    initedExecute = `${FloatingWindow.modePresets[mode].createInitedExecute(FloatingWindow.initedContextVars.create)}
${initedExecute}`;
    const borderInitedExecute = (_d = (_c = options.borderInitedExecute) === null || _c === void 0 ? void 0 : _c.call(options, FloatingWindow.initedContextVars.create)) !== null && _d !== void 0 ? _d : FloatingWindow.modePresets.show.createInitedExecute(FloatingWindow.initedContextVars.create);
    return [initedExecute, borderInitedExecute];
  }
  static async create(options = {}) {
    var _a, _b, _c;
    const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : "default";
    const [initedExecute, borderInitedExecute] = this.getInitedExecute(mode, options);
    const [bufnr, borderBufnr] = await floatingModule.create.call((_b = options.name) !== null && _b !== void 0 ? _b : "", initedExecute, (_c = options.hasBorderBuf) !== null && _c !== void 0 ? _c : true, borderInitedExecute);
    const floatingUtil = new FloatingUtil(this.srcId);
    return new FloatingWindow(bufnr, borderBufnr !== null && borderBufnr !== void 0 ? borderBufnr : void 0, options, mode, floatingUtil);
  }
  constructor(bufnr, borderBufnr, createOptions, mode, util2) {
    this.bufnr = bufnr;
    this.borderBufnr = borderBufnr;
    this.createOptions = createOptions;
    this.mode = mode;
    this.util = util2;
    this.nvim = import_coc11.workspace.nvim;
    this.disposables = [];
    this.nvim = import_coc11.workspace.nvim;
    this.buffer = this.nvim.createBuffer(bufnr);
    if (borderBufnr) {
      this.borderBuffer = import_coc11.workspace.nvim.createBuffer(borderBufnr);
      this.disposables.push(import_coc11.events.on("BufWinLeave", helperLogger.asyncCatch(async (curBufnr) => {
        if (this.borderBufnr && curBufnr === this.bufnr) {
          await utilModule.closeWinByBufnr.call([this.borderBufnr]);
        }
      })));
    }
  }
  getInitedExecute(options) {
    var _a, _b, _c, _d;
    let initedExecute = (_b = (_a = options.initedExecute) === null || _a === void 0 ? void 0 : _a.call(options, FloatingWindow.initedContextVars.open)) !== null && _b !== void 0 ? _b : "";
    initedExecute = `${FloatingWindow.modePresets[this.mode].openInitedExecute(FloatingWindow.initedContextVars.open)}
${initedExecute}`;
    const borderInitedExecute = (_d = (_c = options.borderInitedExecute) === null || _c === void 0 ? void 0 : _c.call(options, FloatingWindow.initedContextVars.open)) !== null && _d !== void 0 ? _d : FloatingWindow.modePresets.show.openInitedExecute(FloatingWindow.initedContextVars.open);
    return [initedExecute, borderInitedExecute];
  }
  getFocus(options) {
    var _a, _b;
    return (_b = (_a = options.focus) !== null && _a !== void 0 ? _a : this.mode ? FloatingWindow.modePresets[this.mode].focus : void 0) !== null && _b !== void 0 ? _b : false;
  }
  getModifiable(options) {
    var _a, _b;
    return (_b = (_a = options.modifiable) !== null && _a !== void 0 ? _a : this.mode ? FloatingWindow.modePresets[this.mode].modifiable : void 0) !== null && _b !== void 0 ? _b : false;
  }
  setLinesNotifier(options) {
    return Notifier.create(() => {
      if (!options.lines && !options.modifiable) {
        return;
      }
      const modifiable = this.getModifiable(options);
      this.buffer.setOption("modifiable", true, true);
      this.buffer.setOption("readonly", false, true);
      if (options.lines) {
        void this.buffer.setLines(options.lines, { start: 0, end: -1 }, true);
      }
      if (!modifiable) {
        this.buffer.setOption("modifiable", false, true);
        this.buffer.setOption("readonly", true, true);
      }
      if (options.highlights) {
        for (const hl of options.highlights) {
          this.util.addHighlightsNotify(this.buffer, [hl]);
        }
      }
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    });
  }
  async setLines(options) {
    await this.setLinesNotifier(options).run();
  }
  async opened() {
    const win = await this.win();
    return !!win;
  }
  async openNotifier(options) {
    var _a;
    if (options.width <= 0 || options.height <= 0) {
      return Notifier.noop();
    }
    const notifiers = [];
    notifiers.push(this.closeNotifier());
    const ctx = await this.util.createContext(options);
    const [initedExecute, borderInitedExecute] = this.getInitedExecute(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options);
    if (options.borderOnly && borderWinConfig) {
      notifiers.push(floatingModule.open.callNotifier(this.bufnr, borderWinConfig, borderInitedExecute, null, null, "", false, this.util.nvimWinHl(options)));
      notifiers.push(this.util.renderBorderNotifier(this.buffer, ctx, options, borderWinConfig));
    } else {
      notifiers.push(floatingModule.open.callNotifier(this.bufnr, winConfig, initedExecute, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, borderInitedExecute, this.getFocus(options), this.util.nvimWinHl(options)));
    }
    if (import_coc11.workspace.isNvim && this.borderBuffer && borderWinConfig) {
      notifiers.push(this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig));
    }
    notifiers.push(this.setLinesNotifier(options), Notifier.create(() => {
      if (options.filetype) {
        this.buffer.setOption("filetype", options.filetype, true);
      }
    }));
    return Notifier.combine(notifiers);
  }
  async open(options) {
    await (await this.openNotifier(options)).run();
  }
  async resumeNotifier(options) {
    const ctx = await this.util.createContext(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options);
    return Notifier.create(() => {
      var _a;
      floatingModule.resume.callNotify(this.bufnr, winConfig, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, this.getFocus(options), this.util.nvimWinHl(options));
      if (this.borderBuffer && borderWinConfig) {
        this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig).notify();
      }
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    });
  }
  async resume(options) {
    await (await this.resumeNotifier(options)).run();
  }
  async resizeNotifier(options) {
    var _a;
    const ctx = await this.util.createContext(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options, false);
    const notifiers = [];
    if (options.borderOnly && borderWinConfig) {
      notifiers.push(floatingModule.update.callNotifier(this.bufnr, borderWinConfig, null, null, this.util.nvimWinHl(options)));
      notifiers.push(this.util.renderBorderNotifier(this.buffer, ctx, options, borderWinConfig));
    } else {
      notifiers.push(floatingModule.update.callNotifier(this.bufnr, winConfig, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, this.util.nvimWinHl(options)));
    }
    if (import_coc11.workspace.isNvim && this.borderBuffer && borderWinConfig) {
      notifiers.push(this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig));
    }
    notifiers.push(Notifier.create(() => {
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    }));
    return Notifier.combine(notifiers);
  }
  async resize(options) {
    await (await this.resizeNotifier(options)).run();
  }
  async win() {
    const winid = await floatingModule.winid.call(this.bufnr);
    return winid ? this.nvim.createWindow(winid) : void 0;
  }
  async borderWin() {
    const borderWinid = await floatingModule.winid.call(this.bufnr);
    return borderWinid ? this.nvim.createWindow(borderWinid) : void 0;
  }
  closeNotifier() {
    return floatingModule.close.callNotifier(this.bufnr);
  }
  async close() {
    await this.closeNotifier().run();
  }
  dispose() {
    (0, import_coc11.disposeAll)(this.disposables);
    this.disposables.forEach((s3) => s3.dispose());
  }
};
FloatingWindow.modePresets = {
  default: {
    modifiable: false,
    focus: false,
    createInitedExecute: () => "",
    openInitedExecute: () => ""
  },
  base: {
    createInitedExecute: (ctx) => `
        call setbufvar(${ctx.bufnr}, '&buftype', 'nofile')
        call setbufvar(${ctx.bufnr}, '&bufhidden', 'hide')
        call setbufvar(${ctx.bufnr}, '&buflisted', 0)

        call setbufvar(${ctx.bufnr}, '&wrap', 1)

        call setbufvar(${ctx.bufnr}, '&swapfile', 0)

        call setbufvar(${ctx.bufnr}, '&modeline', 0)
      `,
    openInitedExecute: (ctx) => `
        call setbufvar(${ctx.bufnr}, '&list', 0)

        call setbufvar(${ctx.bufnr}, '&listchars', '')
        if has('nvim')
          call setbufvar(${ctx.bufnr}, '&fillchars', 'eob: ')
        endif

        call setbufvar(${ctx.bufnr}, '&signcolumn', 'no')
        call setbufvar(${ctx.bufnr}, '&number', 0)
        call setbufvar(${ctx.bufnr}, '&relativenumber', 0)
        call setbufvar(${ctx.bufnr}, '&foldenable', 0)
        call setbufvar(${ctx.bufnr}, '&foldcolumn', 0)

        call setbufvar(${ctx.bufnr}, '&spell', 0)

        call setbufvar(${ctx.bufnr}, '&cursorcolumn', 0)
        call setbufvar(${ctx.bufnr}, '&cursorline', 0)
        call setbufvar(${ctx.bufnr}, '&colorcolumn', '')
      `
  },
  show: {
    modifiable: false,
    createInitedExecute: (ctx) => `
        ${FloatingWindow.modePresets.base.createInitedExecute(ctx)}
        " call setbufvar(${ctx.bufnr}, '&undofile', 0)
        " call setbufvar(${ctx.bufnr}, '&undolevels', -1)

        call setbufvar(${ctx.bufnr}, '&modifiable', 0)
        call setbufvar(${ctx.bufnr}, '&modified', 0)
        call setbufvar(${ctx.bufnr}, '&readonly', 1)
      `,
    openInitedExecute: (ctx) => `
        ${FloatingWindow.modePresets.base.openInitedExecute(ctx)}
      `
  }
};
FloatingWindow.initedContextVars = {
  create: { bufnr: "a:ctx.bufnr" },
  open: { bufnr: "a:ctx.bufnr", winid: "a:ctx.winid" }
};
FloatingWindow.srcId = "coc-helper-floatwin";

// ../coc-helper/lib/esm/MultiFloatingWindow.js
var import_coc12 = require("coc.nvim");

// ../coc-helper/lib/esm/events.js
var import_coc13 = require("coc.nvim");
var HelperEventEmitter = class {
  constructor(helperLogger2, concurrent = false) {
    this.helperLogger = helperLogger2;
    this.concurrent = concurrent;
    this.listenersMap = /* @__PURE__ */ new Map();
  }
  listeners(event) {
    if (!this.listenersMap.has(event)) {
      const listeners = [];
      this.listenersMap.set(event, listeners);
      return listeners;
    }
    return this.listenersMap.get(event);
  }
  once(event, listener, disposables) {
    this.listeners(event).push(async (...args) => {
      const result = await listener(...args);
      disposable.dispose();
      return result;
    });
    const disposable = import_coc13.Disposable.create(() => this.off(event, listener));
    if (disposables) {
      disposables.push(disposable);
    }
    return disposable;
  }
  on(event, listener, disposables) {
    this.listeners(event).push(listener);
    const disposable = import_coc13.Disposable.create(() => this.off(event, listener));
    if (disposables) {
      disposables.push(disposable);
    }
    return disposable;
  }
  off(event, listener) {
    if (typeof listener.cancel === "function") {
      listener.cancel();
    }
    const listeners = this.listeners(event);
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
  }
  async fire(event, ...args) {
    if (this.concurrent) {
      await Promise.all(this.listeners(event).map(async (listener) => {
        try {
          await listener(...args);
        } catch (e2) {
          this.helperLogger.error(e2);
        }
      }));
    } else {
      for (const listener of this.listeners(event)) {
        try {
          await listener(...args);
        } catch (e2) {
          this.helperLogger.error(e2);
        }
      }
    }
  }
};

// ../coc-helper/lib/esm/WinLayoutFinder.js
var import_coc14 = require("coc.nvim");
var WinLayoutFinder = class {
  static convertVimLayoutNode(vimLayout, parent) {
    if (vimLayout[0] === "leaf") {
      return {
        type: vimLayout[0],
        winid: vimLayout[1],
        parent
      };
    } else {
      const group = {
        type: vimLayout[0],
        children: []
      };
      group.children = vimLayout[1].map((child, idx) => this.convertVimLayoutNode(child, {
        group,
        indexInParent: idx
      }));
      return group;
    }
  }
  static async create(tabnr) {
    const args = tabnr ? [tabnr] : [];
    const root2 = await import_coc14.workspace.nvim.call("winlayout", args);
    return new this(this.convertVimLayoutNode(root2));
  }
  static getFirstLeafWinid(node) {
    if (node.type === "leaf") {
      return node.winid;
    } else {
      return this.getFirstLeafWinid(node.children[0]);
    }
  }
  constructor(root2) {
    this.root = root2;
  }
  findWinid(winid, beginNode = this.root) {
    if (beginNode.type === "leaf") {
      if (beginNode.winid === winid) {
        return beginNode;
      }
    } else {
      for (const child of beginNode.children) {
        const target = this.findWinid(winid, child);
        if (target) {
          return target;
        }
      }
    }
  }
  findClosest(beginNode, matchWinids) {
    const checked = /* @__PURE__ */ new Set([beginNode]);
    const queue = [beginNode];
    while (queue.length) {
      const node = queue.shift();
      if (node.type === "leaf") {
        if (matchWinids.includes(node.winid)) {
          return node;
        }
      } else {
        for (const child of node.children) {
          if (!checked.has(child)) {
            queue.push(child);
            checked.add(child);
            continue;
          }
        }
      }
      if (node.parent && !checked.has(node.parent.group)) {
        queue.push(node.parent.group);
        checked.add(node.parent.group);
      }
    }
  }
};

// ../coc-helper/lib/esm/index.js
async function activateHelper(context2, options = {}) {
  var _a;
  if ((_a = options.vimModule) !== null && _a !== void 0 ? _a : true) {
    await VimModule.init(context2);
  }
  try {
    await import_coc15.workspace.nvim.command("hi default link CocHelperNormalFloatNC CocHelperNormalFloat");
  } catch (error) {
    void import_coc15.window.showErrorMessage(error.toString());
  }
}

// src/index.ts
var import_coc68 = require("coc.nvim");

// src/actions/menu.ts
var ActionMenu;
((ActionMenu2) => {
  function getNormalizeMenus(menus) {
    return Object.entries(menus).map(([key, value]) => {
      const actionArgs = async () => {
        return key.split(/:/);
      };
      return typeof value === "string" ? {
        description: value,
        args: key,
        actionArgs
      } : Object.assign(
        {
          args: key,
          actionArgs
        },
        value
      );
    });
  }
  ActionMenu2.getNormalizeMenus = getNormalizeMenus;
})(ActionMenu || (ActionMenu = {}));

// src/lists/actions.ts
var import_coc21 = require("coc.nvim");

// src/util/string.ts
function byteLength(str) {
  return Buffer.byteLength(str);
}
function splitCount(str, sep, count = 2) {
  const ret = [];
  let remain = str;
  let idx = str.indexOf(sep);
  while (idx !== -1 && count > 1) {
    ret.push(remain.slice(0, idx));
    remain = remain.slice(idx + 1);
    idx = remain.indexOf(sep);
    count -= 1;
  }
  ret.push(remain);
  return ret;
}
function isASCII(str) {
  return /^[\x00-\xFF]*$/.test(str);
}

// src/util/number.ts
var subscriptTable = {
  0: "\u2080",
  1: "\u2081",
  2: "\u2082",
  3: "\u2083",
  4: "\u2084",
  5: "\u2085",
  6: "\u2086",
  7: "\u2087",
  8: "\u2088",
  9: "\u2089"
};
function toSubscriptNumbers(s3) {
  return s3.toString().split("").map((c2) => subscriptTable[c2] ?? c2).join("");
}

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result = toFinite_default(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf_default(array, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path2) {
  path2 = castPath_default(path2, object);
  var index = 0, length = path2.length;
  while (object != null && index < length) {
    object = object[toKey_default(path2[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path2, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path2);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/flatten.js
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, 1) : [];
}
var flatten_default = flatten;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
function cloneBuffer(buffer2, isDeep) {
  if (isDeep) {
    return buffer2.slice();
  }
  var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
  buffer2.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto12 = Object.prototype;
var propertyIsEnumerable2 = objectProto12.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result = [];
  while (object) {
    arrayPush_default(result, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto13 = Object.prototype;
var hasOwnProperty10 = objectProto13.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty10.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag3 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag3] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag3 || tag == argsTag3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag3 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag3:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert2 = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert2 || (convert2 = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty11.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag4 = "[object Object]";
var objectProto15 = Object.prototype;
var hasOwnProperty12 = objectProto15.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag4 : objTag;
  othTag = othTag == argsTag4 ? objectTag4 : othTag;
  var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty12.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty12.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path2, hasFunc) {
  path2 = castPath_default(path2, object);
  var index = -1, length = path2.length, result = false;
  while (++index < length) {
    var key = toKey_default(path2[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path2) {
  return object != null && hasPath_default(object, path2, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey_default(path2) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path2), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path2) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path2) {
  return function(object) {
    return baseGet_default(object, path2);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path2) {
  return isKey_default(path2) ? baseProperty_default(toKey_default(path2)) : basePropertyDeep_default(path2);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value, comparator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/findIndex.js
var nativeMax = Math.max;
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index);
}
var findIndex_default = findIndex;

// node_modules/lodash-es/findLastIndex.js
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = fromIndex < 0 ? nativeMax2(length + index, 0) : nativeMin(index, length - 1);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/groupBy.js
var objectProto16 = Object.prototype;
var hasOwnProperty13 = objectProto16.hasOwnProperty;
var groupBy = createAggregator_default(function(result, value, key) {
  if (hasOwnProperty13.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue_default(result, key, [value]);
  }
});
var groupBy_default = groupBy;

// node_modules/lodash-es/_baseGt.js
function baseGt(value, other) {
  return value > other;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result, value, key) {
  baseAssignValue_default(result, key, value);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array, iteratee, comparator) {
  var index = -1, length = array.length;
  while (++index < length) {
    var value = array[index], current = iteratee(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result = value;
    }
  }
  return result;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseGt_default) : void 0;
}
var max_default = max;

// node_modules/lodash-es/_baseSum.js
function baseSum(array, iteratee) {
  var result, index = -1, length = array.length;
  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== void 0) {
      result = result === void 0 ? current : result + current;
    }
  }
  return result;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/min.js
function min(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseLt_default) : void 0;
}
var min_default = min;

// node_modules/lodash-es/minBy.js
function minBy(array, iteratee) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/partition.js
var partition = createAggregator_default(function(result, value, key) {
  result[key ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
var partition_default = partition;

// node_modules/lodash-es/sum.js
function sum2(array) {
  return array && array.length ? baseSum_default(array, identity_default) : 0;
}
var sum_default = sum2;

// node_modules/lodash-es/_createSet.js
var INFINITY4 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values) {
  return new Set_default(values);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq(array, iteratee, comparator) {
  var index = -1, includes = arrayIncludes_default, length = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE2) {
    var set = iteratee ? null : createSet_default(array);
    if (set) {
      return setToArray_default(set);
    }
    isCommon = false;
    includes = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/uniq.js
function uniq(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default = uniq;

// src/util/collection.ts
var compactI2 = (arr) => arr.filter((it) => it !== void 0 && it !== null);
function mapGetWithDefault(map, key, fetchDefault) {
  let v = map.get(key);
  if (v === void 0) {
    v = fetchDefault();
    map.set(key, v);
  }
  return v;
}
function scanIndexPrev(list, startIndex, wrapscan, condition) {
  if (startIndex > 0) {
    const index = findLastIndex_default(list, condition, startIndex - 1);
    if (index !== -1) {
      return index;
    }
  }
  if (wrapscan && startIndex < list.length - 1) {
    const index = findLastIndex_default(list.slice(startIndex + 1), condition);
    return index === -1 ? void 0 : index + startIndex + 1;
  }
}
function scanIndexNext(list, startIndex, wrapscan, condition) {
  if (startIndex < list.length - 1) {
    const index = findIndex_default(list, condition, startIndex + 1);
    if (index !== -1) {
      return index;
    }
  }
  if (wrapscan && startIndex > 0) {
    const index = findIndex_default(list.slice(0, startIndex), condition);
    return index === -1 ? void 0 : index;
  }
}

// src/util/async.ts
var sleep2 = (ms) => {
  return new Promise((resolve6) => {
    setTimeout(resolve6, ms);
  });
};

// src/util/fs.ts
var import_fs10 = __toESM(require("fs"));
var import_os2 = __toESM(require("os"));
var import_make_dir = __toESM(require_make_dir());
var import_path7 = __toESM(require("path"));
var import_readline = __toESM(require("readline"));

// node_modules/rimraf/dist/mjs/src/opt-arg.js
var opt_arg_default = (opt = {}) => {
  assertRimrafOptions(opt);
  return opt;
};

// node_modules/rimraf/dist/mjs/src/platform.js
var platform_default = process.env.__TESTING_RIMRAF_PLATFORM__ || process.platform;

// node_modules/rimraf/dist/mjs/src/path-arg.js
var import_path = require("path");
var import_util9 = require("util");
var pathArg = (path2, opt = {}) => {
  const type = typeof path2;
  if (type !== "string") {
    const ctor = path2 && type === "object" && path2.constructor;
    const received = ctor && ctor.name ? `an instance of ${ctor.name}` : type === "object" ? (0, import_util9.inspect)(path2) : `type ${type} ${path2}`;
    const msg = `The "path" argument must be of type string. Received ${received}`;
    throw Object.assign(new TypeError(msg), {
      path: path2,
      code: "ERR_INVALID_ARG_TYPE"
    });
  }
  if (/\0/.test(path2)) {
    const msg = "path must be a string without null bytes";
    throw Object.assign(new TypeError(msg), {
      path: path2,
      code: "ERR_INVALID_ARG_VALUE"
    });
  }
  path2 = (0, import_path.resolve)(path2);
  const { root: root2 } = (0, import_path.parse)(path2);
  if (path2 === root2 && opt.preserveRoot !== false) {
    const msg = "refusing to remove root directory without preserveRoot:false";
    throw Object.assign(new Error(msg), {
      path: path2,
      code: "ERR_PRESERVE_ROOT"
    });
  }
  if (platform_default === "win32") {
    const badWinChars = /[*|"<>?:]/;
    const { root: root3 } = (0, import_path.parse)(path2);
    if (badWinChars.test(path2.substring(root3.length))) {
      throw Object.assign(new Error("Illegal characters in path."), {
        path: path2,
        code: "EINVAL"
      });
    }
  }
  return path2;
};
var path_arg_default = pathArg;

// node_modules/rimraf/dist/mjs/src/fs.js
var import_fs = __toESM(require("fs"), 1);
var import_fs2 = require("fs");
var chmod = (path2, mode) => new Promise((res, rej) => import_fs.default.chmod(path2, mode, (er, ...d3) => er ? rej(er) : res(...d3)));
var mkdir = (path2, options) => new Promise((res, rej) => import_fs.default.mkdir(path2, options, (er, made) => er ? rej(er) : res(made)));
var readdir = (path2) => new Promise((res, rej) => import_fs.default.readdir(path2, (er, data) => er ? rej(er) : res(data)));
var rename = (oldPath, newPath) => new Promise((res, rej) => import_fs.default.rename(oldPath, newPath, (er, ...d3) => er ? rej(er) : res(...d3)));
var rm = (path2, options) => new Promise((res, rej) => import_fs.default.rm(path2, options, (er, ...d3) => er ? rej(er) : res(...d3)));
var rmdir = (path2) => new Promise((res, rej) => import_fs.default.rmdir(path2, (er, ...d3) => er ? rej(er) : res(...d3)));
var stat = (path2) => new Promise((res, rej) => import_fs.default.stat(path2, (er, data) => er ? rej(er) : res(data)));
var unlink = (path2) => new Promise((res, rej) => import_fs.default.unlink(path2, (er, ...d3) => er ? rej(er) : res(...d3)));
var promises = {
  chmod,
  mkdir,
  readdir,
  rename,
  rm,
  rmdir,
  stat,
  unlink
};

// node_modules/rimraf/dist/mjs/src/rimraf-posix.js
var import_path2 = require("path");

// node_modules/rimraf/dist/mjs/src/readdir-or-error.js
var { readdir: readdir2 } = promises;
var readdirOrError = (path2) => readdir2(path2).catch((er) => er);
var readdirOrErrorSync = (path2) => {
  try {
    return (0, import_fs2.readdirSync)(path2);
  } catch (er) {
    return er;
  }
};

// node_modules/rimraf/dist/mjs/src/ignore-enoent.js
var ignoreENOENT = async (p) => p.catch((er) => {
  if (er.code !== "ENOENT") {
    throw er;
  }
});
var ignoreENOENTSync = (fn) => {
  try {
    return fn();
  } catch (er) {
    if ((er == null ? void 0 : er.code) !== "ENOENT") {
      throw er;
    }
  }
};

// node_modules/rimraf/dist/mjs/src/rimraf-posix.js
var { rmdir: rmdir2, unlink: unlink2 } = promises;
var rimrafPosix = async (path2, opt) => {
  const entries = await readdirOrError(path2);
  if (!Array.isArray(entries)) {
    if (entries.code === "ENOENT") {
      return;
    }
    if (entries.code !== "ENOTDIR") {
      throw entries;
    }
    return ignoreENOENT(unlink2(path2));
  }
  await Promise.all(entries.map((entry) => rimrafPosix((0, import_path2.resolve)(path2, entry), opt)));
  if (opt.preserveRoot === false && path2 === (0, import_path2.parse)(path2).root) {
    return;
  }
  return ignoreENOENT(rmdir2(path2));
};
var rimrafPosixSync = (path2, opt) => {
  const entries = readdirOrErrorSync(path2);
  if (!Array.isArray(entries)) {
    if (entries.code === "ENOENT") {
      return;
    }
    if (entries.code !== "ENOTDIR") {
      throw entries;
    }
    return ignoreENOENTSync(() => (0, import_fs2.unlinkSync)(path2));
  }
  for (const entry of entries) {
    rimrafPosixSync((0, import_path2.resolve)(path2, entry), opt);
  }
  if (opt.preserveRoot === false && path2 === (0, import_path2.parse)(path2).root) {
    return;
  }
  return ignoreENOENTSync(() => (0, import_fs2.rmdirSync)(path2));
};

// node_modules/rimraf/dist/mjs/src/rimraf-windows.js
var import_path5 = require("path");

// node_modules/rimraf/dist/mjs/src/fix-eperm.js
var { chmod: chmod2 } = promises;
var fixEPERM = (fn) => async (path2) => {
  try {
    return await fn(path2);
  } catch (er) {
    const fer = er;
    if ((fer == null ? void 0 : fer.code) === "ENOENT") {
      return;
    }
    if ((fer == null ? void 0 : fer.code) === "EPERM") {
      try {
        await chmod2(path2, 438);
      } catch (er2) {
        const fer2 = er2;
        if ((fer2 == null ? void 0 : fer2.code) === "ENOENT") {
          return;
        }
        throw er;
      }
      return await fn(path2);
    }
    throw er;
  }
};
var fixEPERMSync = (fn) => (path2) => {
  try {
    return fn(path2);
  } catch (er) {
    const fer = er;
    if ((fer == null ? void 0 : fer.code) === "ENOENT") {
      return;
    }
    if ((fer == null ? void 0 : fer.code) === "EPERM") {
      try {
        (0, import_fs2.chmodSync)(path2, 438);
      } catch (er2) {
        const fer2 = er2;
        if ((fer2 == null ? void 0 : fer2.code) === "ENOENT") {
          return;
        }
        throw er;
      }
      return fn(path2);
    }
    throw er;
  }
};

// node_modules/rimraf/dist/mjs/src/retry-busy.js
var MAXBACKOFF = 200;
var RATE = 1.2;
var MAXRETRIES = 10;
var codes = /* @__PURE__ */ new Set(["EMFILE", "ENFILE", "EBUSY"]);
var retryBusy = (fn) => {
  const method = async (path2, opt, backoff = 1, total = 0) => {
    const mbo = opt.maxBackoff || MAXBACKOFF;
    const rate = opt.backoff || RATE;
    const max2 = opt.maxRetries || MAXRETRIES;
    let retries = 0;
    while (true) {
      try {
        return await fn(path2);
      } catch (er) {
        const fer = er;
        if ((fer == null ? void 0 : fer.path) === path2 && (fer == null ? void 0 : fer.code) && codes.has(fer.code)) {
          backoff = Math.ceil(backoff * rate);
          total = backoff + total;
          if (total < mbo) {
            return new Promise((res, rej) => {
              setTimeout(() => {
                method(path2, opt, backoff, total).then(res, rej);
              }, backoff);
            });
          }
          if (retries < max2) {
            retries++;
            continue;
          }
        }
        throw er;
      }
    }
  };
  return method;
};
var retryBusySync = (fn) => {
  const method = (path2, opt) => {
    const max2 = opt.maxRetries || MAXRETRIES;
    let retries = 0;
    while (true) {
      try {
        return fn(path2);
      } catch (er) {
        const fer = er;
        if ((fer == null ? void 0 : fer.path) === path2 && (fer == null ? void 0 : fer.code) && codes.has(fer.code) && retries < max2) {
          retries++;
          continue;
        }
        throw er;
      }
    }
  };
  return method;
};

// node_modules/rimraf/dist/mjs/src/rimraf-move-remove.js
var import_path4 = require("path");

// node_modules/rimraf/dist/mjs/src/default-tmp.js
var import_os = require("os");
var import_path3 = require("path");
var { stat: stat2 } = promises;
var isDirSync = (path2) => {
  try {
    return (0, import_fs2.statSync)(path2).isDirectory();
  } catch (er) {
    return false;
  }
};
var isDir = (path2) => stat2(path2).then((st) => st.isDirectory(), () => false);
var win32DefaultTmp = async (path2) => {
  const { root: root2 } = (0, import_path3.parse)(path2);
  const tmp = (0, import_os.tmpdir)();
  const { root: tmpRoot } = (0, import_path3.parse)(tmp);
  if (root2.toLowerCase() === tmpRoot.toLowerCase()) {
    return tmp;
  }
  const driveTmp = (0, import_path3.resolve)(root2, "/temp");
  if (await isDir(driveTmp)) {
    return driveTmp;
  }
  return root2;
};
var win32DefaultTmpSync = (path2) => {
  const { root: root2 } = (0, import_path3.parse)(path2);
  const tmp = (0, import_os.tmpdir)();
  const { root: tmpRoot } = (0, import_path3.parse)(tmp);
  if (root2.toLowerCase() === tmpRoot.toLowerCase()) {
    return tmp;
  }
  const driveTmp = (0, import_path3.resolve)(root2, "/temp");
  if (isDirSync(driveTmp)) {
    return driveTmp;
  }
  return root2;
};
var posixDefaultTmp = async () => (0, import_os.tmpdir)();
var posixDefaultTmpSync = () => (0, import_os.tmpdir)();
var defaultTmp = platform_default === "win32" ? win32DefaultTmp : posixDefaultTmp;
var defaultTmpSync = platform_default === "win32" ? win32DefaultTmpSync : posixDefaultTmpSync;

// node_modules/rimraf/dist/mjs/src/rimraf-move-remove.js
var { rename: rename2, unlink: unlink3, rmdir: rmdir3, chmod: chmod3 } = promises;
var uniqueFilename = (path2) => `.${(0, import_path4.basename)(path2)}.${Math.random()}`;
var unlinkFixEPERM = async (path2) => unlink3(path2).catch((er) => {
  if (er.code === "EPERM") {
    return chmod3(path2, 438).then(() => unlink3(path2), (er2) => {
      if (er2.code === "ENOENT") {
        return;
      }
      throw er;
    });
  } else if (er.code === "ENOENT") {
    return;
  }
  throw er;
});
var unlinkFixEPERMSync = (path2) => {
  try {
    (0, import_fs2.unlinkSync)(path2);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "EPERM") {
      try {
        return (0, import_fs2.chmodSync)(path2, 438);
      } catch (er2) {
        if ((er2 == null ? void 0 : er2.code) === "ENOENT") {
          return;
        }
        throw er;
      }
    } else if ((er == null ? void 0 : er.code) === "ENOENT") {
      return;
    }
    throw er;
  }
};
var rimrafMoveRemove = async (path2, opt) => {
  if (!opt.tmp) {
    return rimrafMoveRemove(path2, { ...opt, tmp: await defaultTmp(path2) });
  }
  if (path2 === opt.tmp && (0, import_path4.parse)(path2).root !== path2) {
    throw new Error("cannot delete temp directory used for deletion");
  }
  const entries = await readdirOrError(path2);
  if (!Array.isArray(entries)) {
    if (entries.code === "ENOENT") {
      return;
    }
    if (entries.code !== "ENOTDIR") {
      throw entries;
    }
    return await ignoreENOENT(tmpUnlink(path2, opt.tmp, unlinkFixEPERM));
  }
  await Promise.all(entries.map((entry) => rimrafMoveRemove((0, import_path4.resolve)(path2, entry), opt)));
  if (opt.preserveRoot === false && path2 === (0, import_path4.parse)(path2).root) {
    return;
  }
  return await ignoreENOENT(tmpUnlink(path2, opt.tmp, rmdir3));
};
var tmpUnlink = async (path2, tmp, rm3) => {
  const tmpFile = (0, import_path4.resolve)(tmp, uniqueFilename(path2));
  await rename2(path2, tmpFile);
  return await rm3(tmpFile);
};
var rimrafMoveRemoveSync = (path2, opt) => {
  if (!opt.tmp) {
    return rimrafMoveRemoveSync(path2, { ...opt, tmp: defaultTmpSync(path2) });
  }
  const tmp = opt.tmp;
  if (path2 === opt.tmp && (0, import_path4.parse)(path2).root !== path2) {
    throw new Error("cannot delete temp directory used for deletion");
  }
  const entries = readdirOrErrorSync(path2);
  if (!Array.isArray(entries)) {
    if (entries.code === "ENOENT") {
      return;
    }
    if (entries.code !== "ENOTDIR") {
      throw entries;
    }
    return ignoreENOENTSync(() => tmpUnlinkSync(path2, tmp, unlinkFixEPERMSync));
  }
  for (const entry of entries) {
    rimrafMoveRemoveSync((0, import_path4.resolve)(path2, entry), opt);
  }
  if (opt.preserveRoot === false && path2 === (0, import_path4.parse)(path2).root) {
    return;
  }
  return ignoreENOENTSync(() => tmpUnlinkSync(path2, tmp, import_fs2.rmdirSync));
};
var tmpUnlinkSync = (path2, tmp, rmSync2) => {
  const tmpFile = (0, import_path4.resolve)(tmp, uniqueFilename(path2));
  (0, import_fs2.renameSync)(path2, tmpFile);
  return rmSync2(tmpFile);
};

// node_modules/rimraf/dist/mjs/src/rimraf-windows.js
var { unlink: unlink4, rmdir: rmdir4 } = promises;
var rimrafWindowsFile = retryBusy(fixEPERM(unlink4));
var rimrafWindowsFileSync = retryBusySync(fixEPERMSync(import_fs2.unlinkSync));
var rimrafWindowsDir = retryBusy(fixEPERM(rmdir4));
var rimrafWindowsDirSync = retryBusySync(fixEPERMSync(import_fs2.rmdirSync));
var rimrafWindowsDirMoveRemoveFallback = async (path2, opt) => {
  try {
    await rimrafWindowsDir(path2, opt);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOTEMPTY") {
      return await rimrafMoveRemove(path2, opt);
    }
    throw er;
  }
};
var rimrafWindowsDirMoveRemoveFallbackSync = (path2, opt) => {
  try {
    rimrafWindowsDirSync(path2, opt);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOTEMPTY") {
      return rimrafMoveRemoveSync(path2, opt);
    }
    throw er;
  }
};
var START = Symbol("start");
var CHILD = Symbol("child");
var FINISH = Symbol("finish");
var states = /* @__PURE__ */ new Set([START, CHILD, FINISH]);
var rimrafWindows = async (path2, opt, state = START) => {
  if (!states.has(state)) {
    throw new TypeError("invalid third argument passed to rimraf");
  }
  const entries = await readdirOrError(path2);
  if (!Array.isArray(entries)) {
    if (entries.code === "ENOENT") {
      return;
    }
    if (entries.code !== "ENOTDIR") {
      throw entries;
    }
    return ignoreENOENT(rimrafWindowsFile(path2, opt));
  }
  await Promise.all(entries.map((entry) => rimrafWindows((0, import_path5.resolve)(path2, entry), opt, state === START ? CHILD : state)));
  if (state === START) {
    return rimrafWindows(path2, opt, FINISH);
  } else if (state === FINISH) {
    if (opt.preserveRoot === false && path2 === (0, import_path5.parse)(path2).root) {
      return;
    }
    return ignoreENOENT(rimrafWindowsDirMoveRemoveFallback(path2, opt));
  }
};
var rimrafWindowsSync = (path2, opt, state = START) => {
  if (!states.has(state)) {
    throw new TypeError("invalid third argument passed to rimraf");
  }
  const entries = readdirOrErrorSync(path2);
  if (!Array.isArray(entries)) {
    if (entries.code === "ENOENT") {
      return;
    }
    if (entries.code !== "ENOTDIR") {
      throw entries;
    }
    return ignoreENOENTSync(() => rimrafWindowsFileSync(path2, opt));
  }
  for (const entry of entries) {
    const s3 = state === START ? CHILD : state;
    rimrafWindowsSync((0, import_path5.resolve)(path2, entry), opt, s3);
  }
  if (state === START) {
    return rimrafWindowsSync(path2, opt, FINISH);
  } else if (state === FINISH) {
    if (opt.preserveRoot === false && path2 === (0, import_path5.parse)(path2).root) {
      return;
    }
    return ignoreENOENTSync(() => {
      rimrafWindowsDirMoveRemoveFallbackSync(path2, opt);
    });
  }
};

// node_modules/rimraf/dist/mjs/src/rimraf-manual.js
var rimrafManual = platform_default === "win32" ? rimrafWindows : rimrafPosix;
var rimrafManualSync = platform_default === "win32" ? rimrafWindowsSync : rimrafPosixSync;

// node_modules/rimraf/dist/mjs/src/rimraf-native.js
var { rm: rm2 } = promises;
var rimrafNative = (path2, opt) => rm2(path2, {
  ...opt,
  force: true,
  recursive: true
});
var rimrafNativeSync = (path2, opt) => (0, import_fs2.rmSync)(path2, {
  ...opt,
  force: true,
  recursive: true
});

// node_modules/rimraf/dist/mjs/src/use-native.js
var version2 = process.env.__TESTING_RIMRAF_NODE_VERSION__ || process.version;
var versArr = version2.replace(/^v/, "").split(".");
var hasNative = +versArr[0] > 14 || +versArr[0] === 14 && +versArr[1] >= 14;
var useNative = !hasNative || platform_default === "win32" ? () => false : () => true;
var useNativeSync = !hasNative || platform_default === "win32" ? () => false : () => true;

// node_modules/rimraf/dist/mjs/src/index.js
var typeOrUndef = (val, t2) => typeof val === "undefined" || typeof val === t2;
var isRimrafOptions = (o) => !!o && typeof o === "object" && typeOrUndef(o.preserveRoot, "boolean") && typeOrUndef(o.preserveRoot, "number") && typeOrUndef(o.maxRetries, "number") && typeOrUndef(o.retryDelay, "number") && typeOrUndef(o.backoff, "number") && typeOrUndef(o.maxBackoff, "number");
var assertRimrafOptions = (o) => {
  if (!isRimrafOptions(o)) {
    throw new Error("invalid rimraf options");
  }
};
var wrap = (fn) => async (path2, opt) => {
  const options = opt_arg_default(opt);
  await (Array.isArray(path2) ? Promise.all(path2.map((p) => fn(path_arg_default(p, options), options))) : fn(path_arg_default(path2, options), options));
};
var wrapSync = (fn) => (path2, opt) => {
  const options = opt_arg_default(opt);
  return Array.isArray(path2) ? path2.forEach((p) => fn(path_arg_default(p, options), options)) : fn(path_arg_default(path2, options), options);
};
var nativeSync = wrapSync(rimrafNativeSync);
var native = Object.assign(wrap(rimrafNative), { sync: nativeSync });
var manualSync = wrapSync(rimrafManualSync);
var manual = Object.assign(wrap(rimrafManual), { sync: manualSync });
var windowsSync = wrapSync(rimrafWindowsSync);
var windows = Object.assign(wrap(rimrafWindows), { sync: windowsSync });
var posixSync = wrapSync(rimrafPosixSync);
var posix = Object.assign(wrap(rimrafPosix), { sync: posixSync });
var moveRemoveSync = wrapSync(rimrafMoveRemoveSync);
var moveRemove = Object.assign(wrap(rimrafMoveRemove), {
  sync: moveRemoveSync
});
var rimrafSync = wrapSync((path2, opt) => useNativeSync() ? rimrafNativeSync(path2, opt) : rimrafManualSync(path2, opt));
var rimraf = Object.assign(wrap((path2, opt) => useNative() ? rimrafNative(path2, opt) : rimrafManual(path2, opt)), {
  rimraf: manual,
  sync: rimrafSync,
  rimrafSync,
  manual,
  manualSync,
  native,
  nativeSync,
  posix,
  posixSync,
  windows,
  windowsSync,
  moveRemove,
  moveRemoveSync
});
rimraf.rimraf = rimraf;

// src/util/fs.ts
var import_util11 = require("util");

// src/util/cli.ts
var import_child_process = require("child_process");
var import_which = __toESM(require_lib());
var execCmd = (name, args, options) => {
  const streams = (0, import_child_process.spawn)(name, args, options);
  let output = "";
  streams.stdout.on("data", (data) => {
    output += data.toString();
  });
  return new Promise((resolve6, reject) => {
    streams.stdout.on("error", (error) => {
      reject(error);
    });
    streams.stdout.on("end", () => {
      resolve6(output);
    });
  });
};
var execCmdLine = (command, options) => {
  return new Promise((resolve6, reject) => {
    (0, import_child_process.exec)(command, options, (error, stdout) => {
      if (error) {
        return reject(error);
      }
      resolve6(stdout.toString("utf8"));
    });
  });
};
function shellescape(s3) {
  if (process.platform === "win32") {
    return `"${s3.replace(/"/g, '\\"')}"`;
  }
  if (/[^A-Za-z0-9_/:=-]/.test(s3)) {
    s3 = `'${s3.replace(/'/g, "'\\''")}'`;
    s3 = s3.replace(/^(?:'')+/g, "").replace(/\\'''/g, "\\'");
    return s3;
  }
  return s3;
}
var executable = async (cmd) => {
  try {
    await (0, import_which.default)(cmd);
  } catch (e2) {
    return false;
  }
  return true;
};

// src/util/platform.ts
var isWindows2 = process.platform === "win32";
var isMacos = process.platform === "darwin";
var isLinux2 = process.platform === "linux";

// src/util/trash.ts
var import_path6 = __toESM(require("path"));

// src/config.ts
var import_coc16 = require("coc.nvim");
var config = import_coc16.workspace.getConfiguration("explorer");
var configLocal = (resource = generateUri2(import_coc16.workspace.cwd)) => import_coc16.workspace.getConfiguration("explorer", resource);
var bufferTabOnly = () => {
  return config.get("buffer.tabOnly");
};
var getRevealAuto = (config4) => {
  let revealAuto = config4.get("file.autoReveal");
  if (revealAuto !== void 0 && revealAuto !== null) {
    logger.error(
      "`explorer.file.autoReveal` has been deprecated, please use explorer.file.reveal.auto instead of it"
    );
  } else {
    revealAuto = config4.get("file.reveal.auto");
  }
  return revealAuto;
};
var getRevealWhenOpen = (config4, revealWhenOpenArg) => {
  if (revealWhenOpenArg !== void 0) {
    return revealWhenOpenArg;
  }
  let revealWhenOpen = config4.get("file.revealWhenOpen");
  if (revealWhenOpen !== void 0 && revealWhenOpen !== null) {
    logger.error(
      "`explorer.file.autoReveal` has been deprecated, please use explorer.file.reveal.whenOpen instead of it"
    );
  } else {
    revealWhenOpen = config4.get("file.reveal.whenOpen");
  }
  return revealWhenOpen;
};
function buildExplorerConfig(config4) {
  return {
    get config() {
      return config4;
    },
    get(section, defaultValue) {
      return this.config.get(section, defaultValue);
    }
  };
}

// src/util/trash.ts
var nodejsModuleTrash = async (paths) => {
  const nodePath = process.argv[0];
  const scriptPath = import_path6.default.join(__dirname, "../cli/trash.mjs");
  const pathArgs = paths.map((p) => shellescape(p)).join(" ");
  const cmd = `${shellescape(nodePath)} ${shellescape(scriptPath)} ${pathArgs}`;
  await execCmdLine(cmd);
};
var TrashTemplateCmd = class {
  constructor() {
    this.inited = false;
    this.placeholders = {
      list: "%l",
      sourceFile: "%s"
    };
    this.exec_ = async () => {
    };
  }
  async init() {
    if (this.inited) {
      return;
    }
    const configTrashCommand = config.get("trash.command");
    if (configTrashCommand === "nodejs:module") {
      this.exec_ = async (paths) => {
        await nodejsModuleTrash(paths);
      };
      return;
    }
    const m3 = configTrashCommand.match(/^([^\s]+)/);
    const cmd = m3 == null ? void 0 : m3[1];
    if (!cmd) {
      this.exec_ = async () => {
        throw new Error("'explorer.trash.command' must not be empty");
      };
      return;
    }
    const checkCmd = async (cmd2) => {
      if (!await executable(cmd2)) {
        throw new Error(`command(${cmd2}) does not exist`);
      }
    };
    if (configTrashCommand.includes(this.placeholders.list)) {
      this.exec_ = async (paths) => {
        await checkCmd(cmd);
        const pathArgs = paths.map((p) => shellescape(p)).join(" ");
        await execCmdLine(
          configTrashCommand.replace(
            new RegExp(this.placeholders.list, "g"),
            pathArgs
          )
        );
      };
    } else if (configTrashCommand.includes(this.placeholders.sourceFile)) {
      this.exec_ = async (paths) => {
        await checkCmd(cmd);
        for (const path2 of paths.map((p) => shellescape(p))) {
          await execCmdLine(
            configTrashCommand.replace(
              new RegExp(this.placeholders.sourceFile, "g"),
              path2
            )
          );
        }
      };
    }
    this.inited = true;
  }
  async exec(paths) {
    await this.init();
    await this.exec_(paths);
  }
};
var trashCmd = new TrashTemplateCmd();

// src/util/fs.ts
var import_minimatch = __toESM(require_minimatch());
var fsOpen = (0, import_util11.promisify)(import_fs10.default.open);
var fsClose = (0, import_util11.promisify)(import_fs10.default.close);
var fsTouch = async (path2) => await fsClose(await fsOpen(path2, "w"));
var fsMkdirp = import_make_dir.default;
var fsReaddir = (0, import_util11.promisify)(import_fs10.default.readdir);
var fsReadlink = (0, import_util11.promisify)(import_fs10.default.readlink);
var fsAccess = (path2, mode) => new Promise((resolve6) => {
  import_fs10.default.access(path2, mode, (err) => {
    err ? resolve6(false) : resolve6(true);
  });
});
var fsWriteFile = (0, import_util11.promisify)(import_fs10.default.writeFile);
var fsReadFile = (0, import_util11.promisify)(import_fs10.default.readFile);
var fsExists = fsAccess;
var fsStat = (0, import_util11.promisify)(import_fs10.default.stat);
var fsLstat = (0, import_util11.promisify)(import_fs10.default.lstat);
var fsCopyFile = (0, import_util11.promisify)(import_fs10.default.copyFile);
var fsRename = (0, import_util11.promisify)(import_fs10.default.rename);
var fsRemove = rimraf;
var fsTrash = async (paths) => {
  await trashCmd.exec(typeof paths === "string" ? [paths] : paths);
};
async function fsCopyFileRecursive(sourcePath, targetPath) {
  const lstat = await fsLstat(sourcePath);
  if (lstat.isDirectory()) {
    await fsMkdirp(targetPath);
    const filenames = await fsReaddir(sourcePath);
    for (const filename of filenames) {
      await fsCopyFileRecursive(
        import_path7.default.join(sourcePath, filename),
        import_path7.default.join(targetPath, filename)
      );
    }
  } else {
    await fsCopyFile(sourcePath, targetPath);
  }
}
async function fsMergeDirectory(sourceDir, targetDir, action) {
  const filenames = await fsReaddir(sourceDir);
  for (const filename of filenames) {
    const sourcePath = import_path7.default.join(sourceDir, filename);
    const targetPath = import_path7.default.join(targetDir, filename);
    if (await fsExists(targetPath)) {
      const sourceLstat = await fsLstat(sourcePath);
      const targetLstat = await fsLstat(targetPath);
      if (sourceLstat.isDirectory() && targetLstat.isDirectory()) {
        await fsMergeDirectory(sourcePath, targetPath, action);
      } else {
        await fsTrash(targetPath);
        await action(sourcePath, targetPath);
      }
    } else {
      await action(sourcePath, targetPath);
    }
  }
}
async function overwritePrompt(promptText, paths, action) {
  const endFullpaths = [];
  const finalAction = async (source, target) => {
    await fsMkdirp(import_path7.default.dirname(target));
    await action(source, target);
    endFullpaths.push(target);
  };
  for (let i2 = 0, len = paths.length; i2 < len; i2++) {
    const sourcePath = paths[i2].source;
    const targetPath = paths[i2].target;
    if (!await fsExists(targetPath)) {
      await finalAction(sourcePath, targetPath);
      continue;
    }
    const sourceLstat = typeof sourcePath === "string" ? await fsLstat(sourcePath) : void 0;
    const targetLstat = await fsLstat(targetPath);
    const rename3 = async function() {
      const newTargetPath = await input(
        `Rename: ${targetPath} ->`,
        targetPath,
        "file"
      );
      if (!newTargetPath) {
        i2 -= 1;
        return;
      }
      return finalAction(sourcePath, newTargetPath);
    };
    const replace = async function() {
      await fsTrash(targetPath);
      return finalAction(sourcePath, targetPath);
    };
    const quit = function() {
      i2 = len;
    };
    const prompt_ = async function(choices = {}) {
      var _a;
      choices = {
        skip: void 0,
        rename: rename3,
        "force replace": replace,
        ...choices,
        quit
      };
      const answer = await prompt(
        `${promptText[0].toUpperCase()}${promptText.slice(
          1
        )}: ${targetPath} already exists.`,
        Object.keys(choices)
      );
      if (answer && answer in choices) {
        return (_a = choices[answer]) == null ? void 0 : _a.call(choices);
      }
    };
    if (sourcePath && (sourceLstat == null ? void 0 : sourceLstat.isDirectory())) {
      if (targetLstat.isDirectory()) {
        await prompt_({
          merge: () => fsMergeDirectory(sourcePath, targetPath, finalAction),
          "one by one": async () => {
            const files = await fsReaddir(sourcePath);
            const paths2 = files.map((source) => ({
              source,
              target: import_path7.default.join(targetPath, import_path7.default.basename(source))
            }));
            await overwritePrompt(promptText, paths2, action);
          }
        });
      } else {
        await prompt_();
      }
    } else {
      if (targetLstat.isDirectory()) {
        await prompt_();
      } else {
        await prompt_();
      }
    }
  }
  return { endFullpaths };
}
function readFileLines(fullpath, start, end) {
  if (!import_fs10.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  const res = [];
  const stream = import_fs10.default.createReadStream(fullpath, { encoding: "utf8" });
  const rl = import_readline.default.createInterface({
    input: stream,
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve6, reject) => {
    stream.on("error", reject);
    rl.on("line", (line) => {
      if (n === 0 && line.startsWith("\uFEFF")) {
        line = line.slice(1);
      }
      if (n >= start && n <= end) {
        res.push(line);
      }
      if (n === end) {
        rl.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve6(res);
    });
    rl.on("error", reject);
  });
}
async function inDirectory(dir, patterns) {
  try {
    const files = await fsReaddir(dir);
    for (const pattern of patterns) {
      const isWildcard = pattern.includes("*");
      const ret = isWildcard ? import_minimatch.default.match(files, pattern, {
        nobrace: true,
        noext: true,
        nocomment: true,
        nonegate: true,
        dot: true
      }).length !== 0 : files.includes(pattern);
      if (ret)
        return true;
    }
  } catch {
  }
  return false;
}
function displayedFullpath(s3) {
  const homePath = import_os2.default.homedir();
  if (s3.startsWith(homePath)) {
    return `~${s3.slice(homePath.length)}`;
  }
  return s3;
}
async function listDrive() {
  if (isWindows2) {
    const content = await execCmd("wmic", ["logicaldisk", "get", "name"]);
    const list = content.split("\n").map((d3) => d3.trim()).filter((d3) => d3.endsWith(":")).map((d3) => `${d3}\\`);
    return list;
  } else {
    throw new Error(`not support listDrive in ${process.platform}`);
  }
}

// src/util/path.ts
var import_os3 = __toESM(require("os"));
var import_path8 = __toESM(require("path"));
function getExtensions(filename) {
  const parts = import_path8.default.basename(filename).split(".");
  const [basename2, ...extensions3] = parts;
  if (basename2) {
    return { basename: basename2, extensions: extensions3 };
  } else {
    const [basename22, ...extensions22] = extensions3;
    return {
      basename: [basename2, basename22].join("."),
      extensions: extensions22
    };
  }
}
function normalizePath(path2) {
  let _path = import_path8.default.normalize(path2);
  if (_path[0] === "~") {
    _path = import_path8.default.join(import_os3.default.homedir(), _path.slice(1));
  }
  if (isWindows2 && /[a-z]:/.test(_path)) {
    const driveChar = _path[0];
    _path = driveChar.toUpperCase() + _path.slice(1);
  }
  return _path;
}
function isParentFolder(folder, filepath) {
  let finalFolder = normalizePath(import_path8.default.resolve(folder));
  const finalFilepath = normalizePath(import_path8.default.resolve(filepath));
  if (finalFolder === "//")
    finalFolder = "/";
  if (finalFolder.endsWith(import_path8.default.sep))
    return finalFilepath.startsWith(finalFolder);
  return finalFilepath.startsWith(finalFolder) && finalFilepath[finalFolder.length] === import_path8.default.sep;
}

// src/util/vim.ts
var import_coc17 = require("coc.nvim");
var import_color_convert = __toESM(require_color_convert());
function supportedFloat() {
  return import_coc17.workspace.floatSupported;
}
function supportedNvimFloating() {
  return import_coc17.workspace.isNvim && supportedFloat();
}
async function enableWrapscan() {
  const wrapscan = await import_coc17.workspace.nvim.getOption("wrapscan");
  return !!wrapscan;
}
function generateHighlightFg(groupName, hl) {
  if (!hl) {
    return;
  }
  const guifg = hl.guifg;
  if (guifg) {
    const ctermfg = hl.ctermfg ?? import_color_convert.default.rgb.ansi256([guifg.red, guifg.green, guifg.blue]);
    return `highlight default ${groupName} ctermfg=${ctermfg} guifg=#${toHex(
      guifg
    )}`;
  } else if (hl.ctermfg) {
    return `highlight default ${groupName} ctermfg=${hl.ctermfg}`;
  }
}
async function displayWidth2(str) {
  return import_coc17.workspace.nvim.strWidth(str);
}
async function displaySlice(str, start, end) {
  return await import_coc17.workspace.nvim.call("coc_explorer#util#strdisplayslice", [
    str,
    start,
    end ?? void 0
  ]);
}
function closeWinByBufnrNotifier(bufnrs) {
  return Notifier.create(() => {
    import_coc17.workspace.nvim.call("coc_explorer#util#close_win_by_bufnr", bufnrs, true);
  });
}
async function winnrByBufnr(bufnr) {
  if (!bufnr) {
    return void 0;
  }
  return import_coc17.workspace.nvim.call("bufwinnr", bufnr).then((winnr) => {
    if (winnr > 0) {
      return winnr;
    } else {
      return void 0;
    }
  });
}
async function winidByWinnr(winnr) {
  if (!winnr) {
    return void 0;
  }
  const winid = await import_coc17.workspace.nvim.call("win_getid", winnr);
  if (winid >= 0) {
    return winid;
  } else {
    return void 0;
  }
}
async function winByWinid(winid) {
  if (winid) {
    return import_coc17.workspace.nvim.createWindow(winid);
  } else {
    return void 0;
  }
}
async function bufnrByWinnrOrWinid(winnrOrWinid) {
  if (!winnrOrWinid) {
    return void 0;
  }
  const bufnr = await import_coc17.workspace.nvim.call("winbufnr", winnrOrWinid);
  if (bufnr >= 0) {
    return bufnr;
  } else {
    return void 0;
  }
}
async function winidsByBufnr(bufnr) {
  return await import_coc17.workspace.nvim.call("win_findbuf", [bufnr]);
}
async function winidsByBufnrInCurTab(bufnr) {
  const tabpage = await import_coc17.workspace.nvim.tabpage;
  const wins = await tabpage.windows;
  const winidsOfTab = wins.map((win) => win.id);
  const allWinids = await import_coc17.workspace.nvim.call("win_findbuf", [
    bufnr
  ]);
  return allWinids.filter((winid) => winidsOfTab.includes(winid));
}
async function leaveEmptyInWinids(winids) {
  const curWinid = await import_coc17.workspace.nvim.call("win_getid", []);
  if (!winids.length) {
    return;
  }
  import_coc17.workspace.nvim.pauseNotification();
  for (const winid of winids) {
    import_coc17.workspace.nvim.call("win_gotoid", [winid], true);
    import_coc17.workspace.nvim.command("enew", true);
    if (import_coc17.workspace.isVim) {
      import_coc17.workspace.nvim.command("redraw", true);
    }
  }
  import_coc17.workspace.nvim.call("win_gotoid", [curWinid], true);
  await import_coc17.workspace.nvim.resumeNotification();
}
async function currentBufnr() {
  return import_coc17.workspace.nvim.call("bufnr");
}

// src/util/ui.ts
var import_coc18 = require("coc.nvim");
var floatInputExt;
async function getFloatInputApi() {
  if (!floatInputExt) {
    floatInputExt = import_coc18.extensions.all.find((e2) => e2.id === "coc-floatinput");
  }
  return floatInputExt == null ? void 0 : floatInputExt.exports;
}
async function getFloatUI() {
  var _a;
  if (!config.get("enableFloatinput")) {
    return void 0;
  }
  return (_a = await getFloatInputApi()) == null ? void 0 : _a.FloatingUI;
}
async function vimPrompt(msg, choices, defaultChoice) {
  if (!choices) {
    choices = ["yes", "no"];
    defaultChoice = "no";
  }
  const defaultNumber = defaultChoice ? choices.indexOf(defaultChoice) : -1;
  const result = await import_coc18.workspace.nvim.call("confirm", [
    msg,
    choices.map((choice) => {
      let index = [...choice].findIndex((ch) => /[A-Z]/.test(ch));
      if (index === -1) {
        index = 0;
      }
      return `${choice.slice(0, index)}&${choice[index].toUpperCase()}${choice.slice(index + 1)}`;
    }).join("\n"),
    defaultNumber + 1
  ]);
  if (result !== 0) {
    return choices[result - 1];
  }
}
async function prompt(msg, choices, defaultChoice) {
  const FloatUI = await getFloatUI();
  if (FloatUI) {
    return FloatUI.confirm({
      prompt: msg,
      values: choices,
      defaultValue: defaultChoice
    });
  } else {
    return vimPrompt(msg, choices, defaultChoice);
  }
}
async function vimInput(prompt2, defaultInput = "", completion = void 0) {
  return import_coc18.workspace.nvim.callAsync("coc#util#with_callback", [
    "input",
    [`${prompt2} `, defaultInput, completion]
  ]);
}
async function input(prompt2, defaultInput = "", completion = void 0) {
  const FloatUI = await getFloatUI();
  if (FloatUI) {
    return await FloatUI.stringInput({
      prompt: prompt2,
      defaultValue: defaultInput
    }) ?? "";
  } else {
    return vimInput(prompt2, defaultInput, completion);
  }
}
async function selectWindowsUI(config4, sourceType, {
  onSelect,
  noChoice,
  onCancel
}) {
  let filterOption = config4.get("openAction.select.filter");
  if (filterOption.sources) {
    const sourceFilterOption = filterOption.sources[sourceType];
    if (sourceFilterOption) {
      filterOption = {
        ...filterOption,
        ...sourceFilterOption
      };
    }
  }
  const winnr = await import_coc18.workspace.nvim.call("coc_explorer#select_wins#start", [
    filterOption.buftypes ?? [],
    filterOption.filetypes ?? [],
    filterOption.floatingWindows ?? true
  ]);
  if (winnr > 0) {
    await Promise.resolve(onSelect(winnr));
  } else if (winnr === 0) {
    await Promise.resolve(noChoice == null ? void 0 : noChoice());
  } else {
    await Promise.resolve(onCancel == null ? void 0 : onCancel());
  }
}

// src/util/uri.ts
function generateUri2(path2, scheme = "file") {
  if (scheme === "file" && isWindows2 && /^[A-Za-z]:/.test(path2)) {
    path2 = `/${path2}`;
  }
  return `${scheme}://${path2}`;
}

// src/util/color.ts
var import_color_convert2 = __toESM(require_color_convert());
function createColor(red, green, blue, alpha) {
  return { red, green, blue, alpha };
}
function colorDistance(c1, c2) {
  const rmean = (c1.red + c2.red) / 2;
  const r = c1.red - c2.red;
  const g = c1.green - c2.green;
  const b2 = c1.blue - c2.blue;
  return Math.sqrt(
    ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b2 * b2 >> 8)
  );
}
function findNearestColor(color, list, getColor = (it) => it) {
  return minBy_default(list, (it) => colorDistance(getColor(it), color));
}
function parseColor(str) {
  str = str.trim();
  if (str[0] === "#") {
    str = str.slice(1);
  }
  const m3 = str.match(/.{1,2}/g);
  if (!m3)
    return;
  const [r, g, b2] = m3;
  const ri = parseInt(r, 16);
  if (isNaN(ri))
    return;
  const gi = parseInt(g, 16);
  if (isNaN(gi))
    return;
  const bi = parseInt(b2, 16);
  if (isNaN(bi))
    return;
  return createColor(ri, gi, bi, 1);
}
function toHex(color) {
  return import_color_convert2.default.rgb.hex(color.red, color.green, color.blue);
}

// src/util/rx.ts
var import_coc19 = require("coc.nvim");

// node_modules/rxjs/dist/esm/internal/util/isFunction.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  const _super = (instance) => {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  const ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {
  _super(this);
  this.message = errors ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i2) => `${i2 + 1}) ${err.toString()}`).join("\n  ")}` : "";
  this.name = "UnsubscriptionError";
  this.errors = errors;
});

// node_modules/rxjs/dist/esm/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    const index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm/internal/Subscription.js
var Subscription = class {
  constructor(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  unsubscribe() {
    let errors;
    if (!this.closed) {
      this.closed = true;
      const { _parentage } = this;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          for (const parent of _parentage) {
            parent.remove(this);
          }
        } else {
          _parentage.remove(this);
        }
      }
      const { initialTeardown: initialFinalizer } = this;
      if (isFunction2(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      const { _finalizers } = this;
      if (_finalizers) {
        this._finalizers = null;
        for (const finalizer of _finalizers) {
          try {
            execFinalizer(finalizer);
          } catch (err) {
            errors = errors !== null && errors !== void 0 ? errors : [];
            if (err instanceof UnsubscriptionError) {
              errors = [...errors, ...err.errors];
            } else {
              errors.push(err);
            }
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  }
  add(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  }
  _hasParent(parent) {
    const { _parentage } = this;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  }
  _addParent(parent) {
    const { _parentage } = this;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  }
  _removeParent(parent) {
    const { _parentage } = this;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  }
  remove(teardown) {
    const { _finalizers } = this;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription) {
      teardown._removeParent(this);
    }
  }
};
Subscription.EMPTY = (() => {
  const empty = new Subscription();
  empty.closed = true;
  return empty;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction2(value.remove) && isFunction2(value.add) && isFunction2(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction2(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm/internal/config.js
var config2 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout(handler, timeout, ...args) {
    const { delegate } = timeoutProvider;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout(handler, timeout, ...args);
    }
    return setTimeout(handler, timeout, ...args);
  },
  clearTimeout(handle) {
    const { delegate } = timeoutProvider;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(() => {
    const { onUnhandledError } = config2;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm/internal/util/noop.js
function noop2() {
}

// node_modules/rxjs/dist/esm/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = (() => createNotification("C", void 0, void 0))();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config2.useDeprecatedSynchronousErrorHandling) {
    const isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      const { errorThrown, error } = context;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config2.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm/internal/Subscriber.js
var Subscriber = class extends Subscription {
  constructor(destination) {
    super();
    this.isStopped = false;
    if (destination) {
      this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(this);
      }
    } else {
      this.destination = EMPTY_OBSERVER;
    }
  }
  static create(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  }
  next(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  }
  error(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  }
  complete() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  }
  unsubscribe() {
    if (!this.closed) {
      this.isStopped = true;
      super.unsubscribe();
      this.destination = null;
    }
  }
  _next(value) {
    this.destination.next(value);
  }
  _error(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  }
  _complete() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }
};
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = class {
  constructor(partialObserver) {
    this.partialObserver = partialObserver;
  }
  next(value) {
    const { partialObserver } = this;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  }
  error(err) {
    const { partialObserver } = this;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  }
  complete() {
    const { partialObserver } = this;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  }
};
var SafeSubscriber = class extends Subscriber {
  constructor(observerOrNext, error, complete) {
    super();
    let partialObserver;
    if (isFunction2(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      let context2;
      if (this && config2.useDeprecatedNextContext) {
        context2 = Object.create(observerOrNext);
        context2.unsubscribe = () => this.unsubscribe();
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context2),
          error: observerOrNext.error && bind(observerOrNext.error, context2),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context2)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    this.destination = new ConsumerObserver(partialObserver);
  }
};
function handleUnhandledError(error) {
  if (config2.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  const { onStoppedNotification } = config2;
  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop2,
  error: defaultErrorHandler,
  complete: noop2
};

// node_modules/rxjs/dist/esm/internal/symbol/observable.js
var observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();

// node_modules/rxjs/dist/esm/internal/util/identity.js
function identity2(x2) {
  return x2;
}

// node_modules/rxjs/dist/esm/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity2;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input2) {
    return fns.reduce((prev, fn) => fn(prev), input2);
  };
}

// node_modules/rxjs/dist/esm/internal/Observable.js
var Observable = class {
  constructor(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  lift(operator) {
    const observable2 = new Observable();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  }
  subscribe(observerOrNext, error, complete) {
    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(() => {
      const { operator, source } = this;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
    });
    return subscriber;
  }
  _trySubscribe(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  }
  forEach(next, promiseCtor) {
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor((resolve6, reject) => {
      const subscriber = new SafeSubscriber({
        next: (value) => {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve6
      });
      this.subscribe(subscriber);
    });
  }
  _subscribe(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  }
  [observable]() {
    return this;
  }
  pipe(...operations) {
    return pipeFromArray(operations)(this);
  }
  toPromise(promiseCtor) {
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor((resolve6, reject) => {
      let value;
      this.subscribe((x2) => value = x2, (err) => reject(err), () => resolve6(value));
    });
  }
};
Observable.create = (subscribe) => {
  return new Observable(subscribe);
};
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config2.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction2(value.next) && isFunction2(value.error) && isFunction2(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm/internal/util/lift.js
function hasLift(source) {
  return isFunction2(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return (source) => {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = class extends Subscriber {
  constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    super(destination);
    this.onFinalize = onFinalize;
    this.shouldUnsubscribe = shouldUnsubscribe;
    this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : super._next;
    this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : super._error;
    this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : super._complete;
  }
  unsubscribe() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      const { closed } = this;
      super.unsubscribe();
      !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  }
};

// node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {
  _super(this);
  this.name = "ObjectUnsubscribedError";
  this.message = "object unsubscribed";
});

// node_modules/rxjs/dist/esm/internal/Subject.js
var Subject = class extends Observable {
  constructor() {
    super();
    this.closed = false;
    this.currentObservers = null;
    this.observers = [];
    this.isStopped = false;
    this.hasError = false;
    this.thrownError = null;
  }
  lift(operator) {
    const subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  }
  _throwIfClosed() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  }
  next(value) {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        if (!this.currentObservers) {
          this.currentObservers = Array.from(this.observers);
        }
        for (const observer of this.currentObservers) {
          observer.next(value);
        }
      }
    });
  }
  error(err) {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        this.hasError = this.isStopped = true;
        this.thrownError = err;
        const { observers } = this;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  }
  complete() {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        this.isStopped = true;
        const { observers } = this;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  }
  unsubscribe() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  }
  get observed() {
    var _a;
    return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  _trySubscribe(subscriber) {
    this._throwIfClosed();
    return super._trySubscribe(subscriber);
  }
  _subscribe(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  }
  _innerSubscribe(subscriber) {
    const { hasError, isStopped, observers } = this;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(() => {
      this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  }
  _checkFinalizedStatuses(subscriber) {
    const { hasError, thrownError, isStopped } = this;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  }
  asObservable() {
    const observable2 = new Observable();
    observable2.source = this;
    return observable2;
  }
};
Subject.create = (destination, source) => {
  return new AnonymousSubject(destination, source);
};
var AnonymousSubject = class extends Subject {
  constructor(destination, source) {
    super();
    this.destination = destination;
    this.source = source;
  }
  next(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  }
  error(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  }
  complete() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  _subscribe(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/scheduler/Action.js
var Action = class extends Subscription {
  constructor(scheduler, work) {
    super();
  }
  schedule(state, delay = 0) {
    return this;
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval(handler, timeout, ...args) {
    const { delegate } = intervalProvider;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval(handler, timeout, ...args);
    }
    return setInterval(handler, timeout, ...args);
  },
  clearInterval(handle) {
    const { delegate } = intervalProvider;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js
var AsyncAction = class extends Action {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
    this.pending = false;
  }
  schedule(state, delay = 0) {
    var _a;
    if (this.closed) {
      return this;
    }
    this.state = state;
    const id = this.id;
    const scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
    return this;
  }
  requestAsyncId(scheduler, _id, delay = 0) {
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  }
  recycleAsyncId(_scheduler, id, delay = 0) {
    if (delay != null && this.delay === delay && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  }
  execute(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    const error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  }
  _execute(state, _delay) {
    let errored = false;
    let errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  }
  unsubscribe() {
    if (!this.closed) {
      const { id, scheduler } = this;
      const { actions } = scheduler;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      super.unsubscribe();
    }
  }
};

// node_modules/rxjs/dist/esm/internal/Scheduler.js
var Scheduler = class {
  constructor(schedulerActionCtor, now = Scheduler.now) {
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  schedule(work, delay = 0, state) {
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  }
};
Scheduler.now = dateTimestampProvider.now;

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = class extends Scheduler {
  constructor(SchedulerAction, now = Scheduler.now) {
    super(SchedulerAction, now);
    this.actions = [];
    this._active = false;
  }
  flush(action) {
    const { actions } = this;
    if (this._active) {
      actions.push(action);
      return;
    }
    let error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction2(value.schedule);
}

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// node_modules/rxjs/dist/esm/internal/util/isArrayLike.js
var isArrayLike2 = (x2) => x2 && typeof x2.length === "number" && typeof x2 !== "function";

// node_modules/rxjs/dist/esm/internal/util/isPromise.js
function isPromise(value) {
  return isFunction2(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js
function isInteropObservable(input2) {
  return isFunction2(input2[observable]);
}

// node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction2(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input2) {
  return new TypeError(`You provided ${input2 !== null && typeof input2 === "object" ? "an invalid object" : `'${input2}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
}

// node_modules/rxjs/dist/esm/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm/internal/util/isIterable.js
function isIterable(input2) {
  return isFunction2(input2 === null || input2 === void 0 ? void 0 : input2[iterator]);
}

// node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const { value, done } = yield __await(reader.read());
        if (done) {
          return yield __await(void 0);
        }
        yield yield __await(value);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function isReadableStreamLike(obj) {
  return isFunction2(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm/internal/observable/innerFrom.js
function innerFrom(input2) {
  if (input2 instanceof Observable) {
    return input2;
  }
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return fromInteropObservable(input2);
    }
    if (isArrayLike2(input2)) {
      return fromArrayLike(input2);
    }
    if (isPromise(input2)) {
      return fromPromise(input2);
    }
    if (isAsyncIterable(input2)) {
      return fromAsyncIterable(input2);
    }
    if (isIterable(input2)) {
      return fromIterable(input2);
    }
    if (isReadableStreamLike(input2)) {
      return fromReadableStreamLike(input2);
    }
  }
  throw createInvalidObservableTypeError(input2);
}
function fromInteropObservable(obj) {
  return new Observable((subscriber) => {
    const obs = obj[observable]();
    if (isFunction2(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable((subscriber) => {
    for (let i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable((subscriber) => {
    promise.then((value) => {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, (err) => subscriber.error(err)).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable((subscriber) => {
    for (const value of iterable) {
      subscriber.next(value);
      if (subscriber.closed) {
        return;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable((subscriber) => {
    process2(asyncIterable, subscriber).catch((err) => subscriber.error(err));
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_1, _a;
  return __awaiter(this, void 0, void 0, function* () {
    try {
      for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done; ) {
        const value = asyncIterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))
          yield _a.call(asyncIterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}

// node_modules/rxjs/dist/esm/internal/util/EmptyError.js
var EmptyError = createErrorClass((_super) => function EmptyErrorImpl() {
  _super(this);
  this.name = "EmptyError";
  this.message = "no elements in sequence";
});

// node_modules/rxjs/dist/esm/internal/firstValueFrom.js
function firstValueFrom(source, config4) {
  const hasConfig = typeof config4 === "object";
  return new Promise((resolve6, reject) => {
    const subscriber = new SafeSubscriber({
      next: (value) => {
        resolve6(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: () => {
        if (hasConfig) {
          resolve6(config4.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm/internal/observable/timer.js
function timer(dueTime = 0, intervalOrScheduler, scheduler = async) {
  let intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable((subscriber) => {
    let due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    let n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm/internal/operators/buffer.js
function buffer(closingNotifier) {
  return operate((source, subscriber) => {
    let currentBuffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, (value) => currentBuffer.push(value), () => {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    innerFrom(closingNotifier).subscribe(createOperatorSubscriber(subscriber, () => {
      const b2 = currentBuffer;
      currentBuffer = [];
      subscriber.next(b2);
    }, noop2));
    return () => {
      currentBuffer = null;
    };
  });
}

// node_modules/rxjs/dist/esm/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler = asyncScheduler) {
  return operate((source, subscriber) => {
    let activeTask = null;
    let lastValue = null;
    let lastTime = null;
    const emit = () => {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        const value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      const targetTime = lastTime + dueTime;
      const now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, () => {
      emit();
      subscriber.complete();
    }, void 0, () => {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate((source, subscriber) => {
    let innerSubscriber = null;
    let index = 0;
    let isComplete = false;
    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      let innerIndex = 0;
      const outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {
        innerSubscriber = null;
        checkComplete();
      }));
    }, () => {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/throttle.js
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config4 = defaultThrottleConfig) {
  return operate((source, subscriber) => {
    const { leading, trailing } = config4;
    let hasValue = false;
    let sendValue = null;
    let throttled = null;
    let isComplete = false;
    const endThrottling = () => {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    const cleanupThrottling = () => {
      throttled = null;
      isComplete && subscriber.complete();
    };
    const startThrottle = (value) => throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    const send = () => {
      if (hasValue) {
        hasValue = false;
        const value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, () => {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/throttleTime.js
function throttleTime(duration, scheduler = asyncScheduler, config4 = defaultThrottleConfig) {
  const duration$ = timer(duration, scheduler);
  return throttle(() => duration$, config4);
}

// src/util/rx.ts
function subjectToHook(observable2) {
  return (fn) => {
    const sub = observable2.subscribe(logger.asyncCatch(fn));
    return import_coc19.Disposable.create(() => sub.unsubscribe());
  };
}
function createSubject(builder) {
  const sub = new Subject();
  const obs = builder(sub);
  obs.subscribe({
    error: logger.error
  });
  return sub;
}
function fromHelperEvent(events6, key) {
  const sub = new Subject();
  events6.once(key, (v) => {
    sub.next(v);
  });
  return sub.asObservable();
}
function fromEmitter(emitter) {
  const sub = new Subject();
  emitter.event((value) => {
    sub.next(value);
  });
  return sub.asObservable();
}
function debounceFn(dueTime, fn) {
  const sub = new Subject();
  sub.pipe(
    debounceTime(dueTime),
    switchMap(async (args) => fn(...args))
  ).subscribe({ error: logger.error });
  const wrappedFn = (...args) => sub.next(args);
  wrappedFn.dispose = () => sub.unsubscribe();
  return wrappedFn;
}
function throttleFn(dueTime, fn, config4) {
  const sub = new Subject();
  sub.pipe(
    throttleTime(dueTime, void 0, config4),
    switchMap(async (args) => fn(...args))
  ).subscribe({
    error: logger.error
  });
  const wrappedFn = (...args) => sub.next(args);
  wrappedFn.dispose = () => sub.unsubscribe();
  return wrappedFn;
}

// src/util/object.ts
function hasOwnProperty14(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

// src/util/index.ts
var logger = new HelperLogger("explorer");

// src/lists/runner.ts
var import_coc20 = require("coc.nvim");
var argSym = Symbol("arg");
var ProxyList = class extends import_coc20.BasicList {
  constructor(init) {
    super(import_coc20.workspace.nvim);
    this.name = init.name;
    this.#loadItems = (context2, token) => init.loadItems(this[argSym], context2, token);
    if (init.doHighlight) {
      this.doHighlight = init.doHighlight;
    }
    if (init.defaultAction) {
      this.defaultAction = init.defaultAction;
    }
    const initContext = {
      addAction: (name, fn, options) => this.addAction(
        name,
        (item, context2) => fn({
          arg: this[argSym],
          item,
          context: context2
        }),
        options
      ),
      addLocationActions: () => this.addLocationActions(),
      convertLocation: (location) => this.convertLocation(location)
    };
    init.init.call(initContext, initContext);
  }
  #loadItems;
  loadItems(context2, token) {
    return this.#loadItems(context2, token);
  }
};
argSym;
function registerList(init) {
  return new ProxyList(init);
}
async function startCocList(explorer, list, arg, listArgs = []) {
  list[argSym] = arg;
  const config4 = explorer.config;
  const nvim = explorer.nvim;
  const bufManager = explorer.explorerManager.bufManager;
  const floatingHideOnCocList = config4.get("floating.hideOnCocList", true);
  let isExplorerShown = true;
  if (explorer.isFloating && floatingHideOnCocList) {
    await explorer.hide();
    isExplorerShown = false;
  }
  const shownExplorerEmitter = new import_coc20.Emitter();
  const listDisposable = import_coc20.listManager.registerList(list);
  await nvim.command(`CocList ${listArgs.join(" ")} ${list.name}`);
  listDisposable.dispose();
  return {
    async waitExplorerShow() {
      await bufManager.waitReload();
      const eventDisposable = import_coc20.events.on("BufEnter", async () => {
        const buf = bufManager.getBufferNode(`list:///${list.name}`);
        if (buf && await winnrByBufnr(buf.bufnr)) {
          return;
        }
        eventDisposable.dispose();
        if (explorer.isFloating && !isExplorerShown) {
          await sleep2(200);
          await explorer.show();
          shownExplorerEmitter.fire();
        }
      });
      if (isExplorerShown) {
        return;
      }
      return new Promise((resolve6) => {
        shownExplorerEmitter.event(() => {
          isExplorerShown = true;
          resolve6(void 0);
        });
      });
    }
  };
}

// src/lists/actions.ts
function score(list, key) {
  const idx = list.indexOf(key);
  return idx === -1 ? -1 : list.length - idx;
}
var actionListMru = import_coc21.workspace.createMru("explorer-actions");
var explorerActionList = registerList({
  name: "explorerActionList",
  defaultAction: "do",
  async loadItems(actions) {
    const mruList = await actionListMru.load();
    const items = actions.map((actionData) => ({
      label: `${actionData.name} [${actionData.key || ""}] ${actionData.description}`,
      data: {
        ...actionData,
        score: score(mruList, actionData.name)
      }
    }));
    items.sort((a3, b2) => b2.data.score - a3.data.score);
    return items;
  },
  doHighlight() {
    const { nvim } = import_coc21.workspace;
    nvim.pauseNotification();
    nvim.command(
      "syntax match CocExplorerActionName /\\v^[a-zA-Z0-9:|<>]+/",
      true
    );
    nvim.command("syntax match CocExplorerActionKey /\\v\\[.*\\]/", true);
    nvim.command(
      "syntax match CocExplorerActionDescription /\\v\\] \\zs.*/",
      true
    );
    nvim.command("highlight default link CocExplorerActionName PreProc", true);
    nvim.command(
      "highlight default link CocExplorerActionKey Identifier",
      true
    );
    nvim.command(
      "highlight default link CocExplorerActionDescription Comment",
      true
    );
    nvim.resumeNotification().catch(logger.error);
  },
  init() {
    this.addAction("do", ({ item }) => {
      logger.asyncCatch(async () => {
        const data = item.data;
        await data.callback();
        await actionListMru.add(data.name);
      })();
    });
  }
});

// src/mappings/index.ts
var import_coc22 = require("coc.nvim");

// src/actions/special.ts
var conditionActionRules = {
  "expandable?": {
    filter: (_s, n) => n.expandable,
    getHelpDescription: () => "expandable?"
  },
  "expanded?": {
    filter: (s3, n) => s3.view.isExpanded(n),
    getHelpDescription: () => "expanded?"
  },
  "type?": {
    filter: (_s, n, args) => n.type === args[0],
    getHelpDescription: (args) => `type is ${args[0]}`
  }
};
var waitAction = {
  name: "wait",
  helpDescription: "<wait>"
};
var noopAction = {
  name: "noop",
  helpDescription: "<noop>"
};

// src/mappings/index.ts
function parseOriginalAction(originalAction) {
  if (typeof originalAction !== "string") {
    return originalAction;
  }
  const [name, ...args] = originalAction.split(/:/);
  return {
    name,
    args
  };
}
function toOriginalAction(action) {
  const { name, args } = action;
  return [name, ...args].join(":");
}
function parseMappingKey(key) {
  return key.includes("<dot>") ? key.replace(/<dot>/g, ".") : key;
}
function parseOriginalActionExp(originalActionExp) {
  if (Array.isArray(originalActionExp)) {
    return originalActionExp.map(parseOriginalActionExp);
  } else {
    return parseOriginalAction(originalActionExp);
  }
}
function parseOriginalMappings(originalMappings) {
  const mappings2 = {};
  for (const [key, originalActionExp] of Object.entries(originalMappings)) {
    mappings2[parseMappingKey(key)] = parseOriginalActionExp(originalActionExp);
  }
  return mappings2;
}
function mixAndParseMappings(defaultMappings, userMappings) {
  const mappings2 = parseOriginalMappings(defaultMappings);
  for (const [key, originalActionExp] of Object.entries(userMappings)) {
    if (originalActionExp === false) {
      delete mappings2[key];
      continue;
    }
    mappings2[parseMappingKey(key)] = parseOriginalActionExp(originalActionExp);
  }
  return mappings2;
}
function getSingleAction(actionExp) {
  if (!Array.isArray(actionExp)) {
    return actionExp;
  } else {
    const actions = actionExp.map((action) => getSingleAction(action)).filter(
      (action) => action && !(action.name in conditionActionRules) && action.name !== waitAction.name && action.name !== noopAction.name
    );
    return actions[0];
  }
}
var KeyMapping = class {
  constructor() {
    this.mode = config.get("keyMappingMode", "default");
    this.mouseMappings = {
      none: {},
      singleclick: {
        "<LeftRelease>": [
          "expandable?",
          ["expanded?", "collapse", "expand"],
          "open"
        ]
      },
      doubleclick: {
        "<2-LeftMouse>": [
          "expandable?",
          ["expanded?", "collapse", "expand"],
          "open"
        ]
      }
    }[config.get("mouseMode")];
    this.configByModes = {
      none: {
        global: {},
        vmap: {},
        sources: {}
      },
      default: {
        global: {
          "*": "toggleSelection",
          "<tab>": "actionMenu",
          h: ["wait", "collapse"],
          l: ["wait", "expandable?", "expand", "open"],
          J: ["wait", "toggleSelection", "normal:j"],
          K: ["wait", "toggleSelection", "normal:k"],
          gl: ["wait", "expand:recursive"],
          gh: ["wait", "collapse:recursive"],
          ...this.mouseMappings,
          o: ["wait", "expanded?", "collapse", "expand"],
          "<cr>": ["wait", "expandable?", "cd", "open"],
          e: "open",
          s: "open:split",
          E: "open:vsplit",
          t: "open:tab",
          "<bs>": ["wait", "gotoParent"],
          gs: ["wait", "reveal:select"],
          il: "preview:labeling",
          ic: "preview:content",
          Il: "previewOnHover:toggle:labeling",
          Ic: "previewOnHover:toggle:content",
          II: "previewOnHover:disable",
          yp: "copyFilepath",
          yn: "copyFilename",
          yy: "copyFile",
          yt: "copyFile:toggle",
          ya: "copyFile:append",
          "y<space>": "clearCopyOrCut",
          dd: "cutFile",
          dt: "cutFile:toggle",
          da: "cutFile:append",
          "d<space>": "clearCopyOrCut",
          p: ["pasteFile", "clearCopyOrCut"],
          P: "pasteFile",
          df: "delete",
          dF: "deleteForever",
          a: "addFile",
          A: "addDirectory",
          r: "rename",
          zh: "toggleHidden",
          "g<dot>": "toggleHidden",
          R: "refresh",
          "?": "help",
          q: "quit",
          "<esc>": "esc",
          X: "systemExecute",
          gd: "listDrive",
          f: "search",
          F: "search:recursive",
          gf: "gotoSource:file",
          gb: "gotoSource:buffer",
          "[[": ["wait", "sourcePrev"],
          "]]": ["wait", "sourceNext"],
          "[i": ["wait", "indentPrev"],
          "]i": ["wait", "indentNext"],
          "[m": ["wait", "markPrev:modified"],
          "]m": ["wait", "markNext:modified"],
          "[d": ["wait", "markPrev:diagnosticError:diagnosticWarning"],
          "]d": ["wait", "markNext:diagnosticError:diagnosticWarning"],
          "[D": ["wait", "markPrev:diagnosticError"],
          "]D": ["wait", "markNext:diagnosticError"],
          "[c": ["wait", "markPrev:gitUnstaged:gitStaged"],
          "]c": ["wait", "markNext:gitUnstaged:gitStaged"],
          "[C": ["wait", "markPrev:gitUnstaged"],
          "]C": ["wait", "markNext:gitUnstaged"],
          "<<": "gitStage",
          ">>": "gitUnstage"
        },
        vmap: {
          il: "textobj:line:i",
          al: "textobj:line:a",
          ii: "textobj:indent:i",
          ai: "textobj:indent:a"
        },
        sources: {}
      }
    };
  }
  get config() {
    return this.configByModes[this.mode];
  }
  globalMappings() {
    if (!this.globalMappings_) {
      this.globalMappings_ = mixAndParseMappings(this.config.global, {
        ...config.get("keyMappings.global", {})
      });
    }
    return this.globalMappings_;
  }
  vmapMappings() {
    if (!this.vmapMappings_) {
      this.vmapMappings_ = mixAndParseMappings(this.config.vmap, {
        ...config.get("keyMappings.vmap", {})
      });
    }
    return this.vmapMappings_;
  }
  allSourceMappings() {
    if (!this.allSourceMappings_) {
      const defaultSources = this.config.sources ?? {};
      const userSources = config.get(
        "keyMappings.sources",
        {}
      );
      this.allSourceMappings_ = /* @__PURE__ */ new Map();
      for (const [type, sourceMappings] of Object.entries(defaultSources)) {
        this.allSourceMappings_.set(type, {
          ...parseOriginalMappings(sourceMappings)
        });
      }
      for (const [type, sourceMappings] of Object.entries(userSources)) {
        const mappings2 = this.allSourceMappings_.get(type);
        if (mappings2) {
          this.allSourceMappings_.set(
            type,
            mixAndParseMappings(mappings2, sourceMappings)
          );
        } else {
          this.allSourceMappings_.set(
            type,
            mixAndParseMappings({}, sourceMappings)
          );
        }
      }
    }
    return this.allSourceMappings_;
  }
  sourceMappings(sourceType) {
    return this.allSourceMappings().get(sourceType);
  }
  async filterEscForVim(keys2) {
    if (import_coc22.workspace.isVim && !await import_coc22.workspace.nvim.call("has", ["gui_running"])) {
      keys2.delete("<esc>");
    }
  }
  async getCommonKeys() {
    const keys2 = /* @__PURE__ */ new Set();
    for (const key of Object.keys(this.globalMappings())) {
      keys2.add(key);
    }
    for (const sourceMappings of this.allSourceMappings().values()) {
      for (const key of Object.keys(sourceMappings)) {
        keys2.add(key);
      }
    }
    await this.filterEscForVim(keys2);
    return keys2;
  }
  async getVisualKeys() {
    const keys2 = /* @__PURE__ */ new Set();
    for (const key of Object.keys(this.vmapMappings())) {
      keys2.add(key);
    }
    return keys2;
  }
  getActionExp(sourceType, key, mode) {
    const vmapMappings = this.vmapMappings();
    const globalMappings = this.globalMappings();
    const sourceMappings = this.sourceMappings(sourceType);
    if (mode === "v") {
      return (vmapMappings == null ? void 0 : vmapMappings[key]) ?? (sourceMappings == null ? void 0 : sourceMappings[key]) ?? globalMappings[key];
    }
    return (sourceMappings == null ? void 0 : sourceMappings[key]) ?? globalMappings[key];
  }
  async getMappings(sourceType) {
    const globalMappings = this.globalMappings();
    const vmapMappings = this.vmapMappings();
    const sourceMappings = this.sourceMappings(sourceType);
    const mappings2 = { ...globalMappings, ...sourceMappings };
    if (import_coc22.workspace.isVim && !await import_coc22.workspace.nvim.call("has", ["gui_running"])) {
      delete mappings2["<esc>"];
    }
    return {
      all: mappings2,
      vmap: vmapMappings
    };
  }
  async getReversedMappings(sourceType) {
    const mappings2 = await this.getMappings(sourceType);
    const reverseMappings = {};
    Object.entries(mappings2.all).find(([key, actionExp]) => {
      const action = getSingleAction(actionExp);
      if (action) {
        const orgAction = toOriginalAction(action);
        if (!reverseMappings[orgAction]) {
          reverseMappings[orgAction] = {};
        }
        reverseMappings[orgAction].all = key;
      }
    });
    Object.entries(mappings2.vmap).find(([key, actionExp]) => {
      const action = getSingleAction(actionExp);
      if (action) {
        const orgAction = toOriginalAction(action);
        if (!reverseMappings[orgAction]) {
          reverseMappings[orgAction] = {};
        }
        reverseMappings[orgAction].vmap = key;
      }
    });
    return reverseMappings;
  }
};
var keyMapping = new KeyMapping();

// src/actions/codeActionProider.ts
function score2(list, key) {
  const idx = list.indexOf(key);
  return idx === -1 ? -1 : list.length - idx;
}
var ActionMenuCodeActionProvider = class {
  constructor(explorerManager) {
    this.explorerManager = explorerManager;
  }
  async provideCodeActions(_document, _range, _context, _token) {
    const explorer = await this.explorerManager.currentExplorer();
    if (!explorer) {
      return [];
    }
    const source = await explorer.view.currentSource();
    if (!source) {
      return [];
    }
    const reverseMappings = await keyMapping.getReversedMappings(
      source.sourceType
    );
    const actions = source.action.registeredActions();
    const mruList = await actionListMru.load();
    return flatten_default(
      [...actions.entries()].filter(([actionName]) => actionName !== "actionMenu").sort(([aName], [bName]) => aName.localeCompare(bName)).sort(([aName], [bName]) => aName.localeCompare(bName)).map(([actionName, { options }]) => {
        const keys2 = reverseMappings[actionName];
        const key = keys2 ? keys2.vmap ?? keys2.all : "";
        const list = [
          {
            title: `${actionName} [${key}]`,
            name: actionName,
            command: "explorer.doCodeAction",
            arguments: [actionName, actionName, async () => []],
            score: score2(mruList, actionName)
          }
        ];
        if (options.menus) {
          list.push(
            ...ActionMenu.getNormalizeMenus(options.menus).map((menu) => {
              const fullActionName = `${actionName}:${menu.args}`;
              const keys3 = reverseMappings[fullActionName];
              const key2 = keys3 ? keys3.vmap ?? keys3.all : "";
              return {
                title: `${fullActionName} [${key2}]`,
                name: fullActionName,
                command: "explorer.doCodeAction",
                arguments: [
                  fullActionName,
                  actionName,
                  () => menu.actionArgs()
                ],
                score: score2(mruList, fullActionName)
              };
            })
          );
        }
        return list;
      })
    ).sort((a3, b2) => b2.score - a3.score);
  }
};

// src/bufManager.ts
var import_coc25 = require("coc.nvim");
var import_path9 = __toESM(require("path"));

// src/container.ts
var import_coc23 = require("coc.nvim");
var TabContainer = class {
  constructor() {
    this.bufnrs = /* @__PURE__ */ new Set();
  }
  getExplorer(position) {
    return this[position.name];
  }
  setExplorer(position, explorer) {
    this[position.name] = explorer;
  }
  all() {
    const explorers = [];
    if (this.left) {
      explorers.push(this.left);
    }
    if (this.right) {
      explorers.push(this.right);
    }
    if (this.tab) {
      explorers.push(this.tab);
    }
    if (this.floating) {
      explorers.push(this.floating);
    }
    return explorers;
  }
};
var TabContainerManager = class {
  constructor() {
    this.initedEmitter = new import_coc23.Emitter();
    this.tabContainerMap = /* @__PURE__ */ new Map();
    this.waitInited = firstValueFrom(fromEmitter(this.initedEmitter));
  }
  get(id) {
    const c2 = this.tabContainerMap.get(id);
    if (c2) {
      return c2;
    } else {
      const c3 = new TabContainer();
      this.tabContainerMap.set(id, c3);
      return c3;
    }
  }
  async register() {
    const bufnrs = await import_coc23.workspace.nvim.call("tabpagebuflist");
    await tabContainerManager.curTabAddBufnr(...bufnrs);
  }
  values() {
    return Array.from(this.tabContainerMap.values());
  }
  async currentTabId() {
    await this.waitInited;
    return await import_coc23.workspace.nvim.call("coc_explorer#tab#current_id");
  }
  async currentTabMaxId() {
    await this.waitInited;
    return await import_coc23.workspace.nvim.call("coc_explorer#tab#max_id");
  }
  async currentTabContainer() {
    return this.get(await this.currentTabId());
  }
  existBufnr(bufnr) {
    return this.values().some((c2) => c2.bufnrs.has(bufnr));
  }
  async curTabAddBufnr(...bufnrs) {
    const id = await this.currentTabId();
    const c2 = this.get(id);
    bufnrs.forEach((bufnr) => c2.bufnrs.add(bufnr));
  }
  async curTabDelBufnr(...bufnrs) {
    const id = await this.currentTabId();
    const c2 = this.get(id);
    bufnrs.forEach((bufnr) => c2.bufnrs.delete(bufnr));
  }
};
var tabContainerManager = new TabContainerManager();

// src/events.ts
var import_coc24 = require("coc.nvim");
var onEvent = (event, listener, thisArgs, disposables) => {
  const disposable = import_coc24.events.on(event, logger.asyncCatch(listener), thisArgs);
  const finalDisposable = import_coc24.Disposable.create(() => {
    if (typeof listener.cancel === "function") {
      listener.cancel();
    }
    if (typeof listener.dispose === "function") {
      listener.dispose();
    }
    disposable.dispose();
  });
  if (disposables) {
    disposables.push(finalDisposable);
  }
  return finalDisposable;
};
function onBufEnter(listener, delay, disposables) {
  let prevBufnr = 0;
  const handler = delay !== 0 ? debounceFn(delay, (bufnr) => {
    if (bufnr !== prevBufnr) {
      prevBufnr = bufnr;
      return listener(bufnr);
    }
  }) : listener;
  return onEvent("BufEnter", handler, void 0, disposables);
}
function onCursorMoved(listener, delay, disposables) {
  const handler = throttleFn(delay, listener, {
    leading: false,
    trailing: true
  });
  return onEvent("CursorMoved", handler, void 0, disposables);
}
function registerInternalEvents(context2) {
  const eventList = [
    [false, "BufDelete", ['+expand("<abuf>")']],
    [false, "BufWipeout", ['+expand("<abuf>")']],
    [false, "TabEnter", ['+expand("<abuf>")']],
    [false, "ColorScheme", ["g:colors_name"]],
    [true, "CocDiagnosticChange", []],
    [true, "CocGitStatusChange", []],
    [true, "FugitiveChanged", []],
    [true, "CocBookmarkChange", []]
  ];
  context2.subscriptions.push(
    ...eventList.map(
      ([user, event, arglist]) => import_coc24.workspace.registerAutocmd({
        event: user ? `User ${event}` : event,
        arglist,
        callback: async (...args) => {
          await internalEvents.fire(event, ...args);
        }
      })
    )
  );
}
var internalEvents = new HelperEventEmitter(logger);
var cocListCloseEmitter = new import_coc24.Emitter();
function doUserAutocmdNotifier(name) {
  return Notifier.create(() => {
    import_coc24.workspace.nvim.call("coc_explorer#util#do_autocmd", [name], true);
  });
}
async function doUserAutocmd(name) {
  await doUserAutocmdNotifier(name).run();
}

// src/bufManager.ts
var regex = /^\s*(\d+)(.+?)"(.+?)".*/;
var BufManager = class {
  constructor(context2) {
    this.bufferNodeMapByFullpath = /* @__PURE__ */ new Map();
    this.bufferNodeMapById = /* @__PURE__ */ new Map();
    this.nvim = import_coc25.workspace.nvim;
    this.reloadSubject = new Subject();
    this.modifiedSubject = new Subject();
    this.bufferNodes = [];
    this.onReload = subjectToHook(this.reloadSubject);
    this.onReloadDebounce = subjectToHook(this.reloadSubject.pipe(debounceTime(500)));
    this.onModifiedDebounce = subjectToHook(
      this.modifiedSubject.pipe(
        buffer(this.modifiedSubject.pipe(debounceTime(500)))
      )
    );
    this.registerEvents(context2).catch(logger.error);
  }
  async registerEvents(context2) {
    context2.subscriptions.push(
      onEvent(
        ["BufCreate", "BufHidden", "BufUnload", "BufWinEnter", "BufWinLeave"],
        throttleFn(100, () => this.reload(), {
          leading: false,
          trailing: true
        })
      ),
      internalEvents.on("BufDelete", () => this.reload()),
      internalEvents.on("BufWipeout", () => this.reload())
    );
    context2.subscriptions.push(
      onEvent(
        "BufWinEnter",
        (bufnr) => tabContainerManager.curTabAddBufnr(bufnr)
      ),
      internalEvents.on(
        "TabEnter",
        (bufnr) => tabContainerManager.curTabAddBufnr(bufnr)
      )
    );
    const refreshBufModified = async (bufnr) => {
      const bufNode = this.bufferNodeMapById.get(bufnr);
      if (!bufNode) {
        return;
      }
      const modified = await import_coc25.workspace.nvim.eval(
        `bufloaded(${bufnr}) ? getbufvar(${bufnr}, '&modified') : v:null`
      );
      if (modified === null || bufNode.modified === modified) {
        return;
      }
      bufNode.modified = modified;
      this.modifiedSubject.next(bufNode.fullpath);
    };
    context2.subscriptions.push(
      onEvent("BufWritePost", async (bufnr) => {
        await refreshBufModified(bufnr);
      }),
      ...["TextChanged", "TextChangedI", "TextChangedP"].map(
        (event) => onEvent(event, async (bufnr) => {
          await refreshBufModified(bufnr);
        })
      )
    );
  }
  async removeBufNode(bufNode, options) {
    if (!options.skipModified && bufNode.modified) {
      throw new Error("The content of buffer has not been saved!");
    }
    const winids = await winidsByBufnr(bufNode.bufnr);
    await leaveEmptyInWinids(winids);
    if (options.bwipeout) {
      await this.nvim.command(`bwipeout! ${bufNode.bufnr}`);
    } else {
      await this.nvim.command(`bdelete! ${bufNode.bufnr}`);
    }
  }
  async removePrefix(prefixFullpath, options) {
    for (const [fullpath, bufNode] of this.bufferNodeMapByFullpath) {
      if (fullpath.startsWith(prefixFullpath)) {
        await this.removeBufNode(bufNode, options);
      }
    }
  }
  async remove(fullpath, options) {
    if (options.directory) {
      return this.removePrefix(fullpath + import_path9.default.sep, options);
    } else {
      const bufNode = this.bufferNodeMapByFullpath.get(fullpath);
      if (!bufNode) {
        return;
      }
      await this.removeBufNode(bufNode, options);
    }
  }
  async replaceBufNode(bufNode, targetFullpath, options) {
    if (!options.skipModified && bufNode.modified) {
      throw new Error("The content of buffer has not been saved!");
    }
    const { nvim } = this;
    const curWinid = await nvim.call("win_getid", []);
    const winids = await winidsByBufnr(bufNode.bufnr);
    if (winids.length) {
      const escapedPath = await nvim.call("fnameescape", [
        targetFullpath
      ]);
      nvim.pauseNotification();
      for (const winid of winids) {
        nvim.call("win_gotoid", [winid], true);
        nvim.command(`edit ${escapedPath}`, true);
        if (import_coc25.workspace.isVim) {
          nvim.command("redraw", true);
        }
      }
      nvim.call("win_gotoid", [curWinid], true);
      await nvim.resumeNotification();
    }
    if (options.bwipeout) {
      await nvim.command(`bwipeout! ${bufNode.bufnr}`);
    } else {
      await nvim.command(`bdelete! ${bufNode.bufnr}`);
    }
  }
  async replacePrefix(sourceFullpath, targetFullpath, options) {
    for (const [fullpath, bufNode] of this.bufferNodeMapByFullpath) {
      if (fullpath.startsWith(sourceFullpath)) {
        const newTargetFullpath = bufNode.fullpath.replace(
          sourceFullpath,
          targetFullpath
        );
        await this.replaceBufNode(bufNode, newTargetFullpath, options);
      }
    }
  }
  async replace(sourceFullpath, targetFullpath, options) {
    return this.replacePrefix(sourceFullpath, targetFullpath, options);
  }
  modified(fullpath, options) {
    var _a;
    if (options.directory) {
      return this.modifiedPrefix(fullpath + import_path9.default.sep);
    } else {
      return ((_a = this.bufferNodeMapByFullpath.get(fullpath)) == null ? void 0 : _a.modified) ?? false;
    }
  }
  modifiedPrefix(prefixFullpath) {
    for (const [fullpath, bufNode] of this.bufferNodeMapByFullpath) {
      if (fullpath.startsWith(prefixFullpath)) {
        if (bufNode.modified) {
          return true;
        }
      }
    }
    return false;
  }
  getBufferNode(bufnrOrFullpath) {
    if (typeof bufnrOrFullpath === "number") {
      return this.bufferNodeMapById.get(bufnrOrFullpath);
    } else {
      return this.bufferNodeMapByFullpath.get(bufnrOrFullpath);
    }
  }
  async waitReload() {
    return new Promise((resolve6) => {
      const disposable = this.onReload(() => {
        disposable.dispose();
        resolve6();
      });
      setTimeout(resolve6, 100);
    });
  }
  async reload() {
    const lsCommand = "ls!";
    const content = await this.nvim.call("execute", lsCommand);
    this.bufferNodes = compactI2(
      await Promise.all(
        content.split(/\n/).map(async (line) => {
          const matches = line.match(regex);
          if (!matches) {
            return;
          }
          const bufnr = matches[1];
          const flags = matches[2];
          const bufname = matches[3];
          const fullpath = await import_coc25.workspace.nvim.call("expand", [
            `#${bufnr}:p`,
            1
          ]);
          return {
            type: "child",
            uid: bufnr,
            level: 1,
            bufnr: parseInt(bufnr),
            bufnrStr: bufnr,
            bufname,
            fullpath,
            name: import_path9.default.basename(bufname),
            unlisted: flags.includes("u"),
            current: flags.includes("%"),
            previous: flags.includes("#"),
            visible: flags.includes("a"),
            hidden: flags.includes("h"),
            modifiable: !flags.includes("-"),
            readonly: flags.includes("="),
            terminal: flags.includes("R") || flags.includes("F") || flags.includes("?"),
            modified: flags.includes("+"),
            readErrors: flags.includes("x")
          };
        })
      )
    );
    this.bufferNodeMapByFullpath = this.bufferNodes.reduce((map, node) => {
      map.set(node.fullpath, node);
      return map;
    }, /* @__PURE__ */ new Map());
    this.bufferNodeMapById = this.bufferNodes.reduce((map, node) => {
      map.set(node.bufnr, node);
      return map;
    }, /* @__PURE__ */ new Map());
    this.reloadSubject.next();
  }
};

// src/explorerManager.ts
var import_coc65 = require("coc.nvim");

// src/arg/parseArgs.ts
var import_coc27 = require("coc.nvim");

// src/presets.ts
var import_coc26 = require("coc.nvim");
async function getPresets(config4) {
  const presets = await import_coc26.workspace.nvim.eval(
    'get(g:, "coc_explorer_global_presets", {})'
  );
  return new Map(
    Object.entries({
      ...presets,
      ...config4.get("presets")
    }).map(([k2, v]) => [k2, new Map(Object.entries(v))])
  );
}

// src/arg/parseArgs.ts
var _Args = class {
  constructor(args) {
    this.args = args;
    this.optionValues = /* @__PURE__ */ new Map();
  }
  static registerOption(name, options = {}) {
    const option = {
      type: options.position === void 0 ? "string" : "positional",
      name,
      ...options
    };
    this.registeredOptions.set(name, option);
    return option;
  }
  static registerBoolOption(name, defaultValue) {
    const option = {
      type: "boolean",
      name,
      getDefault: typeof defaultValue === "boolean" ? () => defaultValue : defaultValue
    };
    this.registeredOptions.set(name, option);
    this.registeredOptions.set(`no-${name}`, option);
    return option;
  }
  static async parse(strArgs, config4) {
    var _a;
    const self2 = new _Args(strArgs);
    const args = [...strArgs];
    let position = 1;
    while (args.length > 0) {
      const arg = args.shift();
      if (arg.startsWith("--")) {
        let key, value;
        if (/^--[\w-]+=/.test(arg)) {
          [key, value] = splitCount(arg.slice(2), "=", 2);
        } else {
          key = arg.slice(2);
        }
        const option = this.registeredOptions.get(key);
        if (!option) {
          throw Error(`coc-explorer command no support option(${key})`);
        }
        if (value === void 0) {
          if (option.type === "boolean") {
            self2.optionValues.set(option.name, !key.startsWith("no-"));
            continue;
          } else {
            value = args.shift();
            if (value === void 0) {
              continue;
            }
          }
        }
        self2.optionValues.set(
          option.name,
          option.parseArg ? await option.parseArg(value) : value
        );
        continue;
      }
      const positional = Array.from(this.registeredOptions.values()).find(
        (option) => option.position === position
      );
      if (positional) {
        self2.optionValues.set(
          positional.name,
          positional.parseArg ? await positional.parseArg(arg) : arg
        );
      }
      position += 1;
    }
    const presetName = self2.optionValues.get("preset");
    if (!presetName) {
      return self2;
    }
    const presets = await getPresets(config4);
    const preset = presets.get(presetName);
    if (!preset) {
      await import_coc27.window.showWarningMessage(
        `coc-explorer preset(${presetName}) not found`
      );
      return self2;
    }
    for (const [argName, argValue] of preset) {
      if (self2.optionValues.has(argName) || argValue === void 0) {
        continue;
      }
      const option = this.registeredOptions.get(argName);
      if (option) {
        self2.optionValues.set(
          argName,
          ((_a = option.parsePreset) == null ? void 0 : _a.call(option, argValue)) ?? argValue
        );
      }
    }
    return self2;
  }
  has(option) {
    return this.optionValues.has(option.name);
  }
  async value(option) {
    var _a, _b, _c, _d;
    let result;
    if (this.optionValues.has(option.name)) {
      result = this.optionValues.get(option.name);
    } else {
      if (!_Args.registeredOptions.has(option.name)) {
        throw new Error(`Argument(${option.name}) not found`);
      } else {
        result = await ((_b = (_a = _Args.registeredOptions.get(option.name)) == null ? void 0 : _a.getDefault) == null ? void 0 : _b.call(_a));
      }
    }
    return ((_d = (_c = _Args.registeredOptions.get(option.name)) == null ? void 0 : _c.handler) == null ? void 0 : _d.call(_c, result)) ?? result;
  }
  async values(options) {
    const entries = await Promise.all(
      Object.entries(options).map(
        async ([key, option]) => [key, await this.value(option)]
      )
    );
    return entries.reduce((ret, [key, value]) => {
      ret[key] = value;
      return ret;
    }, {});
  }
};
var Args = _Args;
Args.registeredOptions = /* @__PURE__ */ new Map();

// src/arg/argOptions.ts
var argOptions = {
  rootUri: Args.registerOption("root-uri", {
    position: 1
  }),
  rootStrategies: Args.registerOption("root-strategies", {
    parseArg: (originalStrategies) => originalStrategies.split(","),
    getDefault: () => config.get("root.strategies")
  }),
  toggle: Args.registerBoolOption(
    "toggle",
    () => config.get("toggle")
  ),
  openActionStrategy: Args.registerOption(
    "open-action-strategy",
    {
      getDefault: () => config.get("openAction.strategy")
    }
  ),
  focus: Args.registerBoolOption("focus", () => config.get("focus")),
  quit: Args.registerBoolOption("quit", false),
  quitOnOpen: Args.registerBoolOption(
    "quit-on-open",
    () => config.get("quitOnOpen")
  ),
  reveal: Args.registerOption("reveal", {
    handler: (path2) => path2 ? normalizePath(path2) : path2
  }),
  revealWhenOpen: Args.registerBoolOption("reveal-when-open"),
  preset: Args.registerOption("preset"),
  sources: Args.registerOption("sources", {
    parseArg: (sources) => sources.split(",").map((source) => {
      let expand = false;
      let name;
      if (source.endsWith("+")) {
        expand = true;
        name = source.slice(0, source.length - 1);
      } else if (source.endsWith("-")) {
        expand = false;
        name = source.slice(0, source.length - 1);
      } else {
        name = source;
      }
      return {
        name,
        expand
      };
    }),
    getDefault: () => config.get("sources")
  }),
  position: Args.registerOption(
    "position",
    {
      parseArg: (s3) => {
        const [name, arg] = s3.split(":");
        return { name, arg };
      },
      parsePreset: (pos) => {
        if (Array.isArray(pos)) {
          return { name: pos[0], arg: pos[0] };
        } else if (typeof pos === "string") {
          return { name: pos };
        } else {
          return pos;
        }
      },
      getDefault: () => {
        const pos = config.get("position");
        if (Array.isArray(pos)) {
          return { name: pos[0], arg: pos[1] };
        } else {
          return { name: pos };
        }
      }
    }
  ),
  width: Args.registerOption("width", {
    parseArg: (s3) => parseInt(s3, 10),
    getDefault: () => config.get("width")
  }),
  contentWidth: Args.registerOption("content-width", {
    parseArg: (s3) => parseInt(s3, 10),
    getDefault: () => config.get("contentWidth")
  }),
  contentWidthType: Args.registerOption("content-width-type", {
    getDefault: () => config.get("contentWidthType")
  }),
  floatingPosition: Args.registerOption("floating-position", {
    parseArg: (s3) => {
      if (["left-center", "right-center", "center", "center-top"].includes(s3)) {
        return s3;
      } else {
        return s3.split(",").map((i2) => parseInt(i2, 10));
      }
    },
    getDefault: () => config.get("floating.position")
  }),
  floatingWidth: Args.registerOption("floating-width", {
    parseArg: (s3) => parseInt(s3, 10),
    getDefault: () => config.get("floating.width")
  }),
  floatingHeight: Args.registerOption("floating-height", {
    parseArg: (s3) => parseInt(s3, 10),
    getDefault: () => config.get("floating.height")
  }),
  floatingContentWidth: Args.registerOption("floating-content-width", {
    parseArg: (s3) => parseInt(s3, 10),
    getDefault: () => config.get("floating.contentWidth")
  })
};

// src/contextVariables.ts
var import_coc28 = require("coc.nvim");
var variableName = "coc_explorer_context";
var ContextVars = class {
  constructor(name) {
    this.name = name;
  }
  async set(value) {
    const obj = await this.read();
    if (value === void 0) {
      Reflect.deleteProperty(obj, this.name);
    } else {
      Reflect.set(obj, this.name, value);
    }
    await this.write(obj);
  }
  async get() {
    const obj = await this.read();
    return Reflect.get(obj, this.name);
  }
};
var BuffuerContextVars = class extends ContextVars {
  constructor(name, buffer2) {
    super(name);
    this.name = name;
    this.buffer = buffer2;
  }
  async read() {
    return await this.buffer.getVar(variableName) || {};
  }
  async write(obj) {
    await this.buffer.setVar(variableName, obj);
  }
};
var GlobalContextVars = class extends ContextVars {
  constructor() {
    super(...arguments);
    this.nvim = import_coc28.workspace.nvim;
  }
  async read() {
    return await this.nvim.getVar(variableName) ?? {};
  }
  async write(obj) {
    await this.nvim.setVar(variableName, obj);
  }
};

// src/explorer.ts
var import_coc63 = require("coc.nvim");
var import_p_filter2 = __toESM(require_p_filter());

// src/actions/actionExplorer.ts
var import_coc29 = require("coc.nvim");

// src/actions/registrar.ts
var ActionRegistrar = class {
  constructor(owner) {
    this.owner = owner;
    this.actions = /* @__PURE__ */ new Map();
  }
  addNodesAction(name, callback, description, options = {}) {
    this.actions.set(name, {
      callback,
      description,
      options: {
        select: true,
        ...options
      }
    });
  }
  addNodeAction(name, callback, description, options = {}) {
    this.actions.set(name, {
      callback: async ({ source, nodes, args, mode }) => {
        for (const node of nodes) {
          await callback.call(source, { source, node, args, mode });
        }
      },
      description,
      options
    });
  }
};

// src/actions/actionExplorer.ts
var ActionExplorer = class extends ActionRegistrar {
  constructor(owner) {
    super(owner);
    this.waitActionMutex = new import_coc29.Mutex();
    this.explorer = this.owner;
  }
  get locator() {
    return this.explorer.locator;
  }
  async doActionByKey(key, mode, count = 1) {
    for (let c2 = 0; c2 < count; c2++) {
      const selectedLineIndexes = await this.explorer.getSelectedOrCursorLineIndexes(mode);
      const lineIndexesGroups = this.explorer.lineIndexesGroupBySource(selectedLineIndexes);
      for (const { source, lineIndexes } of lineIndexesGroups) {
        const actionExp = keyMapping.getActionExp(source.sourceType, key, mode);
        if (actionExp) {
          await this.doActionExp(actionExp, {
            mode,
            lineIndexes
          });
        }
      }
    }
    await this.explorer.view.emitRequestRenderNodes();
  }
  async doActionExp(actionExp, options = {}) {
    const count = options.count ?? 1;
    const mode = options.mode ?? "n";
    const firstLineIndexes = options.lineIndexes ? new Set(options.lineIndexes) : await this.explorer.getSelectedOrCursorLineIndexes(mode);
    try {
      for (let c2 = 0; c2 < count; c2++) {
        const lineIndexes = c2 === 0 ? firstLineIndexes : await this.explorer.getSelectedOrCursorLineIndexes(mode);
        const nodesGroup = /* @__PURE__ */ new Map();
        for (const lineIndex of lineIndexes) {
          const { source } = this.explorer.findSourceByLineIndex(lineIndex);
          if (!nodesGroup.has(source)) {
            nodesGroup.set(source, []);
          }
          const relativeLineIndex = lineIndex - source.view.startLineIndex;
          nodesGroup.get(source).push(source.view.flattenedNodes[relativeLineIndex]);
        }
        for (const [source, nodes] of nodesGroup) {
          await source.action.doActionExp(actionExp, nodes, { mode });
        }
      }
    } catch (error) {
      await import_coc29.window.showErrorMessage(
        `Error when do action(${JSON.stringify(actionExp)})`
      );
      logger.error(error);
    }
  }
  async nodePrev(moveStrategy = "default", condition) {
    const gotoPrev = async (nodes, lineIndex, startLineIndex) => {
      const relativeIndex = scanIndexPrev(
        nodes,
        lineIndex,
        await enableWrapscan(),
        condition
      );
      if (relativeIndex === void 0) {
        return;
      }
      await this.locator.gotoLineIndex(startLineIndex + relativeIndex);
    };
    if (moveStrategy === "insideSource") {
      const source = await this.explorer.view.currentSource();
      if (!source) {
        return;
      }
      await gotoPrev(
        source.view.flattenedNodes,
        source.view.currentLineIndex,
        source.view.startLineIndex
      );
    } else {
      await gotoPrev(
        this.explorer.view.flattenedNodes,
        this.explorer.view.currentLineIndex,
        0
      );
    }
  }
  async nodeNext(moveStrategy = "default", condition) {
    const gotoNext = async (nodes, lineIndex, startLineIndex) => {
      const relativeIndex = scanIndexNext(
        nodes,
        lineIndex,
        await enableWrapscan(),
        condition
      );
      if (relativeIndex === void 0) {
        return;
      }
      await this.locator.gotoLineIndex(startLineIndex + relativeIndex);
    };
    if (moveStrategy === "insideSource") {
      const source = await this.explorer.view.currentSource();
      if (!source) {
        return;
      }
      await gotoNext(
        source.view.flattenedNodes,
        source.view.currentLineIndex,
        source.view.startLineIndex
      );
    } else {
      await gotoNext(
        this.explorer.view.flattenedNodes,
        this.explorer.view.currentLineIndex,
        0
      );
    }
  }
};

// src/actions/globalActions.ts
var import_coc34 = require("coc.nvim");

// src/git/manager.ts
var import_coc32 = require("coc.nvim");
var import_path12 = __toESM(require("path"));

// src/git/binder.ts
var import_coc30 = require("coc.nvim");
var import_path10 = __toESM(require("path"));

// src/git/types.ts
var GitFormat = /* @__PURE__ */ ((GitFormat2) => {
  GitFormat2["mixed"] = "*";
  GitFormat2["unmodified"] = " ";
  GitFormat2["modified"] = "M";
  GitFormat2["added"] = "A";
  GitFormat2["deleted"] = "D";
  GitFormat2["renamed"] = "R";
  GitFormat2["copied"] = "C";
  GitFormat2["unmerged"] = "U";
  GitFormat2["untracked"] = "?";
  GitFormat2["ignored"] = "!";
  return GitFormat2;
})(GitFormat || {});

// src/git/binder.ts
var statusEqual = (a3, b2) => {
  return a3.x === b2.x && a3.y === b2.y;
};
var rootStatusEqual = (a3, b2) => {
  if (a3.allStaged !== b2.allStaged) {
    return false;
  }
  return a3.formats.join(",") === b2.formats.join(",");
};
var GitBinder = class {
  constructor() {
    this.sourcesBinding = /* @__PURE__ */ new Map();
    this.prevStatusesMapInRoot = /* @__PURE__ */ new Map();
    this.prevIgnoresMapInRoot = /* @__PURE__ */ new Map();
    this.prevRootStatuses = /* @__PURE__ */ new Map();
    this.registerForSourceDisposables = [];
    this.registerDisposables = [];
    this.inited = false;
    this.reloadDebounceSubject = createSubject(
      (sub) => sub.pipe(
        buffer(sub.pipe(debounceTime(200))),
        switchMap(async (list) => {
          const sources = new Set(list.map((it) => it.sources).flat());
          const directories = new Set(list.map((it) => it.directory));
          await this.reload([...sources], [...directories]);
        })
      )
    );
  }
  get explorerManager() {
    if (!this.explorerManager_) {
      throw new Error("ExplorerSource(explorerManager) is not bound yet");
    }
    return this.explorerManager_;
  }
  get sources() {
    return Array.from(this.sourcesBinding.keys());
  }
  get refTotalCount() {
    return sum_default(Array.from(this.sourcesBinding.values()).map((b2) => b2.refCount));
  }
  init_(source) {
    if (!this.inited) {
      this.inited = true;
      this.explorerManager_ = source.explorer.explorerManager;
    }
  }
  bind(source) {
    this.init_(source);
    const binding = mapGetWithDefault(this.sourcesBinding, source, () => ({
      refCount: 0
    }));
    binding.refCount += 1;
    if (binding.refCount === 1) {
      this.registerForSourceDisposables = this.registerForSource(source);
    }
    if (this.refTotalCount === 1) {
      this.registerDisposables = this.register();
    }
    return import_coc30.Disposable.create(() => {
      binding.refCount -= 1;
      if (binding.refCount === 0) {
        (0, import_coc30.disposeAll)(this.registerForSourceDisposables);
        this.registerForSourceDisposables = [];
      }
      if (this.refTotalCount === 0) {
        (0, import_coc30.disposeAll)(this.registerDisposables);
        this.registerDisposables = [];
      }
    });
  }
  register() {
    return [
      ...["CocGitStatusChange", "FugitiveChanged"].map(
        (event) => internalEvents.on(event, async () => {
          this.reloadDebounceSubject.next({
            sources: this.sources,
            directory: import_coc30.workspace.cwd
          });
        })
      ),
      onEvent("BufWritePost", async (bufnr) => {
        var _a;
        const fullpath = (_a = this.explorerManager.bufManager.getBufferNode(bufnr)) == null ? void 0 : _a.fullpath;
        if (fullpath) {
          const dirname = import_path10.default.dirname(fullpath);
          this.reloadDebounceSubject.next({
            sources: this.sources,
            directory: dirname
          });
        }
      })
    ];
  }
  registerForSource(source) {
    return [
      source.events.on("loaded", async (node) => {
        const directory = "isRoot" in node ? source.root : node.expandable ? node.fullpath : node.fullpath && import_path10.default.dirname(node.fullpath);
        if (directory) {
          this.reloadDebounceSubject.next({ sources: [source], directory });
        }
      })
    ];
  }
  async reload(sources, directories) {
    const roots = await gitManager.getGitRoots(directories);
    if (!roots.length) {
      return;
    }
    const updatePaths = /* @__PURE__ */ new Set();
    const updateDirs = /* @__PURE__ */ new Set();
    for (const root2 of roots) {
      await gitManager.reload(root2);
      const statuses = gitManager.getMixedStatusesByRoot(root2);
      const ignores = gitManager.getIgnoreByRoot(root2);
      const rootStatus = gitManager.getRootStatus(root2) || {
        allStaged: false,
        formats: []
      };
      let prevStatusMap = this.prevStatusesMapInRoot.get(root2);
      if (!prevStatusMap) {
        prevStatusMap = /* @__PURE__ */ new Map();
        this.prevStatusesMapInRoot.set(root2, prevStatusMap);
      }
      let prevIgnoreMap = this.prevIgnoresMapInRoot.get(root2);
      if (!prevIgnoreMap) {
        prevIgnoreMap = /* @__PURE__ */ new Map();
        this.prevIgnoresMapInRoot.set(root2, prevIgnoreMap);
      }
      let prevRootStatus = this.prevRootStatuses.get(root2);
      if (!prevRootStatus) {
        prevRootStatus = {
          allStaged: false,
          formats: []
        };
        this.prevRootStatuses.set(root2, prevRootStatus);
      }
      const addGitIgnore = (fullpath, gitIgnore) => {
        if (gitIgnore === 0 /* directory */) {
          updateDirs.add(fullpath.replace(/[\\/]$/, ""));
        } else {
          updatePaths.add(fullpath);
        }
      };
      for (const [fullpath, status] of statuses) {
        const prevStatus = prevStatusMap.get(fullpath);
        if (prevStatus) {
          if (statusEqual(prevStatus, status)) {
            prevStatusMap.delete(fullpath);
            continue;
          }
        }
        updatePaths.add(fullpath);
      }
      for (const fullpath of prevStatusMap.keys()) {
        updatePaths.add(fullpath);
      }
      for (const [fullpath, gitIgnore] of ignores) {
        const prevIgnore = prevIgnoreMap.get(fullpath);
        if (prevIgnore === gitIgnore) {
          prevIgnoreMap.delete(fullpath);
          continue;
        }
        addGitIgnore(fullpath, gitIgnore);
      }
      for (const [fullpath, gitIgnore] of prevIgnoreMap) {
        addGitIgnore(fullpath, gitIgnore);
      }
      if (rootStatus && !rootStatusEqual(prevRootStatus, rootStatus)) {
        updatePaths.add(root2);
      }
      this.prevStatusesMapInRoot.set(root2, statuses);
      this.prevIgnoresMapInRoot.set(root2, ignores);
      this.prevRootStatuses.set(root2, rootStatus);
    }
    for (const source of sources) {
      await source.view.renderPaths([
        ...updatePaths,
        {
          paths: updateDirs,
          withChildren: true
        }
      ]);
    }
  }
};

// src/git/command.ts
var import_coc31 = require("coc.nvim");
var import_command_exists = __toESM(require_command_exists2());
var import_path11 = __toESM(require("path"));
var _GitCommand = class {
  static get binPath() {
    return config.get("git.command");
  }
  static async waitLoaded() {
    if (this.loaded) {
      return;
    }
    return new Promise((resolve6) => {
      this.onLoaded(resolve6);
    });
  }
  static async preload() {
    try {
      await (0, import_command_exists.default)(this.binPath);
      this.available = true;
    } catch (e2) {
      this.available = false;
    } finally {
      this.loaded = true;
      this.loadedEmitter.fire();
    }
  }
  get binPath() {
    return _GitCommand.binPath;
  }
  async available() {
    await _GitCommand.waitLoaded();
    return _GitCommand.available;
  }
  spawn(args, { cwd } = {}) {
    return execCmd(this.binPath, args, {
      cwd
    });
  }
  async getRoot(filepath) {
    const stat3 = await fsStat(filepath).catch(() => void 0);
    const cwd = (stat3 == null ? void 0 : stat3.isDirectory()) ? filepath : import_path11.default.dirname(filepath);
    const output = await this.spawn(["rev-parse", "--show-toplevel"], {
      cwd
    });
    return normalizePath(output.trim());
  }
  parseStatusFormat(format2) {
    return Object.values(GitFormat).find((it) => it === format2) ?? " " /* unmodified */;
  }
  parsePath(str, hasArrow) {
    let index = 0;
    let path2 = "";
    let inPath = false;
    let inQuote = false;
    let inEscape = false;
    const paths = [];
    while (index < str.length) {
      const ch = str[index];
      if (!inPath && !inQuote) {
        if (ch === '"') {
          inQuote = true;
          index += 1;
        }
        path2 = "";
        inPath = true;
        continue;
      } else {
        if (inQuote) {
          if (inEscape) {
            path2 += ch === "t" ? "	" : ch;
            inEscape = false;
          } else {
            if (ch === '"') {
              paths.push(path2);
              inQuote = false;
              inPath = false;
            } else if (ch === "\\") {
              inEscape = true;
            } else {
              path2 += ch;
            }
          }
        } else {
          if (ch === " ") {
            if (hasArrow && str.slice(index, index + 4) === " -> ") {
              if (path2.length) {
                paths.push(path2);
              }
              index += 3;
              inPath = false;
            } else {
              path2 += ch;
            }
          } else {
            path2 += ch;
          }
        }
      }
      index += 1;
    }
    if (inPath) {
      paths.push(path2);
      inPath = false;
    }
    return paths;
  }
  parseStatusLine(gitRoot, line) {
    const xFormat = this.parseStatusFormat(line[0]);
    const yFormat = this.parseStatusFormat(line[1]);
    const rawPath = line.slice(3);
    const hasArrow = ["R" /* renamed */, "C" /* copied */].includes(xFormat) || ["R" /* renamed */, "C" /* copied */].includes(yFormat);
    const paths = this.parsePath(rawPath, hasArrow);
    return [
      xFormat,
      yFormat,
      ...paths.map((p) => import_path11.default.join(gitRoot, p))
    ];
  }
  async status(root2, {
    showUntrackedFiles = "system",
    showIgnored = true
  } = {}) {
    const gitStatus = /* @__PURE__ */ new Map();
    const args = ["status", "--porcelain"];
    if (showUntrackedFiles === true) {
      args.push("-u");
    } else if (showUntrackedFiles === false) {
      args.push("-uno");
    }
    if (showIgnored) {
      args.push("--ignored=matching");
    }
    const output = await this.spawn(args, { cwd: root2 });
    const lines = output.split("\n");
    lines.forEach((line) => {
      if (!line) {
        return;
      }
      const [x_, y_, leftpath, rightpath] = this.parseStatusLine(root2, line);
      const x2 = x_ === "?" /* untracked */ ? " " /* unmodified */ : x_;
      const y3 = y_ === "!" /* ignored */ ? " " /* unmodified */ : y_;
      const changedList = [
        "M" /* modified */,
        "A" /* added */,
        "D" /* deleted */,
        "R" /* renamed */,
        "C" /* copied */
      ];
      const added = x2 === "A" /* added */ || y3 === "A" /* added */;
      const modified = x2 === "M" /* modified */ || y3 === "M" /* modified */;
      const deleted = x2 === "D" /* deleted */ || y3 === "D" /* deleted */;
      const renamed = x2 === "R" /* renamed */ || y3 === "R" /* renamed */;
      const copied = x2 === "C" /* copied */ || y3 === "C" /* copied */;
      const staged = changedList.includes(x2) && y3 === " " /* unmodified */;
      const unmerged = x2 === "D" /* deleted */ && y3 === "D" /* deleted */ || x2 === "A" /* added */ && y3 === "A" /* added */ || x2 === "U" /* unmerged */ || y3 === "U" /* unmerged */;
      const ignored = x2 === "!" /* ignored */;
      const untracked = y3 === "?" /* untracked */;
      const fullpath = rightpath ? rightpath : leftpath;
      gitStatus.set(fullpath, {
        fullpath,
        x: x2,
        y: y3,
        added,
        modified,
        deleted,
        renamed,
        copied,
        staged,
        unmerged,
        untracked,
        ignored
      });
    });
    return gitStatus;
  }
  async stage(paths) {
    if (paths.length) {
      const root2 = await this.getRoot(paths[0]);
      await this.spawn(["add", ...paths], { cwd: root2 });
    }
  }
  async unstage(paths) {
    if (paths.length) {
      const root2 = await this.getRoot(paths[0]);
      await this.spawn(["reset", ...paths], { cwd: root2 });
    }
  }
  async fetch(root2) {
    await this.spawn(["fetch"], { cwd: root2 });
  }
  async hasPull(root2) {
    const count = await this.spawn(["rev-list", "--count", "@..@{upstream}"], {
      cwd: root2
    });
    return parseInt(count);
  }
  async hasPush(root2) {
    const count = await this.spawn(["rev-list", "--count", "@{upstream}..@"], {
      cwd: root2
    });
    return parseInt(count);
  }
  async hasStashed(root2) {
    const list = await this.spawn(["stash", "list"], {
      cwd: root2
    });
    return list.split(/\n/g).length - 1;
  }
  async checkIgnore(paths) {
    if (!paths.length) {
      return [];
    }
    const root2 = await this.getRoot(paths[0]);
    const output = await this.spawn(["check-ignore", ...paths], { cwd: root2 });
    return output.split(/\n/g);
  }
};
var GitCommand = _GitCommand;
GitCommand.available = false;
GitCommand.loadedEmitter = new import_coc31.Emitter();
GitCommand.loaded = false;
GitCommand.onLoaded = _GitCommand.loadedEmitter.event;

// src/git/manager.ts
var GitManager = class {
  constructor() {
    this.cmd = new GitCommand();
    this.rootCache = /* @__PURE__ */ new Map();
    this.mixedStatusMapCacheInRoot = /* @__PURE__ */ new Map();
    this.ignoreMapCacheInRoot = /* @__PURE__ */ new Map();
    this.rootStatusCache = /* @__PURE__ */ new Map();
    this.binder = new GitBinder();
    this.showIgnored = config.get("git.showIgnored");
    this.showUntrackedFiles = config.get(
      "file.git.showUntrackedFiles"
    );
  }
  async getGitRoots(directories) {
    const directorySet = [...new Set(directories)];
    const roots = await Promise.all(
      directorySet.map((directory) => this.getGitRoot(directory))
    );
    return compactI2(roots);
  }
  async getGitRoot(directory) {
    const root2 = this.rootCache.get(directory);
    if (root2)
      return root2;
    const parts = directory.split(import_path12.default.sep);
    const idx = parts.indexOf(".git");
    if (idx !== -1) {
      const root3 = parts.slice(0, idx).join(import_path12.default.sep);
      this.rootCache.set(directory, root3);
    } else {
      try {
        const gitRoot = await this.cmd.getRoot(directory);
        if (import_path12.default.isAbsolute(gitRoot)) {
          this.rootCache.set(directory, gitRoot);
        } else {
          import_path12.default.join(directory, gitRoot);
        }
      } catch (error) {
        logger.error(error);
        return;
      }
    }
    return this.rootCache.get(directory);
  }
  async reload(directory, options = {}) {
    const root2 = await this.getGitRoot(directory);
    if (root2) {
      const statusOptions = {
        showIgnored: options.showIgnored ?? this.showIgnored,
        showUntrackedFiles: options.showUntrackedFiles ?? this.showUntrackedFiles
      };
      const statusRecord = await this.cmd.status(root2, statusOptions);
      const statusArray = [...statusRecord.values()];
      const rootStatus = {
        allStaged: true,
        formats: []
      };
      this.rootStatusCache.set(root2, rootStatus);
      if (await this.cmd.hasStashed(root2)) {
        rootStatus.formats.push(5 /* stashed */);
      }
      if (await this.cmd.hasPull(root2)) {
        rootStatus.formats.push(2 /* behind */);
      }
      if (await this.cmd.hasPush(root2)) {
        rootStatus.formats.push(1 /* ahead */);
      }
      if (statusArray.some((s3) => s3.y === "U" /* unmerged */)) {
        rootStatus.formats.push(3 /* conflicted */);
      }
      if (statusArray.some((s3) => s3.y === "?" /* untracked */)) {
        rootStatus.formats.push(4 /* untracked */);
      }
      if (statusArray.some(
        (s3) => s3.x === "M" /* modified */ || s3.y === "M" /* modified */
      )) {
        rootStatus.formats.push(6 /* modified */);
      }
      if (statusArray.some((s3) => s3.x === "A" /* added */)) {
        rootStatus.formats.push(7 /* added */);
      }
      if (statusArray.some((s3) => s3.x === "R" /* renamed */)) {
        rootStatus.formats.push(8 /* renamed */);
      }
      if (statusArray.some(
        (s3) => s3.x === "D" /* deleted */ || s3.y === "D" /* deleted */
      )) {
        rootStatus.formats.push(9 /* deleted */);
      }
      if (statusArray.some((s3) => s3.y !== " " /* unmodified */)) {
        rootStatus.allStaged = false;
      }
      const mixedStatusMap = /* @__PURE__ */ new Map();
      const ignoreMap = /* @__PURE__ */ new Map();
      this.mixedStatusMapCacheInRoot.set(root2, mixedStatusMap);
      this.ignoreMapCacheInRoot.set(root2, ignoreMap);
      statusRecord.forEach((status, fullpath) => {
        if (status.x === "!" /* ignored */) {
          if (["/", "\\"].includes(fullpath[fullpath.length - 1])) {
            ignoreMap.set(fullpath, 0 /* directory */);
          } else {
            ignoreMap.set(fullpath, 1 /* file */);
          }
          return;
        }
        const relativePath = import_path12.default.relative(root2, fullpath);
        const parts = relativePath.split(import_path12.default.sep);
        for (let i2 = 1; i2 <= parts.length; i2++) {
          const frontalPath = import_path12.default.join(
            root2,
            import_path12.default.join(...parts.slice(0, i2))
          );
          const cache = mixedStatusMap.get(frontalPath);
          if (cache) {
            if (cache.x !== "*" /* mixed */) {
              if (cache.x !== status.x) {
                if (cache.x === " " /* unmodified */) {
                  cache.x = status.x;
                } else if (status.x !== " " /* unmodified */) {
                  cache.x = "*" /* mixed */;
                }
              }
            }
            if (cache.y !== "*" /* mixed */) {
              if (cache.y !== status.y) {
                if (cache.y === " " /* unmodified */) {
                  cache.y = status.y;
                } else if (status.y !== " " /* unmodified */) {
                  cache.y = "*" /* mixed */;
                }
              }
            }
          } else {
            mixedStatusMap.set(frontalPath, {
              x: status.x,
              y: status.y
            });
          }
        }
      });
    }
    return root2;
  }
  bindColumn(source) {
    const enabled = config.get("git.enable");
    if (!enabled) {
      return import_coc32.Disposable.create(() => {
      });
    }
    return this.binder.bind(source);
  }
  getMixedStatusesByRoot(rootPath) {
    return this.mixedStatusMapCacheInRoot.get(rootPath) || /* @__PURE__ */ new Map();
  }
  getIgnoreByRoot(rootPath) {
    return this.ignoreMapCacheInRoot.get(rootPath) || /* @__PURE__ */ new Map();
  }
  getMixedStatus(fullpath, isDirectory) {
    const statusPair = [...this.mixedStatusMapCacheInRoot.entries()].sort((a3, b2) => b2[0].localeCompare(a3[0])).find(([rootPath]) => fullpath.startsWith(rootPath));
    if (statusPair) {
      const pathStatus = statusPair[1].get(fullpath);
      if (pathStatus) {
        return pathStatus;
      }
    }
    const ignorePair = [...this.ignoreMapCacheInRoot.entries()].sort((a3, b2) => b2[0].localeCompare(a3[0])).find(([rootPath]) => fullpath.startsWith(rootPath));
    if (ignorePair) {
      const gitIgnores = ignorePair[1];
      const isIgnore = [...gitIgnores.entries()].some(
        ([ignorePath, gitIgnore]) => {
          if (gitIgnore === 1 /* file */) {
            return ignorePath === fullpath;
          } else {
            const directoryPath = isDirectory ? fullpath + import_path12.default.sep : fullpath;
            return directoryPath.startsWith(ignorePath);
          }
        }
      );
      if (isIgnore) {
        return { x: "!" /* ignored */, y: " " /* unmodified */ };
      }
    }
  }
  getRootStatus(root2) {
    return this.rootStatusCache.get(root2);
  }
};
var gitManager = new GitManager();

// src/types/index.ts
var textobjTargetList = ["line", "indent"];
var textobjTypeList = ["i", "a"];
var moveStrategyList = ["default", "insideSource"];
var revealStrategyList = [
  "select",
  "previousBuffer",
  "previousWindow",
  "sourceWindow",
  "path"
];
var openStrategyList = [
  "select",
  "split",
  "split.plain",
  "split.intelligent",
  "vsplit",
  "vsplit.plain",
  "vsplit.intelligent",
  "tab",
  "previousBuffer",
  "previousWindow",
  "sourceWindow"
];
var copyOrCutFileTypeList = ["toggle", "append", "replace"];
var previewOnHoverActionList = [
  "toggle",
  "enable",
  "disable"
];
var previewStrategyList = [
  "labeling",
  "content"
];
var rootStrategyList = [
  "keep",
  "workspace",
  "cwd",
  "sourceBuffer",
  "reveal"
];
var searchOptionList = ["recursive", "noIgnore", "strict"];
var expandOptionList = [
  "recursive",
  "compact",
  "uncompact",
  "recursiveSingle"
];
var collapseOptionList = ["recursive", "all"];

// src/actions/openAction.ts
var import_coc33 = require("coc.nvim");
var OpenActionContext = class {
  constructor(explorer, source, cursorPosition, originalOpenByWinnr, getFullpath, quitOnOpenNotifier, explorerWinid) {
    this.explorer = explorer;
    this.source = source;
    this.cursorPosition = cursorPosition;
    this.getFullpath = getFullpath;
    this.quitOnOpenNotifier = quitOnOpenNotifier;
    this.explorerWinid = explorerWinid;
    this.nvim = import_coc33.workspace.nvim;
    this.explorerPosition = explorer.argValues.position;
    this.openByWinnr = originalOpenByWinnr ?? (async (winnr) => {
      const openNotifier = await this.openFilepathNotifier("edit");
      await this.openWrap(() => {
        this.nvim.command(`${winnr}wincmd w`, true);
        openNotifier.notify();
        if (import_coc33.workspace.isVim) {
          this.nvim.command("redraw", true);
        }
      });
    });
  }
  jumpToNotify() {
    if (this.cursorPosition === "keep") {
      if (!this.explorerWinid) {
        return;
      }
      this.nvim.call("win_gotoid", [this.explorerWinid], true);
    } else if (this.cursorPosition) {
      this.nvim.call(
        "cursor",
        [
          this.cursorPosition.lineIndex + 1,
          (this.cursorPosition.columnIndex ?? 0) + 1
        ],
        true
      );
    }
  }
  async openWrap(callback, options) {
    const earlyQuit = (options == null ? void 0 : options.earlyQuit) ?? false;
    const notifiers = [];
    if (earlyQuit)
      await this.explorer.tryQuitOnOpen();
    else
      notifiers.push(await this.quitOnOpenNotifier());
    const lastWinnr = await this.nvim.call("winnr", ["$"]);
    const resizeIt = lastWinnr === 1 && this.explorerPosition.name !== "floating";
    this.nvim.pauseNotification();
    callback();
    Notifier.notifyAll(notifiers);
    this.jumpToNotify();
    if (resizeIt)
      this.explorer.resizeNotifier().notify();
    await this.nvim.resumeNotification();
  }
  async openFilepathNotifier(cmd) {
    const fullpath = await this.getFullpath();
    const isRel = this.explorer.config.get("openAction.relativePath");
    return Notifier.create(() => {
      this.nvim.call(
        "coc_explorer#util#open_file",
        [cmd, fullpath, isRel],
        true
      );
    });
  }
  async tryResize() {
    await this.explorer.resize();
  }
};
var OpenActions = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  async select() {
    const ctx = this.ctx;
    if (ctx.explorerPosition.name === "floating") {
      await ctx.explorer.hide();
    }
    await selectWindowsUI(ctx.explorer.config, ctx.source.sourceType, {
      onSelect: async (winnr) => {
        await ctx.openByWinnr(winnr);
      },
      noChoice: async () => {
        await this.vsplit();
      },
      onCancel: async () => {
        if (ctx.explorerPosition.name === "floating") {
          await ctx.explorer.show();
        }
      }
    });
  }
  async splitIntelligent(command, fallbackStrategy) {
    const ctx = this.ctx;
    const explWinid = await ctx.explorer.winid;
    if (!explWinid) {
      return;
    }
    const winFinder = await WinLayoutFinder.create();
    const node = winFinder.findWinid(explWinid);
    if (node) {
      if (node.parent && node.parent.group.type === "row") {
        const target = node.parent.group.children[node.parent.indexInParent + (ctx.explorerPosition.name === "left" ? 1 : -1)];
        if (target) {
          const targetWinid = WinLayoutFinder.getFirstLeafWinid(target);
          const openNotifier = await ctx.openFilepathNotifier(command);
          await ctx.openWrap(() => {
            ctx.nvim.call("win_gotoid", [targetWinid], true);
            openNotifier.notify();
          });
        }
      } else {
        await this["vsplit.plain"]();
      }
    } else {
      await this[fallbackStrategy]();
    }
  }
  async split() {
    await this["split.intelligent"]();
  }
  async "split.plain"() {
    const ctx = this.ctx;
    const openNotifier = await ctx.openFilepathNotifier("split");
    await ctx.openWrap(() => {
      openNotifier.notify();
    });
  }
  async "split.intelligent"() {
    const ctx = this.ctx;
    if (ctx.explorerPosition.name === "floating") {
      await this["split.plain"]();
      return;
    } else if (ctx.explorerPosition.name === "tab") {
      await this.vsplit();
      return;
    }
    await this.splitIntelligent("split", "split.plain");
  }
  async vsplit() {
    await this["vsplit.intelligent"]();
  }
  async "vsplit.plain"() {
    const ctx = this.ctx;
    const openNotifier = await ctx.openFilepathNotifier("vsplit");
    await ctx.openWrap(() => {
      openNotifier.notify();
    });
  }
  async "vsplit.intelligent"() {
    const ctx = this.ctx;
    if (ctx.explorerPosition.name === "floating") {
      await this["vsplit.plain"]();
      return;
    } else if (ctx.explorerPosition.name === "tab") {
      await this["vsplit.plain"]();
      return;
    }
    await this.splitIntelligent("vsplit", "vsplit.plain");
  }
  async tab() {
    const ctx = this.ctx;
    const openNotifier = await ctx.openFilepathNotifier("tabedit");
    await ctx.openWrap(
      () => {
        openNotifier.notify();
      },
      { earlyQuit: true }
    );
  }
  async previousBuffer() {
    const ctx = this.ctx;
    const prevWinnr = await ctx.explorer.explorerManager.prevWinnrByPrevBufnr();
    if (prevWinnr) {
      await ctx.openByWinnr(prevWinnr);
    } else {
      await this.vsplit();
    }
  }
  async previousWindow() {
    const ctx = this.ctx;
    const prevWinnr = await ctx.explorer.explorerManager.prevWinnrByPrevWindowID();
    if (prevWinnr) {
      await ctx.openByWinnr(prevWinnr);
    } else {
      await this.vsplit();
    }
  }
  async sourceWindow() {
    const ctx = this.ctx;
    const srcWinnr = await ctx.explorer.sourceWinnr();
    if (srcWinnr) {
      await ctx.openByWinnr(srcWinnr);
    } else {
      await this.vsplit();
    }
  }
};
async function openAction(explorer, source, node, getFullpath, {
  openByWinnr,
  openStrategy,
  cursorPosition
}) {
  if (node.expandable) {
    return;
  }
  let explorerWinid;
  let quitOnOpenNotifier;
  if (cursorPosition === "keep") {
    explorerWinid = await explorer.winid;
    quitOnOpenNotifier = () => Notifier.noop();
  } else {
    quitOnOpenNotifier = () => explorer.tryQuitOnOpenNotifier();
  }
  const context2 = new OpenActionContext(
    explorer,
    source,
    cursorPosition,
    openByWinnr,
    getFullpath,
    quitOnOpenNotifier,
    explorerWinid
  );
  const actions = new OpenActions(context2);
  if (!openStrategy) {
    openStrategy = await explorer.args.value(argOptions.openActionStrategy);
  }
  if (!hasOwnProperty14(actions, openStrategy)) {
    new Error(`openStrategy(${openStrategy}) is not supported`);
  }
  await actions[openStrategy]();
}

// src/actions/globalActions.ts
function loadGlobalActions(action) {
  const explorer = action.owner;
  const locator = explorer.locator;
  const { nvim } = import_coc34.workspace;
  const openActionArgs = [
    {
      name: "open strategy",
      description: openStrategyList.join(" | ")
    },
    {
      name: "open with position",
      description: "line-number,column-number | keep"
    }
  ];
  const openActionMenu = {
    select: "use select window UI",
    "select:keep": "use select window UI, but keep cursor in explorer",
    "split.plain": "use vim split",
    "split.intelligent": "use split like vscode",
    "vsplit.plain": "use vim vsplit",
    "vsplit.intelligent": "use vim vsplit, but keep the explorer in the original position",
    tab: "vim tab",
    previousBuffer: "use last used buffer",
    previousWindow: "use last used window",
    sourceWindow: "use the window where explorer opened"
  };
  action.addNodeAction(
    "open",
    async ({ source, node, args, mode }) => {
      if (node.expandable) {
        const directoryActionExp = explorer.config.get(
          "openAction.for.directory"
        );
        if (directoryActionExp) {
          await explorer.action.doActionExp(
            parseOriginalActionExp(directoryActionExp),
            { mode, lineIndexes: [explorer.view.flattenedNodes.indexOf(node)] }
          );
        }
        return;
      }
      const [openStrategy, positionRaw] = args;
      let cursorPosition;
      if (positionRaw === "keep") {
        cursorPosition = positionRaw;
      } else if (positionRaw) {
        const [line, column] = positionRaw.split(",").map((n) => parseInt(n, 10));
        cursorPosition = {
          lineIndex: line
        };
        if (column) {
          cursorPosition.columnIndex = column;
        }
      } else if (node.location) {
        const { range } = node.location;
        cursorPosition = { lineIndex: range.start.line - 1 };
      }
      await openAction(explorer, source, node, () => node.fullpath, {
        openStrategy,
        cursorPosition
      });
    },
    "open file or directory",
    {
      select: true,
      args: openActionArgs,
      menus: openActionMenu
    }
  );
  action.addNodeAction(
    "expand",
    async ({ source, node, args }) => {
      if (node.expandable) {
        const options = (args[0] ?? "").split("|");
        const recursive = options.includes("recursive") || void 0;
        const compact = options.includes("compact") || void 0;
        const uncompact = options.includes("uncompact") || void 0;
        const recursiveSingle = options.includes("recursiveSingle") || void 0;
        await source.view.expand(node, {
          recursive,
          compact,
          uncompact,
          recursiveSingle
        });
      }
    },
    "expand node",
    {
      select: true,
      args: [
        {
          name: "expand options",
          description: expandOptionList.join(" | ")
        }
      ],
      menus: {
        recursive: "recursively",
        compact: "single child folders will be compressed in a combined node",
        uncompact: "reset the combined node",
        "compact|uncompact": "compact or uncompact",
        recursiveSingle: "expand single child folder recursively"
      }
    }
  );
  action.addNodeAction(
    "collapse",
    async ({ source, node, args }) => {
      const options = (args[0] ?? "").split("|");
      const all = options.includes("all");
      const recursive = options.includes("recursive");
      if (all && source.view.rootNode.children) {
        for (const subNode of source.view.rootNode.children) {
          if (subNode.expandable && source.view.isExpanded(subNode)) {
            await source.action.doAction(
              "collapse",
              subNode,
              options.filter((op) => op !== "all")
            );
          }
        }
      } else {
        if (node.expandable && source.view.isExpanded(node)) {
          await source.view.collapse(node, { recursive });
        } else if (node.parent) {
          await source.view.collapse(node.parent, { recursive });
        }
      }
    },
    "collapse node",
    {
      select: true,
      args: [
        {
          name: "collapse options",
          description: collapseOptionList.join(" | ")
        }
      ],
      menus: {
        recursive: "recursively",
        all: "for all nodes"
      }
    }
  );
  action.addNodesAction(
    "gitStage",
    async ({ nodes, source }) => {
      const fullpaths = compactI(nodes.map((node) => node.fullpath));
      if (!fullpaths.length) {
        return;
      }
      await gitManager.cmd.stage(fullpaths);
      const roots = await gitManager.getGitRoots(fullpaths);
      for (const root2 of roots) {
        await gitManager.reload(root2);
      }
      source.view.requestRenderNodes([
        { nodes, withParents: true, withChildren: true }
      ]);
    },
    "add file to git index"
  );
  action.addNodesAction(
    "gitUnstage",
    async ({ nodes, source }) => {
      const fullpaths = compactI(nodes.map((node) => node.fullpath));
      if (!fullpaths.length) {
        return;
      }
      await gitManager.cmd.unstage(fullpaths);
      const roots = await gitManager.getGitRoots(fullpaths);
      for (const root2 of roots) {
        await gitManager.reload(root2);
      }
      source.view.requestRenderNodes([
        { nodes, withParents: true, withChildren: true }
      ]);
    },
    "reset file from git index"
  );
  const moveActionArgs = [
    {
      name: "move action options",
      description: moveStrategyList.join(" | ")
    }
  ];
  const moveActionMenu = {
    insideSource: "move inside current source"
  };
  action.addNodeAction(
    "nodePrev",
    async ({ args }) => {
      const moveStrategy = args[0];
      if (moveStrategy === "insideSource") {
        const source = await explorer.view.currentSource();
        if (!source) {
          return;
        }
        await source.locator.gotoLineIndex(source.view.currentLineIndex - 1);
      } else {
        const line = explorer.view.currentLineIndex;
        await locator.gotoLineIndex(line - 1);
      }
    },
    "previous node",
    {
      args: moveActionArgs,
      menus: moveActionMenu
    }
  );
  action.addNodeAction(
    "nodeNext",
    async ({ args }) => {
      const moveStrategy = args[0];
      if (moveStrategy === "insideSource") {
        const source = await explorer.view.currentSource();
        if (!source) {
          return;
        }
        await source.locator.gotoLineIndex(source.view.currentLineIndex + 1);
      } else {
        const line = explorer.view.currentLineIndex;
        await locator.gotoLineIndex(line + 1);
      }
    },
    "next node",
    {
      args: moveActionArgs,
      menus: moveActionMenu
    }
  );
  action.addNodeAction(
    "expandablePrev",
    async ({ args }) => {
      await explorer.action.nodePrev(
        args[0],
        (node) => !!node.expandable
      );
    },
    "previous expandable node",
    {
      args: moveActionArgs,
      menus: moveActionMenu
    }
  );
  action.addNodeAction(
    "expandableNext",
    async ({ args }) => {
      await action.nodeNext(
        args[0],
        (node) => !!node.expandable
      );
    },
    "next expandable node",
    {
      args: moveActionArgs,
      menus: moveActionMenu
    }
  );
  action.addNodeAction(
    "indentPrev",
    async ({ node, args }) => {
      const level = node.level ?? 0;
      await action.nodePrev(
        args[0],
        (node2) => node2.level !== level
      );
    },
    "previous indent node",
    {
      args: moveActionArgs,
      menus: moveActionMenu
    }
  );
  action.addNodeAction(
    "indentNext",
    async ({ node, args }) => {
      const level = node.level ?? 0;
      await action.nodeNext(
        args[0],
        (node2) => node2.level !== level
      );
    },
    "next indent node",
    {
      args: moveActionArgs,
      menus: moveActionMenu
    }
  );
  action.addNodeAction(
    "gotoSource",
    async ({ args }) => {
      const source = explorer.sources.find((s3) => s3.sourceType === args[0]);
      if (source) {
        await source.locator.gotoLineIndex(0);
      }
    },
    "go to source",
    {
      args: [
        {
          name: "source name",
          description: "buffer | file | ..."
        }
      ]
    }
  );
  action.addNodeAction(
    "sourceNext",
    async () => {
      const nextSource = explorer.sources[await explorer.view.currentSourceIndex() + 1];
      if (nextSource) {
        await nextSource.locator.gotoLineIndex(0);
      } else if (await enableWrapscan()) {
        await explorer.sources[0].locator.gotoLineIndex(0);
      }
    },
    "go to next source"
  );
  action.addNodeAction(
    "sourcePrev",
    async () => {
      const prevSource = explorer.sources[await explorer.view.currentSourceIndex() - 1];
      if (prevSource) {
        await prevSource.locator.gotoLineIndex(0);
      } else if (await enableWrapscan()) {
        await explorer.sources[explorer.sources.length - 1].locator.gotoLineIndex(0);
      }
    },
    "go to previous source"
  );
  action.addNodeAction(
    "modifiedPrev",
    async () => {
      await locator.gotoPrevMark("modified");
    },
    "go to previous modified"
  );
  action.addNodeAction(
    "modifiedNext",
    async () => {
      await locator.gotoNextMark("modified");
    },
    "go to next modified"
  );
  action.addNodeAction(
    "diagnosticPrev",
    async () => {
      await locator.gotoPrevMark("diagnosticError", "diagnosticWarning");
    },
    "go to previous diagnostic"
  );
  action.addNodeAction(
    "diagnosticNext",
    async () => {
      await locator.gotoNextMark("diagnosticError", "diagnosticWarning");
    },
    "go to next diagnostic"
  );
  action.addNodeAction(
    "gitPrev",
    async () => {
      await locator.gotoPrevMark("git");
    },
    "go to previous git changed"
  );
  action.addNodeAction(
    "gitNext",
    async () => {
      await locator.gotoNextMark("git");
    },
    "go to next git changed"
  );
  const markOptions = {
    args: [
      {
        name: "mark name",
        description: "string"
      }
    ],
    menus: {
      modified: "modified",
      diagnosticWarning: "diagnosticWarning",
      diagnosticError: "diagnosticError",
      git: "git"
    }
  };
  action.addNodeAction(
    "markPrev",
    async ({ args }) => {
      await locator.gotoPrevMark(...args);
    },
    "go to previous mark",
    markOptions
  );
  action.addNodeAction(
    "markNext",
    async ({ args }) => {
      await locator.gotoNextMark(...args);
    },
    "go to next mark",
    markOptions
  );
  action.addNodeAction(
    "preview",
    async ({ source, node, args }) => {
      const previewStrategy = args[0];
      if (!previewStrategy) {
        return;
      }
      const nodeIndex = source.view.getLineByNode(node);
      if (nodeIndex === void 0) {
        return;
      }
      await explorer.floatingPreview.previewNode(
        previewStrategy,
        source,
        node,
        nodeIndex
      );
    },
    "preview",
    {
      args: [
        {
          name: "preview strategy",
          description: previewStrategyList.join(" | ")
        }
      ],
      menus: {
        labeling: "preview for node labeling",
        content: "preview for node content"
      }
    }
  );
  action.addNodeAction(
    "previewOnHover",
    async ({ args }) => {
      const previewOnHoverAction = args[0];
      if (!previewOnHoverAction) {
        return;
      }
      const previewStrategy = args[1];
      if (!previewStrategy) {
        if (previewOnHoverAction === "disable") {
          explorer.floatingPreview.unregisterOnHover();
        }
        return;
      }
      const delay = args[2] ? parseInt(args[2]) : 0;
      if (previewOnHoverAction === "toggle") {
        explorer.floatingPreview.toggleOnHover(previewStrategy, delay);
      } else if (previewOnHoverAction === "enable") {
        explorer.floatingPreview.registerOnHover(previewStrategy, delay);
      } else {
        explorer.floatingPreview.unregisterOnHover();
      }
    },
    "preview on hover",
    {
      args: [
        {
          name: "sub action",
          description: previewOnHoverActionList.join(" | ")
        },
        {
          name: "preview strategy",
          description: previewStrategyList.join(" | ")
        },
        {
          name: "delay",
          description: "delay millisecond"
        }
      ],
      menus: {
        "toggle:labeling": "toggle labeling",
        "toggle:labeling:200": "toggle labeling with debounce",
        "toggle:content": "toggle content",
        "enable:content": "enable with content",
        "enable:labeling": "enable with labeling"
      }
    }
  );
  action.addNodeAction(
    "textobj",
    async ({ node: currentNode, args }) => {
      const currentIndex = explorer.view.currentLineIndex;
      const textobjTarget = args[0] ?? "line";
      if (textobjTarget === "line") {
        await nvim.command("normal! V");
      } else if (textobjTarget === "indent") {
        const flattenedNodes = explorer.view.flattenedNodes;
        const begin = scanIndexPrev(
          flattenedNodes,
          currentIndex,
          false,
          (node) => {
            return (currentNode.level ?? 0) > (node.level ?? 0);
          }
        );
        if (begin === void 0) {
          return;
        }
        const end = scanIndexNext(
          flattenedNodes,
          currentIndex,
          false,
          (node) => {
            return (currentNode.level ?? 0) > (node.level ?? 0);
          }
        );
        if (end === void 0) {
          return;
        }
        await nvim.command(`normal! ${begin + 2}GV${end}G`);
      }
    },
    "use visual mode selects",
    {
      args: [
        {
          name: "target",
          description: textobjTargetList.join(" | ")
        },
        {
          name: "type",
          description: textobjTypeList.join(" | ")
        }
      ],
      menus: {
        "line:i": "line:i",
        "line:a": "line:a",
        "indent:i": "indent:i",
        "indent:a": "indent:a"
      }
    }
  );
  action.addNodeAction(
    "select",
    async ({ source, node }) => {
      source.selectedNodes.add(node);
      source.view.requestRenderNodes([node]);
    },
    "select node",
    { select: "visual" }
  );
  action.addNodeAction(
    "unselect",
    async ({ source, node }) => {
      source.selectedNodes.delete(node);
      source.view.requestRenderNodes([node]);
    },
    "unselect node",
    { select: "visual" }
  );
  action.addNodeAction(
    "toggleSelection",
    async ({ source, node }) => {
      if (source.selectedNodes.has(node)) {
        await source.action.doAction("unselect", node);
      } else {
        await source.action.doAction("select", node);
      }
    },
    "toggle node selection",
    {
      select: "visual"
    }
  );
  action.addNodeAction(
    "toggleHidden",
    async ({ source }) => {
      source.showHidden = !source.showHidden;
    },
    "toggle visibility of hidden node",
    {
      reload: true
    }
  );
  const parseSize = (sizeStr) => {
    const [widthStr, heightStr] = sizeStr.split(/,|x/).map((it) => it.trim());
    return [
      widthStr ? parseInt(widthStr) : void 0,
      heightStr ? parseInt(heightStr) : void 0
    ];
  };
  action.addNodeAction(
    "resize",
    async ({ args }) => {
      const [sizeStr] = args;
      if (!sizeStr)
        return;
      const [width, height] = parseSize(sizeStr);
      if (explorer.isFloating) {
        await explorer.resize([width, height]);
      } else {
        await explorer.resize([width]);
      }
      await explorer.render();
    },
    "resize",
    {
      args: [
        {
          name: "size",
          description: "{WIDTH}x{HEIGHT} | {WIDTH},{HEIGHT}"
        }
      ],
      menus: {
        path: {
          description: "resize the explorer window",
          args: "[size]",
          async actionArgs() {
            return [await input("input a the size:", "20,10", "file")];
          }
        }
      }
    }
  );
  action.addNodeAction(
    "adjustSize",
    async ({ args }) => {
      const [sizeStr] = args;
      if (!sizeStr)
        return;
      const [width, height] = parseSize(sizeStr);
      if (explorer.isFloating) {
        await explorer.adjustSize([width, height]);
      } else {
        await explorer.adjustSize([width]);
      }
      await explorer.render();
    },
    "adjust window size",
    {
      args: [
        {
          name: "size",
          description: "+-{WIDTH}x+-{HEIGHT} | +-{WIDTH},+-{HEIGHT}"
        }
      ],
      menus: {
        path: {
          description: "resize the explorer window",
          args: "[size]",
          async actionArgs() {
            return [await input("input a the size:", "+20,-10", "file")];
          }
        }
      }
    }
  );
  action.addNodeAction(
    "refresh",
    async ({ source }) => {
      source.selectedNodes.clear();
      await explorer.view.sync(async (r) => {
        const loadNotifier = await explorer.loadAllNotifier(r);
        nvim.pauseNotification();
        source.highlight.clearHighlightsNotify();
        loadNotifier == null ? void 0 : loadNotifier.notify();
        await nvim.resumeNotification();
      });
    },
    "refresh"
  );
  action.addNodeAction(
    "render",
    async ({ source, node }) => {
      await source.view.render({ node });
    },
    "render"
  );
  action.addNodeAction(
    "help",
    async ({ source }) => {
      await source.explorer.showHelp(source);
    },
    "show help"
  );
  action.addNodesAction(
    "actionMenu",
    async ({ source, nodes }) => {
      await source.action.listActionMenu(nodes);
    },
    "show actions in coc-list",
    {
      select: "visual"
    }
  );
  action.addNodeAction(
    "normal",
    async ({ args }) => {
      if (args[0]) {
        await nvim.command(`execute "normal ${args[0]}"`);
      }
    },
    "execute vim normal mode commands",
    {
      args: [
        {
          name: "normal commands"
        }
      ],
      menus: {
        zz: "execute normal zz"
      }
    }
  );
  action.addNodeAction(
    "esc",
    async ({ source, mode }) => {
      if (source.explorer.isFloating && mode === "n") {
        await source.explorer.quit();
      } else {
        source.view.requestRenderNodes(Array.from(source.selectedNodes));
        source.selectedNodes.clear();
      }
    },
    "esc action"
  );
  action.addNodeAction(
    "quit",
    async () => {
      await explorer.quit();
    },
    "quit explorer"
  );
}

// src/floating/floatingPreview.ts
var import_coc36 = require("coc.nvim");
var import_isbinaryfile = __toESM(require_lib2());

// src/floating/floatingWindow.ts
var import_coc35 = require("coc.nvim");
var FloatingWindow2 = class {
  constructor(win) {
    this.win = win;
    this.bufnr = this.win.bufnr;
  }
  static async create(options = {}) {
    const win = await FloatingWindow.create({
      mode: "show",
      name: options.name
    });
    return new FloatingWindow2(win);
  }
  dispose() {
    this.win.dispose();
  }
  async open(lines, highlights, options) {
    if (this.closeTimer) {
      clearTimeout(this.closeTimer);
    }
    await this.win.open({
      top: options.top,
      left: options.left,
      width: options.width,
      height: options.height,
      winHl: "CocExplorerNormalFloat",
      winHlNC: "CocExplorerNormalFloat",
      borderWinHl: "CocExplorerNormalFloatBorder",
      lines,
      highlights,
      focus: false,
      initedExecute: ({ winid }) => {
        const scripts = [];
        if (import_coc35.workspace.isNvim) {
          scripts.push(`
            let store_winid = win_getid(winnr())
            if store_winid != ${winid}
              noau let successful = win_gotoid(${winid})
              if !successful
                return
              endif
            endif
          `);
          scripts.push("set filetype=");
          if (options.focusLineIndex) {
            scripts.push(`call nvim_win_set_cursor(${options.focusLineIndex})`);
          }
          if (!options.filetype && options.filepath) {
            scripts.push(
              `execute 'doautocmd filetypedetect BufRead ' . fnameescape('${options.filepath}')`
            );
          }
          if (options.filetype) {
            scripts.push(`set filetype=${options.filetype}`);
          }
          scripts.push(`
            if store_winid != ${winid}
              noau call win_gotoid(store_winid)
            endif
          `);
        } else {
          scripts.push(`call win_execute(${winid}, 'set filetype=')`);
          if (options.focusLineIndex) {
            scripts.push(
              `call win_execute(${winid}, 'call cursor(${options.focusLineIndex}, 1)')`
            );
          }
          if (!options.filetype && options.filepath) {
            scripts.push(
              `call win_execute(${winid}, 'doautocmd filetypedetect BufRead ' . fnameescape('${options.filepath}'))`
            );
          }
          if (options.filetype) {
            scripts.push(
              `call win_execute(${winid}, 'set filetype=${options.filetype}')`
            );
          }
        }
        return scripts.join("\n");
      }
    });
  }
  async closeDelay(ms) {
    if (this.closeTimer) {
      clearTimeout(this.closeTimer);
    }
    this.closeTimer = setTimeout(() => {
      this.win.close().catch(logger.error);
    }, ms);
  }
  async close() {
    await this.win.close();
  }
};

// src/floating/floatingPreview.ts
var FloatingPreview = class {
  constructor(explorer) {
    this.explorer = explorer;
    this.shown = false;
    this.disposables = [];
    this.preferTop = false;
    this.onHoverStrategy = false;
    this.nvim = import_coc36.workspace.nvim;
    this.onHoverDisposables = [];
    this.registeredPreviewActions = {};
    this.maxHeight = explorer.config.get("previewAction.content.maxHeight");
    this.registerActions();
    this.disposables.push(
      explorer.events.on("first-open-post", () => {
        this.disposables.push(
          onEvent("BufWinLeave", async (bufnr) => {
            if (bufnr === this.explorer.bufnr) {
              await this.close();
            }
          }),
          onBufEnter(async (bufnr) => {
            var _a;
            if (bufnr !== this.explorer.bufnr && bufnr !== ((_a = this.previewWindow) == null ? void 0 : _a.bufnr)) {
              await this.closeDelay(200);
            }
          }, 0),
          onCursorMoved(async (bufnr) => {
            if (this.onHoverStrategy || bufnr !== this.explorer.bufnr) {
              return;
            }
            await this.closeDelay(200);
          }, 0),
          import_coc36.Disposable.create(() => {
            (0, import_coc36.disposeAll)(this.onHoverDisposables);
          })
        );
        const onHover = explorer.config.get("previewAction.onHover");
        if (!onHover) {
          return;
        }
        if (Array.isArray(onHover)) {
          this.registerOnHover(onHover[0], onHover[1]);
        } else {
          this.registerOnHover(onHover);
        }
      })
    );
  }
  dispose() {
    var _a;
    (_a = this.previewWindow) == null ? void 0 : _a.dispose();
  }
  async getPreviewWindow() {
    if (!this.previewWindow) {
      this.previewWindow = await FloatingWindow2.create();
    }
    return this.previewWindow;
  }
  async closeDelay(ms) {
    var _a;
    await ((_a = this.previewWindow) == null ? void 0 : _a.closeDelay(ms));
  }
  async close() {
    var _a;
    await ((_a = this.previewWindow) == null ? void 0 : _a.close());
  }
  toggleOnHover(onHoverStrategy, delay) {
    if (this.onHoverStrategy === onHoverStrategy) {
      this.unregisterOnHover();
    } else {
      this.registerOnHover(onHoverStrategy, delay);
    }
  }
  registerOnHover(onHoverStrategy, delay = 300) {
    if (this.onHoverStrategy === onHoverStrategy) {
      return;
    }
    this.onHoverStrategy = onHoverStrategy;
    (0, import_coc36.disposeAll)(this.onHoverDisposables);
    this.onHoverDisposables = [];
    const onHover = async (bufnr) => {
      if (this.explorer.view.isHelpUI) {
        await this.close();
        return;
      }
      if (bufnr !== this.explorer.bufnr) {
        return;
      }
      await this.explorer.view.refreshLineIndex();
      const source = await this.explorer.view.currentSource();
      if (!source) {
        return;
      }
      const node = source.view.currentNode();
      if (!node) {
        return;
      }
      const nodeIndex = source.view.getLineByNode(node);
      if (nodeIndex === void 0) {
        return;
      }
      await this.previewNode(onHoverStrategy, source, node, nodeIndex);
    };
    this.onHoverDisposables.push(
      onCursorMoved(onHover, delay),
      onBufEnter(onHover, delay)
    );
    currentBufnr().then(onHover).catch(logger.error);
    void import_coc36.window.showInformationMessage(`Preview ${onHoverStrategy} enabled`);
  }
  unregisterOnHover() {
    if (!this.onHoverStrategy) {
      return;
    }
    this.onHoverStrategy = false;
    (0, import_coc36.disposeAll)(this.onHoverDisposables);
    this.onHoverDisposables = [];
    this.close().catch(logger.error);
    void import_coc36.window.showInformationMessage("Preview disabled ");
  }
  registerAction(name, action) {
    this.registeredPreviewActions[name] = action;
  }
  registerActions() {
    this.registerAction("labeling", async ({ source, node, nodeIndex }) => {
      var _a;
      const drawnList = await ((_a = source.view.sourcePainters) == null ? void 0 : _a.drawNodeLabeling(node, nodeIndex));
      if (!drawnList || !await this.explorer.explorerManager.inExplorer()) {
        return;
      }
      return {
        lines: drawnList.map((d3) => d3.content),
        highlights: flatten_default(
          drawnList.map(
            (d3, index) => d3.highlightPositions.map((hl) => ({
              hlGroup: hl.group,
              line: index,
              colStart: hl.start,
              colEnd: hl.start + hl.size
            }))
          )
        ),
        options: {
          filetype: "coc-explorer-labeling"
        }
      };
    });
    this.registerAction("content", async ({ node }) => {
      if (node.expandable) {
        return;
      }
      let location;
      if (node.location) {
        location = node.location;
      } else if (node.fullpath) {
        location = import_coc36.Location.create(node.fullpath, import_coc36.Range.create(0, 0, 0, 0));
      } else {
        return;
      }
      const { uri, range } = location;
      if (await (0, import_isbinaryfile.isBinaryFile)(uri)) {
        await import_coc36.window.showInformationMessage("Preview content skip binary");
        return;
      }
      const doc = import_coc36.workspace.getDocument(uri);
      const lines = doc ? doc.getLines(0, range.end.line + this.maxHeight) : await readFileLines(uri, 0, range.end.line + this.maxHeight);
      return {
        lines,
        highlights: [],
        options: {
          filepath: uri,
          focusLineIndex: range.start.line
        }
      };
    });
  }
  borderOptions() {
    return {
      border_enable: false,
      border_chars: [],
      title: ""
    };
  }
  getDimension(lines, maxWidth, maxHeight) {
    if (maxWidth === 0 || maxHeight === 0) {
      return { width: 0, height: 0 };
    }
    const lineLens = [];
    for (const line of lines) {
      lineLens.push(byteLength(line.replace(/\t/g, "  ")));
    }
    const width = min_default([max_default(lineLens), maxWidth]);
    if (width === void 0 || width === 0) {
      return { width: 0, height: 0 };
    }
    let height = 0;
    for (const lineLen of lineLens) {
      height = height + Math.max(Math.ceil(lineLen / width), 1);
    }
    return { width, height: Math.min(height, maxHeight) };
  }
  async getFloatOptions(lines) {
    const env = import_coc36.workspace.env;
    const vimColumns = env.columns;
    const vimLines = env.lines - env.cmdheight - 1;
    const position = this.explorer.argValues.position;
    const isFloating = position.name === "floating";
    const floatingPosition = await this.explorer.args.value(
      argOptions.floatingPosition
    );
    const win = await this.explorer.win;
    if (!win) {
      return;
    }
    let alignTop = false;
    const bufnr = await currentBufnr();
    let winline = bufnr === this.explorer.bufnr ? await this.nvim.call("winline") : 1;
    winline -= 1;
    const containerWin = isFloating && this.explorer.config.get("floating.border.enable") ? await this.explorer.borderWin : await this.explorer.win;
    if (!containerWin) {
      return;
    }
    let [winTop, winLeft] = await this.nvim.call(
      "win_screenpos",
      [containerWin.id]
    );
    winTop -= 1;
    winLeft -= 1;
    const containerWidth = await containerWin.width;
    const maxWidth = vimColumns - containerWidth - (isFloating ? 0 : 1) - 2;
    const maxHeight = min_default([this.maxHeight, vimLines]);
    const { width, height } = this.getDimension(lines, maxWidth, maxHeight);
    if (!this.preferTop) {
      if (vimLines - winline < height && winline > height) {
        alignTop = true;
      }
    } else {
      if (winline >= maxHeight || winline >= vimLines - winline) {
        alignTop = true;
      }
    }
    const top = winTop + (alignTop ? winline - height + 1 : winline);
    let left;
    if (position.name === "left") {
      left = winLeft + containerWidth + 2;
    } else if (position.name === "right") {
      left = winLeft - width - 2;
    } else if (isFloating && floatingPosition === "left-center") {
      left = winLeft + containerWidth + 1;
    } else if (isFloating && floatingPosition === "right-center") {
      left = winLeft - width - 1;
    } else {
      return;
    }
    return {
      top,
      left,
      width,
      height,
      ...this.borderOptions()
    };
  }
  async previewNode(previewStrategy, source, node, nodeIndex) {
    if (!supportedFloat()) {
      return;
    }
    if (!this.registeredPreviewActions[previewStrategy]) {
      await import_coc36.window.showInformationMessage(
        `coc-explorer no support preview strategy(${previewStrategy})`
      );
      return;
    }
    const openArgs = await this.registeredPreviewActions[previewStrategy]({
      source,
      node,
      nodeIndex
    });
    if (!openArgs) {
      await this.close();
      return;
    }
    const previewWindow = await this.getPreviewWindow();
    const floatOptions = await this.getFloatOptions(openArgs.lines);
    if (!floatOptions) {
      await this.close();
      return;
    }
    await previewWindow.open(openArgs.lines, openArgs.highlights ?? [], {
      ...floatOptions,
      ...openArgs.options
    });
  }
};

// src/help.ts
var import_coc39 = require("coc.nvim");

// src/highlight/manager.ts
var import_coc37 = require("coc.nvim");
var HighlightManager = class {
  constructor() {
    this.nvim = import_coc37.workspace.nvim;
    this.highlights = [];
  }
  linkGroup(groupName, targetGroup) {
    const group = `CocExplorer${groupName}`;
    const commands4 = [`highlight default link ${group} ${targetGroup}`];
    const highlight = {
      group,
      commands: commands4
    };
    this.highlights.push(highlight);
    return highlight;
  }
  createGroup(groupName, hlCommand) {
    const group = `CocExplorer${groupName}`;
    const commands4 = [`highlight default ${group} ${hlCommand}`];
    const highlight = {
      group,
      commands: commands4
    };
    this.highlights.push(highlight);
    return highlight;
  }
  async watchColorScheme(disposables, update, immediate = true) {
    disposables.push(internalEvents.on("ColorScheme", update));
    if (immediate) {
      await update();
    }
  }
  clearHighlightsNotify(explorer, hlSrcId, lineStart, lineEnd) {
    explorer.buffer.clearNamespace(-1, lineStart, lineEnd);
  }
  addHighlightsNotify(explorer, hlSrcId, highlights) {
    for (const hl of highlights) {
      if (hl.size === 0) {
        continue;
      }
      explorer.buffer.highlightRanges(-1, hl.group, [
        import_coc37.Range.create(
          import_coc37.Position.create(hl.lineIndex, hl.start),
          import_coc37.Position.create(hl.lineIndex, hl.start + hl.size)
        )
      ]);
    }
  }
  bootHighlightSyntaxNotify() {
    const commands4 = [];
    for (const hl of this.highlights) {
      this.nvim.command(`silent! syntax clear ${hl.group}`, true);
      commands4.push(...hl.commands);
    }
    this.nvim.call("coc_explorer#util#execute_commands", [commands4], true);
  }
};
var hlGroupManager = new HighlightManager();

// src/painter/util.ts
function drawnWithIndexRange(drawnList) {
  if (!drawnList.length) {
    return [];
  }
  const sortedDrawnList = drawnList.sort((a3, b2) => a3.nodeIndex - b2.nodeIndex);
  const drawnRangeList = [];
  let drawnRangeCur;
  for (let i2 = 0, len = sortedDrawnList.length; i2 < len; i2++) {
    const drawn = sortedDrawnList[i2];
    if (!drawnRangeCur) {
      drawnRangeCur = {
        nodeIndexStart: drawn.nodeIndex,
        nodeIndexEnd: drawn.nodeIndex,
        drawnList: [drawn]
      };
    } else if (drawnRangeCur.nodeIndexEnd + 1 === drawn.nodeIndex) {
      drawnRangeCur.drawnList.push(drawn);
      drawnRangeCur.nodeIndexEnd = drawn.nodeIndex;
    } else {
      drawnRangeList.push(drawnRangeCur);
      i2--;
      drawnRangeCur = void 0;
    }
  }
  if (drawnRangeCur) {
    drawnRangeList.push(drawnRangeCur);
  }
  return drawnRangeList;
}
var isEmptyDrawableList = (drawableList) => sum_default(
  drawableList.map(
    (p) => p.type === "content" ? p.content.length : p.type === "group" ? sum_default(
      p.contents.map(
        (c2) => c2.type === "content" ? c2.content.length : 0
      )
    ) : 0
  )
) === 0;
async function fetchDisplayWidth(drawableList) {
  async function getDrawContentWith(drawable) {
    return {
      ...drawable,
      width: drawable.unicode && !isASCII(drawable.content) ? await displayWidth2(drawable.content) : drawable.content.length
    };
  }
  return compactI2(
    flatten_default(
      await Promise.all(
        drawableList.map(async (it) => {
          if (it.type === "content") {
            return await getDrawContentWith(it);
          } else if (it.type === "group") {
            return {
              ...it,
              contents: await Promise.all(
                compactI2(
                  it.contents.map(
                    (c2) => c2.type === "content" ? getDrawContentWith(c2) : void 0
                  )
                )
              )
            };
          } else {
            return it;
          }
        })
      )
    )
  );
}
function divideVolumeBy(totalWidth, volumes, widthLimit) {
  let unit = totalWidth / sum_default(volumes);
  const widthes = new Array(volumes.length);
  if (widthLimit) {
    for (let i2 = 0; i2 < volumes.length; i2++) {
      const width = Math.ceil(volumes[i2] * unit);
      if (width > widthLimit[i2]) {
        widthes[i2] = widthLimit[i2];
        totalWidth -= widthLimit[i2];
        volumes[i2] = 0;
      }
    }
    unit = totalWidth / sum_default(volumes);
  }
  for (let i2 = 0; i2 < volumes.length; i2++) {
    if (widthes[i2] === void 0) {
      const width = Math.ceil(volumes[i2] * unit);
      if (width <= totalWidth) {
        totalWidth -= width;
        widthes[i2] = width;
      } else {
        widthes[i2] = totalWidth;
      }
    }
  }
  return widthes;
}
async function handlePadding(drawableList) {
  return drawableList.map((it) => {
    var _a;
    if (it.type === "group" && ((_a = it.flexible) == null ? void 0 : _a.padding) && it.flexible.paddingVolume) {
      const width = sum_default(
        it.contents.map((c2) => c2.type === "content" ? c2.width : 0)
      );
      if (it.flexible.paddingVolume > width) {
        const width2 = it.flexible.paddingVolume;
        if (it.flexible.padding === "left") {
          return {
            ...it,
            contents: [
              {
                type: "content",
                content: " ".repeat(width2),
                width: width2
              },
              ...it.contents
            ]
          };
        } else if (it.flexible.padding === "right") {
          return {
            ...it,
            contents: [
              ...it.contents,
              {
                type: "content",
                content: " ".repeat(width2),
                width: width2
              }
            ]
          };
        } else if (it.flexible.padding === "center") {
          const left = Math.ceil(width2 / 2);
          const right = width2 - left;
          return {
            ...it,
            contents: [
              {
                type: "content",
                content: " ".repeat(left),
                width: left
              },
              ...it.contents,
              {
                type: "content",
                content: " ".repeat(right),
                width: right
              }
            ]
          };
        } else {
          return it;
        }
      } else {
        return it;
      }
    } else {
      return it;
    }
  });
}
async function handleGrow(fullwidth, usedWidth, drawableList) {
  const allSpaceWidth = fullwidth - usedWidth;
  const spaceWids = divideVolumeBy(
    allSpaceWidth,
    drawableList.map(
      (c2) => {
        var _a;
        return c2.type === "group" && ((_a = c2.flexible) == null ? void 0 : _a.grow) ? c2.flexible.growVolume ?? 1 : 0;
      }
    )
  );
  return compactI2(
    flatten_default(
      await Promise.all(
        drawableList.map(
          async (item, idx) => {
            var _a;
            if (item.type === "content") {
              return item;
            } else if (item.type === "group") {
              if (!((_a = item.flexible) == null ? void 0 : _a.grow)) {
                return item.contents;
              }
              const spaceWid = spaceWids[idx];
              if (item.flexible.grow === "left") {
                return [
                  {
                    type: "content",
                    content: " ".repeat(spaceWid),
                    width: spaceWid
                  },
                  ...item.contents
                ];
              } else if (item.flexible.grow === "right") {
                return [
                  ...item.contents,
                  {
                    type: "content",
                    content: " ".repeat(spaceWid),
                    width: spaceWid
                  }
                ];
              } else if (item.flexible.grow === "center") {
                const leftSpace = Math.floor(spaceWid / 2);
                const rightSpace = spaceWid - leftSpace;
                return [
                  {
                    type: "content",
                    content: " ".repeat(leftSpace),
                    width: leftSpace
                  },
                  ...item.contents,
                  {
                    type: "content",
                    content: " ".repeat(rightSpace),
                    width: rightSpace
                  }
                ];
              } else {
                return item.contents;
              }
            }
          }
        )
      )
    )
  );
}
var omitSymbolHighlight = hlGroupManager.linkGroup(
  "OmitSymbol",
  "SpecialComment"
);
async function handleOmit(fullwidth, usedWidth, drawableList) {
  const allOmitWidth = usedWidth - fullwidth;
  const omitWids = divideVolumeBy(
    allOmitWidth,
    drawableList.map(
      (c2) => {
        var _a;
        return c2.type === "group" && ((_a = c2.flexible) == null ? void 0 : _a.omit) ? c2.flexible.omitVolume ?? 1 : 0;
      }
    ),
    drawableList.map((c2) => {
      if (c2.type === "content") {
        return c2.width;
      } else if (c2.type === "group") {
        return sum_default(
          c2.contents.map((cc) => cc.type === "content" ? cc.width : 0)
        );
      } else {
        return 0;
      }
    })
  );
  return compactI2(
    flatten_default(
      await Promise.all(
        drawableList.map(
          async (item, idx) => {
            var _a;
            if (item.type === "content") {
              return item;
            } else if (item.type === "group") {
              if (!((_a = item.flexible) == null ? void 0 : _a.omit)) {
                return item.contents;
              }
              const omitWid = omitWids[idx];
              const contents = [];
              if (item.flexible.omit === "left") {
                const cutWid = omitWid + 1;
                let remainCutWid = cutWid;
                for (const c2 of item.contents) {
                  if (c2.type !== "content") {
                    contents.push(c2);
                    continue;
                  }
                  if (remainCutWid < 0) {
                    contents.push(c2);
                  } else if (remainCutWid < c2.width) {
                    contents.push({
                      type: "content",
                      content: "\u2025",
                      width: 1,
                      group: omitSymbolHighlight.group
                    });
                    if (remainCutWid > 0) {
                      contents.push({
                        ...c2,
                        content: await displaySlice(c2.content, remainCutWid),
                        width: c2.width - remainCutWid
                      });
                    }
                  }
                  remainCutWid -= c2.width;
                }
                return contents;
              } else if (item.flexible.omit === "right") {
                const cutWid = omitWid + 1;
                const contentWid = sum_default(
                  item.contents.map(
                    (c2) => c2.type === "content" ? c2.width : 0
                  )
                );
                let remainWid = contentWid - cutWid;
                for (const c2 of item.contents) {
                  if (c2.type !== "content") {
                    contents.push(c2);
                    continue;
                  }
                  if (remainWid >= c2.width) {
                    contents.push(c2);
                  } else if (remainWid < c2.width) {
                    if (remainWid > 0) {
                      contents.push({
                        ...c2,
                        content: await displaySlice(c2.content, 0, remainWid),
                        width: remainWid
                      });
                    }
                    contents.push({
                      type: "content",
                      content: "\u2025",
                      width: 1,
                      group: omitSymbolHighlight.group
                    });
                    break;
                  }
                  remainWid -= c2.width;
                }
                return contents;
              } else if (item.flexible.omit === "center") {
                const contentWid = sum_default(
                  item.contents.map(
                    (c2) => c2.type === "content" ? c2.width : 0
                  )
                );
                const cutWid = omitWid + 1;
                const remainWid = contentWid - cutWid;
                const leftCutPos = Math.floor(remainWid / 2);
                const rightCutPos = contentWid - (remainWid - leftCutPos);
                let itemStartPos = 0;
                let itemEndPos = 0;
                const contents2 = [];
                for (const c2 of item.contents) {
                  if (c2.type !== "content") {
                    contents2.push(c2);
                    continue;
                  }
                  itemEndPos += c2.width;
                  if (itemStartPos < leftCutPos) {
                    if (itemEndPos <= leftCutPos) {
                      contents2.push(c2);
                    } else if (itemEndPos <= rightCutPos) {
                      const width = leftCutPos - itemStartPos;
                      contents2.push({
                        ...c2,
                        content: await displaySlice(c2.content, 0, width),
                        width
                      });
                      contents2.push({
                        type: "content",
                        content: "\u2025",
                        width: 1,
                        group: omitSymbolHighlight.group
                      });
                    } else {
                      const leftWidth = leftCutPos - itemStartPos;
                      contents2.push({
                        ...c2,
                        content: await displaySlice(c2.content, 0, leftWidth),
                        width: leftWidth
                      });
                      contents2.push({
                        type: "content",
                        content: "\u2025",
                        width: 1,
                        group: omitSymbolHighlight.group
                      });
                      const rightWidth = itemEndPos - rightCutPos;
                      contents2.push({
                        ...c2,
                        content: await displaySlice(
                          c2.content,
                          c2.width - rightWidth
                        ),
                        width: rightWidth
                      });
                    }
                  } else if (itemEndPos > rightCutPos) {
                    if (itemStartPos >= rightCutPos) {
                      contents2.push(c2);
                    } else {
                      const width = itemEndPos - rightCutPos;
                      contents2.push({
                        ...c2,
                        content: await displaySlice(c2.content, c2.width - width),
                        width
                      });
                    }
                  }
                  itemStartPos = itemEndPos;
                }
                return contents2;
              }
            }
          }
        )
      )
    )
  );
}

// src/source/viewPainter.ts
var ViewPainter = class {
  constructor(explorer) {
    this.explorer = explorer;
  }
  get width() {
    return this.explorer.contentWidth;
  }
  async drawRow(draw) {
    const row = new ViewRowPainter(this);
    await draw(row);
    return row;
  }
};
var ViewRowPainter = class {
  constructor(view) {
    this.view = view;
    this.drawableList = [];
  }
  async draw({ flexible = true } = {}) {
    const drawableList = await handlePadding(
      await fetchDisplayWidth(this.drawableList)
    );
    let drawContents = [];
    const fullwidth = this.view.width;
    const usedWidth = sum_default(
      drawableList.map((c2) => {
        if (c2.type === "content") {
          return c2.width;
        } else if (c2.type === "group") {
          return sum_default(
            c2.contents.map((cc) => cc.type === "content" ? cc.width : 0)
          );
        } else {
          return 0;
        }
      })
    );
    if (!flexible || usedWidth === fullwidth) {
      drawContents = flatten_default(
        drawableList.map(
          (item) => {
            if (item.type === "group") {
              return item.contents;
            } else {
              return item;
            }
          }
        )
      );
    } else if (usedWidth < fullwidth) {
      drawContents = await handleGrow(fullwidth, usedWidth, drawableList);
    } else if (usedWidth > fullwidth) {
      drawContents = await handleOmit(fullwidth, usedWidth, drawableList);
    }
    const highlightPositions = [];
    let content = "";
    let col = 0;
    for (const drawContent of drawContents) {
      const size = drawContent.content.length;
      if (drawContent.group) {
        highlightPositions.push({
          group: drawContent.group,
          start: col,
          size
        });
      }
      content += drawContent.content;
      col += size;
    }
    return {
      content,
      highlightPositions
    };
  }
  add(content, {
    hl,
    width,
    drawGroup,
    unicode = false
  } = {}) {
    const group = hl ? typeof hl === "string" ? hl : hl.group : void 0;
    const drawContent = {
      type: "content",
      content,
      unicode,
      group,
      width
    };
    if (drawGroup) {
      drawGroup.contents.push(drawContent);
    } else {
      this.drawableList.push(drawContent);
    }
  }
  async drawBlockToList(drawBlock) {
    const storeList = this.drawableList;
    this.drawableList = [];
    await drawBlock(this);
    const drawableList = this.drawableList;
    this.drawableList = storeList;
    return drawableList;
  }
  async flexible(flexible, drawBlock) {
    const list = await this.drawBlockToList(drawBlock);
    this.drawableList.push(this.flexibleForList(flexible, list));
  }
  flexibleForList(flexible, drawableList) {
    return {
      type: "group",
      contents: flatten_default(
        drawableList.map((c2) => {
          if (c2.type === "content") {
            return c2;
          } else if (c2.type === "group") {
            return c2.contents;
          } else {
            return c2;
          }
        })
      ),
      flexible
    };
  }
  async addColumn(node, nodeIndex, column, isLabeling = false) {
    this.drawableList.push(
      ...await this.columnToList(node, nodeIndex, column, isLabeling)
    );
  }
  async columnToList(node, nodeIndex, column, isLabeling = false) {
    return await this.drawBlockToList(async () => {
      var _a;
      if (typeof column === "number") {
        this.add(" ".repeat(column));
        return;
      }
      await ((_a = column.drawHandle) == null ? void 0 : _a.drawNode(this, {
        node,
        nodeIndex,
        isLabeling
      }));
    });
  }
  async addTemplatePart(node, nodeIndex, part, isLabeling = false) {
    if (typeof part === "string") {
      this.add(part);
      return;
    }
    const drawableList = [];
    const column = part.column;
    drawableList.push(
      ...await this.columnToList(node, nodeIndex, column, isLabeling)
    );
    const flexible = {};
    const getVolume = (c2) => typeof c2 === "number" ? c2 : 1;
    if (part.modifiers) {
      for (const modifier of part.modifiers) {
        if (modifier.name === "|") {
          if (isEmptyDrawableList(drawableList)) {
            drawableList.push(
              ...await this.columnToList(
                node,
                nodeIndex,
                modifier.column,
                isLabeling
              )
            );
          }
        } else if (modifier.name === "&") {
          if (!isEmptyDrawableList(drawableList)) {
            drawableList.push(
              ...await this.columnToList(
                node,
                nodeIndex,
                modifier.column,
                isLabeling
              )
            );
          }
        } else if (modifier.name === "growLeft") {
          flexible.grow = "left";
          flexible.growVolume = getVolume(modifier.column);
        } else if (modifier.name === "growCenter") {
          flexible.grow = "center";
          flexible.growVolume = getVolume(modifier.column);
        } else if (modifier.name === "growRight") {
          flexible.grow = "right";
          flexible.growVolume = getVolume(modifier.column);
        } else if (modifier.name === "omitLeft") {
          flexible.omit = "left";
          flexible.omitVolume = getVolume(modifier.column);
        } else if (modifier.name === "omitCenter") {
          flexible.omit = "center";
          flexible.omitVolume = getVolume(modifier.column);
        } else if (modifier.name === "omitRight") {
          flexible.omit = "right";
          flexible.omitVolume = getVolume(modifier.column);
        }
      }
    }
    if (flexible.omit || flexible.grow) {
      this.drawableList.push(this.flexibleForList(flexible, drawableList));
    } else {
      this.drawableList.push(...drawableList);
    }
  }
};

// src/mappings/manager.ts
var import_coc38 = require("coc.nvim");
var mappings = {};
async function registerMappings(context2, explorerManager) {
  const commonKeys = [...await keyMapping.getCommonKeys()];
  const keysModes = [
    ["n", commonKeys],
    ["v", [...commonKeys, ...await keyMapping.getVisualKeys()]]
  ];
  for (const [mode, keys2] of keysModes) {
    mappings[mode] = {};
    for (const key of keys2) {
      if (mappings[mode][key]) {
        continue;
      }
      if (mode === "v" && ["o", "j", "k"].includes(key)) {
        continue;
      }
      const plugKey = `explorer-key-${mode}-${key.replace(/<(.*)>/, "[$1]")}`;
      context2.subscriptions.push(
        import_coc38.workspace.registerKeymap([mode], plugKey, async () => {
          const count = await import_coc38.workspace.nvim.eval("v:count");
          const explorer = await explorerManager.currentExplorer();
          explorer == null ? void 0 : explorer.action.doActionByKey(key, mode, count || 1).catch(logger.error);
        })
      );
      mappings[mode][key] = `<Plug>(coc-${plugKey})`;
    }
  }
  await import_coc38.workspace.nvim.call("coc_explorer#mappings#register", [mappings]);
}
async function executeMappings() {
  await import_coc38.workspace.nvim.call("coc_explorer#mappings#execute", [mappings]);
}
async function clearMappings() {
  await import_coc38.workspace.nvim.call("coc_explorer#mappings#clear", [mappings]);
}

// src/help.ts
var hlg = hlGroupManager.linkGroup.bind(hlGroupManager);
var helpHightlights = {
  line: hlg("HelpLine", "Operator"),
  hint: hlg("HelpHint", "Comment"),
  title: hlg("HelpTitle", "Boolean"),
  subtitle: hlg("HelpSubTitle", "Label"),
  mappingKey: hlg("HelpMappingKey", "PreProc"),
  action: hlg("HelpAction", "Identifier"),
  column: hlg("HelpColumn", "Identifier"),
  arg: hlg("HelpArg", "Identifier"),
  description: hlg("HelpDescription", "Comment"),
  type: hlg("HelperType", "Type"),
  conditional: hlg("HelpConditional", "Conditional")
};
var helpHlSrcId = "coc-explorer-help";
var HelpPainter = class {
  constructor(explorer, source, width) {
    this.explorer = explorer;
    this.source = source;
    this.width = width;
    this.drawnResults = [];
    this.painter = new ViewPainter(explorer);
    this.registeredActions = this.source.action.registeredActions();
  }
  async drawRow(drawBlock) {
    const row = await this.painter.drawRow(drawBlock);
    this.drawnResults.push(await row.draw());
  }
  async drawHr() {
    await this.drawRow((row) => {
      row.add("\u2014".repeat(this.width), { hl: helpHightlights.line });
    });
  }
  async drawHead() {
    await this.drawRow((row) => {
      row.add("Help ");
      row.add("(use q, ? or <esc> return to explorer)", {
        hl: helpHightlights.hint
      });
    });
    await this.drawHr();
  }
  drawActionForMapping(row, action) {
    row.add(action.name, { hl: helpHightlights.action });
    if (action.args) {
      row.add(`(${action.args.join(",")})`, { hl: helpHightlights.arg });
    }
    row.add(" ");
    const registeredAction = this.registeredActions.get(action.name);
    if (registeredAction) {
      row.add(registeredAction.description, {
        hl: helpHightlights.description
      });
    }
  }
  anyAction(actionExp, callback) {
    if (Array.isArray(actionExp)) {
      return actionExp.some((action) => this.anyAction(action, callback));
    } else {
      return callback(actionExp);
    }
  }
  drawMappingsPrefix(indent, row, ctx) {
    if (!ctx.isFirstLine) {
      row.add(indent);
      return;
    }
    ctx.isFirstLine = false;
    if (ctx.key) {
      row.add(" ");
      row.add(ctx.key, { hl: helpHightlights.mappingKey });
      row.add(" - ");
    }
    if (ctx.isWait) {
      row.add(`${waitAction.helpDescription} `, { hl: helpHightlights.type });
    }
  }
  async drawMappingsAction(indent, action, ctx) {
    await this.drawRow((row) => {
      this.drawMappingsPrefix(indent, row, ctx);
      if (action.name === noopAction.name) {
        row.add(noopAction.helpDescription, { hl: helpHightlights.type });
        return;
      }
      row.add(action.name, { hl: helpHightlights.action });
      if (action.args) {
        row.add(`(${action.args.join(",")})`, { hl: helpHightlights.arg });
      }
      row.add(" ");
      const registeredAction = this.registeredActions.get(action.name);
      if (registeredAction) {
        row.add(registeredAction.description, {
          hl: helpHightlights.description
        });
      }
    });
  }
  async drawMappingsActionExp(indent, actionExp, ctx) {
    if (Array.isArray(actionExp)) {
      for (let i2 = 0; i2 < actionExp.length; i2++) {
        const action = actionExp[i2];
        if (Array.isArray(action)) {
          await this.drawMappingsActionExp(indent, action, ctx);
          continue;
        }
        if (action.name === waitAction.name) {
          if (ctx.isFirstLine) {
            ctx.isWait = true;
          }
          continue;
        }
        const rule = conditionActionRules[action.name];
        if (rule) {
          await this.drawRow((row) => {
            this.drawMappingsPrefix(indent, row, ctx);
            row.add(`if ${rule.getHelpDescription(action.args)}`, {
              hl: helpHightlights.conditional
            });
          });
          const [trueAction, falseAction] = [
            actionExp[i2 + 1],
            actionExp[i2 + 2]
          ];
          await this.drawMappingsActionExp(`${indent}  `, trueAction, ctx);
          await this.drawRow((row) => {
            row.add(indent);
            row.add("else", {
              hl: helpHightlights.conditional
            });
          });
          await this.drawMappingsActionExp(`${indent}  `, falseAction, ctx);
          i2 += 2;
          continue;
        }
        await this.drawMappingsAction(indent, action, ctx);
      }
    } else {
      await this.drawMappingsAction(indent, actionExp, ctx);
    }
  }
  async drawMappings() {
    await this.drawRow((row) => {
      row.add(`Mappings for source(${this.source.sourceType})`, {
        hl: helpHightlights.title
      });
    });
    const drawMappings = async (mappings3) => {
      for (const [key, actionExp] of Object.entries(mappings3)) {
        if (!this.anyAction(
          actionExp,
          (action) => this.registeredActions.has(action.name) || action.name === noopAction.name
        )) {
          continue;
        }
        await this.drawMappingsActionExp(
          " ".repeat(key.length + 4),
          actionExp,
          {
            key,
            isFirstLine: true,
            isWait: false
          }
        );
      }
    };
    const mappings2 = await keyMapping.getMappings(this.source.sourceType);
    await drawMappings(mappings2.all);
    await drawMappings(mappings2.vmap);
  }
  async drawActions() {
    await this.drawRow((row) => {
      row.add(`Actions for source(${this.source.sourceType})`, {
        hl: helpHightlights.title
      });
    });
    for (const [name, action] of this.registeredActions) {
      await this.drawRow((row) => {
        row.add(" ");
        row.add(name, { hl: helpHightlights.action });
        row.add(" ");
        row.add(action.description, { hl: helpHightlights.description });
      });
      if (action.options.args) {
        await this.drawRow((row) => {
          row.add("   ");
          row.add("args:", { hl: helpHightlights.subtitle });
        });
        for (const arg of action.options.args) {
          await this.drawRow((row) => {
            row.add("     - ");
            row.add(arg.name, { hl: helpHightlights.arg });
            if (arg.description) {
              row.add(" ");
              row.add(arg.description, { hl: helpHightlights.description });
            }
          });
        }
      }
      if (action.options.menus) {
        await this.drawRow((row) => {
          row.add("   ");
          row.add("menus:", { hl: helpHightlights.subtitle });
        });
        for (const menu of ActionMenu.getNormalizeMenus(action.options.menus)) {
          await this.drawRow((row) => {
            row.add("     - ");
            row.add(`${name}:${menu.args}`, { hl: helpHightlights.action });
            row.add(" ");
            row.add(menu.description, { hl: helpHightlights.description });
          });
        }
      }
    }
  }
  async drawColumns() {
    await this.drawRow((row) => {
      row.add(`Columns for source(${this.source.sourceType})`, {
        hl: helpHightlights.title
      });
    });
    const allColumns = this.source.view.sourcePainters.columnRegistrar.registeredColumns;
    for (const [type, columns] of allColumns) {
      await this.drawRow((row) => {
        row.add(`  Type: ${type}`, { hl: helpHightlights.subtitle });
      });
      for (const [name] of columns) {
        await this.drawRow((row) => {
          row.add("   - ");
          row.add(name, { hl: helpHightlights.column });
        });
      }
    }
  }
  async render() {
    import_coc39.workspace.nvim.pauseNotification();
    this.explorer.setLinesNotifier(
      this.drawnResults.map((n) => n.content),
      0,
      -1
    ).notify();
    const highlightPositions = [];
    for (const [i2, drawn] of this.drawnResults.entries()) {
      if (drawn.highlightPositions) {
        highlightPositions.push(
          ...drawn.highlightPositions.map((hl) => ({
            lineIndex: i2,
            ...hl
          }))
        );
      }
    }
    this.explorer.highlight.addHighlightsNotify(
      helpHlSrcId,
      highlightPositions
    );
    await import_coc39.workspace.nvim.resumeNotification();
  }
};
async function showHelp(explorer, source) {
  var _a;
  explorer.view.isHelpUI = true;
  const storeNode = await explorer.view.currentNode();
  const width = await ((_a = await explorer.win) == null ? void 0 : _a.width) ?? 80;
  const helpPainter = new HelpPainter(explorer, source, width);
  await helpPainter.drawHead();
  await helpPainter.drawMappings();
  await helpPainter.drawHr();
  await helpPainter.drawActions();
  await helpPainter.drawHr();
  await helpPainter.drawColumns();
  await helpPainter.render();
  await clearMappings();
  const disposables = [];
  ["<esc>", "q", "?"].forEach((key) => {
    disposables.push(
      import_coc39.workspace.registerLocalKeymap(
        "n",
        key,
        async () => {
          (0, import_coc39.disposeAll)(disposables);
          await quitHelp(explorer);
          await explorer.view.sync(async (r) => {
            await Notifier.runAll([
              await r.renderAllNotifier(),
              await source.locator.gotoNodeNotifier(storeNode)
            ]);
          });
        },
        true
      )
    );
  });
}
async function quitHelp(explorer) {
  await executeMappings();
  explorer.view.isHelpUI = false;
}

// src/highlight/highlightExplorer.ts
var import_coc40 = require("coc.nvim");
var HighlightExplorer = class {
  constructor(explorer) {
    this.explorer = explorer;
  }
  clearHighlightsNotify(hlSrcId, lineStart, lineEnd) {
    hlGroupManager.clearHighlightsNotify(
      this.explorer,
      hlSrcId,
      lineStart,
      lineEnd
    );
  }
  addHighlightsNotify(hlSrcId, highlights) {
    hlGroupManager.addHighlightsNotify(this.explorer, hlSrcId, highlights);
  }
  async bootSyntax() {
    const winnr = await this.explorer.winnr;
    const curWinnr = await import_coc40.workspace.nvim.call("winnr");
    if (winnr) {
      import_coc40.workspace.nvim.pauseNotification();
      if (winnr !== curWinnr) {
        import_coc40.workspace.nvim.command(`${winnr}wincmd w`, true);
      }
      hlGroupManager.bootHighlightSyntaxNotify();
      if (winnr !== curWinnr) {
        import_coc40.workspace.nvim.command(`${curWinnr}wincmd w`, true);
      }
      await import_coc40.workspace.nvim.resumeNotification();
    }
  }
};

// src/locator/locatorExplorer.ts
var import_coc41 = require("coc.nvim");

// src/locator/markExplorer.ts
var MarkExplorer = class {
  constructor(explorer) {
    this.explorer = explorer;
    this.marksGroupByType = /* @__PURE__ */ new Map();
  }
  add(type, lineIndex) {
    if (!this.marksGroupByType.has(type)) {
      this.marksGroupByType.set(type, /* @__PURE__ */ new Set());
    }
    const lines = this.marksGroupByType.get(type);
    lines.add(lineIndex);
  }
  remove(type, lineIndex) {
    if (!this.marksGroupByType.has(type)) {
      this.marksGroupByType.set(type, /* @__PURE__ */ new Set());
    }
    const lines = this.marksGroupByType.get(type);
    lines.delete(lineIndex);
  }
  removeAll() {
    this.marksGroupByType.clear();
  }
  removeLines(startLineOrLines, endLine = Infinity) {
    if (Array.isArray(startLineOrLines)) {
      this.marksGroupByType.forEach((lines) => {
        startLineOrLines.forEach((line) => {
          lines.delete(line);
        });
      });
    } else {
      const startLine = startLineOrLines;
      this.marksGroupByType.forEach((lines) => {
        lines.forEach((line) => {
          if (startLine <= line && line <= endLine) {
            lines.delete(line);
          }
        });
      });
    }
  }
  offsetLines(offset, startLine, endLine = Infinity) {
    if (offset === 0) {
      return;
    }
    this.marksGroupByType.forEach((lines, name) => {
      const newLines = /* @__PURE__ */ new Set();
      lines.forEach((line) => {
        newLines.add(
          startLine <= line && line <= endLine ? line + offset : line
        );
      });
      this.marksGroupByType.set(name, newLines);
    });
  }
  async prevLineIndex(...names) {
    let mergeLines = [];
    for (const name of names) {
      const lines = this.marksGroupByType.get(name);
      mergeLines = mergeLines.concat(lines ? Array.from(lines) : []);
    }
    if (mergeLines.length) {
      const curLine = this.explorer.view.currentLineIndex;
      const sortedLines = mergeLines.sort((a3, b2) => b2 - a3);
      const prevLine = sortedLines.find((line) => line < curLine);
      if (prevLine) {
        return prevLine;
      } else if (await enableWrapscan()) {
        return sortedLines[0];
      }
    }
  }
  async nextLineIndex(...names) {
    let mergeLines = [];
    for (const name of names) {
      const lines = this.marksGroupByType.get(name);
      mergeLines = mergeLines.concat(lines ? Array.from(lines) : []);
    }
    if (mergeLines.length) {
      const curLine = this.explorer.view.currentLineIndex;
      const sortedLines = mergeLines.sort((a3, b2) => a3 - b2);
      const nextLine = sortedLines.find((line) => line > curLine);
      if (nextLine) {
        return nextLine;
      } else if (await enableWrapscan()) {
        return sortedLines[0];
      }
    }
  }
};

// src/locator/locatorExplorer.ts
var LocatorExplorer = class {
  constructor(explorer) {
    this.explorer = explorer;
    this.mark = new MarkExplorer(this.explorer);
    this.view = this.explorer.view;
  }
  async gotoPrevMark(...names) {
    const lineIndex = await this.mark.prevLineIndex(...names);
    if (lineIndex) {
      await this.gotoLineIndex(lineIndex);
      return true;
    }
    return false;
  }
  async gotoNextMark(...names) {
    const lineIndex = await this.mark.nextLineIndex(...names);
    if (lineIndex) {
      await this.gotoLineIndex(lineIndex);
      return true;
    }
    return false;
  }
  async gotoLineIndex(lineIndex) {
    return (await this.gotoLineIndexNotifier(lineIndex)).run();
  }
  async gotoLineIndexNotifier(lineIndex, col) {
    const win = await this.explorer.win;
    return Notifier.create(() => {
      if (win) {
        const height = this.explorer.height;
        if (lineIndex < 0) {
          lineIndex = 0;
        } else if (lineIndex >= height) {
          lineIndex = height - 1;
        }
        this.view.currentLineIndex = lineIndex;
        win.setCursor([lineIndex + 1, col ?? 0], true);
        if (import_coc41.workspace.isVim) {
          import_coc41.workspace.nvim.command("redraw", true);
        } else {
          import_coc41.workspace.nvim.command("redraw!", true);
        }
      }
    });
  }
};

// src/highlight/internalColors.ts
var import_coc43 = require("coc.nvim");

// src/highlight/extractColors.ts
var import_coc42 = require("coc.nvim");
async function extractHighlightsColor(highlightGroups) {
  const hlColorStrs = await import_coc42.workspace.nvim.call("coc_explorer#highlight#extract_colors", [
    highlightGroups
  ]);
  return Object.entries(hlColorStrs).map(([group, hl]) => {
    const newHl = {};
    if (hl.ctermfg) {
      newHl.ctermfg = hl.ctermfg;
    }
    if (hl.ctermbg) {
      newHl.ctermbg = hl.ctermbg;
    }
    if (hl.guifg) {
      newHl.guifg = parseColor(hl.guifg);
    }
    if (hl.guibg) {
      newHl.guibg = parseColor(hl.guibg);
    }
    return [group, newHl];
  }).reduce((ret, [group, hl]) => {
    ret[group] = hl;
    return ret;
  }, {});
}

// src/highlight/internalColors.ts
var groupConfigs = {
  Error: "ErrorColor",
  Comment: "CommentColor",
  Normal: "NormalColor",
  CocErrorSign: "CocErrorSignColor",
  CocWarningSign: "CocWarningSignColor"
};
var registerInternalColors = (disposables) => {
  hlGroupManager.watchColorScheme(disposables, async () => {
    const groups = Object.keys(groupConfigs);
    const highlights = await extractHighlightsColor(groups);
    const { nvim } = import_coc43.workspace;
    nvim.pauseNotification();
    for (const group of groups) {
      const hl = highlights[group];
      const cmd = generateHighlightFg(
        `CocExplorer${groupConfigs[group]}_Internal`,
        hl
      );
      if (!cmd) {
        continue;
      }
      nvim.command(cmd, true);
    }
    await nvim.resumeNotification();
  }).catch(logger.error);
};
var internalHighlightGroups = {};
Object.values(groupConfigs).forEach((group) => {
  internalHighlightGroups[group] = `CocExplorer${group}_Internal`;
});

// src/view/viewSource.ts
var import_coc46 = require("coc.nvim");

// src/source/sourcePainters.ts
var import_p_filter = __toESM(require_p_filter());

// src/parser/parser.ts
var ParserSource = class {
  constructor(s3, i2) {
    this.s = s3;
    this.i = i2;
  }
  ch() {
    return this.s[this.i];
  }
  skip(n) {
    this.i += n;
  }
  next() {
    this.i += 1;
  }
  forwardString(length) {
    return this.s.slice(this.i, this.i + length);
  }
  match(str, options = {}) {
    if (this.forwardString(str.length) === str) {
      if (options.skip ?? false) {
        this.skip(str.length);
      }
      return true;
    }
    return false;
  }
  end() {
    return this.i >= this.s.length;
  }
};
var ParserError = class extends Error {
  constructor(source, message) {
    super(message);
    this.source = source;
  }
};

// src/source/parseTemplate.ts
function parseKeyword(name, s3, endWith) {
  let keyword = "";
  while (!s3.end()) {
    const ch = s3.ch();
    if (!endWith.includes(ch)) {
      keyword += ch;
      s3.next();
    } else {
      return keyword;
    }
  }
  throw new ParserError(s3, `Unexpected end when parse ${name}`);
}
function parseModifierName(s3) {
  return parseKeyword("modifier name", s3, [" "]);
}
function parseModifierColumn(s3) {
  return parseKeyword("modifier value", s3, [" ", "]"]);
}
function parseModifier(s3) {
  const name = parseModifierName(s3);
  s3.next();
  const column = parseModifierColumn(s3);
  return { name, column };
}
function parseModifiers(s3) {
  const modifiers = [];
  do {
    const ch = s3.ch();
    if (ch === " ") {
      s3.next();
      modifiers.push(parseModifier(s3));
    } else if (ch === "]") {
      return modifiers;
    }
  } while (true);
}
function parseColumnName(s3) {
  return parseKeyword("column name", s3, [" ", "]"]);
}
function parseColumn(s3) {
  s3.next();
  const parsedColumn = {
    column: parseColumnName(s3)
  };
  do {
    const ch = s3.ch();
    if (ch === "]") {
      s3.next();
      return parsedColumn;
    } else if (ch === " ") {
      parsedColumn.modifiers = parseModifiers(s3);
    }
  } while (!s3.end());
  throw new ParserError(s3, "Unexpected end when parse column block");
}
function parsePlainString(s3) {
  let str = "";
  while (!s3.end()) {
    const ch = s3.ch();
    if (ch === "\\") {
      s3.next();
      str += s3.ch();
    } else if (ch === "[") {
      return str;
    } else {
      str += ch;
    }
    s3.next();
  }
  return str;
}
function parseTemplate(str) {
  const s3 = new ParserSource(str, 0);
  const parts = [];
  while (!s3.end()) {
    const ch = s3.ch();
    if (ch === "[") {
      parts.push(parseColumn(s3));
    } else {
      parts.push(parsePlainString(s3));
    }
  }
  return parts;
}

// src/source/sourcePainters.ts
var labelHighlight = hlGroupManager.linkGroup("Label", "Label");
var SourcePainter = class {
  constructor(type, painters, source, columnRegistrar) {
    this.type = type;
    this.painters = painters;
    this.source = source;
    this.columnRegistrar = columnRegistrar;
    this.columns = /* @__PURE__ */ new Set();
    this.parts = [];
    this.labelingParts = [];
  }
  dispose() {
    this.clearParts(this.parts);
  }
  clearColumn(column) {
    if (typeof column !== "number") {
      column.subscriptions.map((s3) => s3.dispose());
    }
  }
  clearParts(parts) {
    parts.forEach((part) => {
      var _a;
      if (typeof part !== "string") {
        this.clearColumn(part.column);
        (_a = part.modifiers) == null ? void 0 : _a.forEach((m3) => this.clearColumn(m3.column));
      }
    });
  }
  async parseTemplate(template, labelingTemplate) {
    let needUpdateColumns = false;
    if (this.templateStr !== template) {
      this.templateStr = template;
      const initedParts = [];
      for (const parsedPart of parseTemplate(template)) {
        const part = await this.initPart(parsedPart);
        if (part) {
          initedParts.push(part);
        }
      }
      this.clearParts(this.parts);
      this.parts = initedParts;
      needUpdateColumns = true;
    }
    if (labelingTemplate) {
      if (this.labelingTemplateStr !== labelingTemplate) {
        this.labelingTemplateStr = labelingTemplate;
        const initedLabelingParts = [];
        for (const parsedPart of parseTemplate(labelingTemplate)) {
          const part = await this.initPart(parsedPart);
          if (part) {
            initedLabelingParts.push(part);
          }
        }
        this.clearParts(this.labelingParts);
        this.labelingParts = initedLabelingParts;
        needUpdateColumns = true;
      }
    }
    if (needUpdateColumns) {
      const columnSet = /* @__PURE__ */ new Set();
      const initedParts = [...this.parts, ...this.labelingParts];
      for (const item of initedParts) {
        if (typeof item !== "string") {
          if (typeof item.column !== "number") {
            columnSet.add(item.column);
          }
          if (item.modifiers) {
            for (const modifier of item.modifiers) {
              if (typeof modifier.column !== "number") {
                columnSet.add(modifier.column);
              }
            }
          }
        }
      }
      this.columns = columnSet;
    }
  }
  async initPart(part) {
    if (typeof part === "string") {
      return part;
    }
    const column = await this.columnRegistrar.initColumn(
      this.type,
      this.source,
      part.column
    );
    if (!column) {
      return void 0;
    }
    const block = {
      column
    };
    if (part.modifiers) {
      const modifiers = await Promise.all(
        part.modifiers.map(async (modifier) => {
          const column2 = await this.columnRegistrar.initColumn(
            this.type,
            this.source,
            modifier.column
          );
          if (!column2) {
            return void 0;
          }
          return {
            name: modifier.name,
            column: column2
          };
        })
      );
      block.modifiers = compactI2(modifiers);
    }
    return block;
  }
};
var SourcePainters = class {
  constructor(source, columnRegistrar) {
    this.source = source;
    this.columnRegistrar = columnRegistrar;
    this.painters = /* @__PURE__ */ new Map();
    this.viewPainter = new ViewPainter(this.source.explorer);
  }
  dispose() {
    this.painters.forEach((painter) => painter.dispose());
  }
  getPainter(type) {
    if (!this.painters.has(type)) {
      this.painters.set(
        type,
        new SourcePainter(type, this, this.source, this.columnRegistrar)
      );
    }
    return this.painters.get(type);
  }
  async parseTemplate(type, template, labelingTemplate) {
    return await this.getPainter(type).parseTemplate(
      template,
      labelingTemplate
    );
  }
  async load(parentNode) {
    for (const painter of this.painters.values()) {
      for (const column of painter.columns) {
        await (column.load && column.load(parentNode));
      }
    }
  }
  async drawPre(nodes, {
    draw,
    drawAll,
    abort,
    force = false
  } = {}) {
    class DrawAll extends Error {
    }
    class Abort extends Error {
    }
    const nodesGroup = groupBy_default(nodes, (n) => n.type);
    const types = Object.keys(nodesGroup);
    for (const type of types) {
      const painter = this.getPainter(type);
      for (const column of painter.columns) {
        try {
          column.drawHandle = await column.draw(nodesGroup[type], {
            drawAll() {
              if (drawAll) {
                throw new DrawAll();
              }
            },
            abort() {
              throw new Abort();
            },
            force
          });
        } catch (err) {
          if (err instanceof DrawAll) {
            return drawAll();
          } else if (err instanceof Abort) {
            if (abort) {
              return abort();
            }
          } else {
            throw err;
          }
        }
      }
    }
    return draw == null ? void 0 : draw();
  }
  async drawNode(node, nodeIndex, {
    isLabeling = false
  } = {}) {
    const row = await this.viewPainter.drawRow(async (row2) => {
      for (const part of this.getPainter(node.type).parts) {
        await row2.addTemplatePart(node, nodeIndex, part, isLabeling);
      }
    });
    const drawn = await row.draw();
    return {
      nodeIndex,
      nodeUid: node.uid,
      content: drawn.content,
      highlightPositions: drawn.highlightPositions
    };
  }
  async drawNodeLabeling(node, nodeIndex) {
    var _a;
    const drawnList = [];
    for (const part of this.getPainter(node.type).labelingParts) {
      if (typeof part === "string") {
        drawnList.push({
          content: part,
          highlightPositions: []
        });
        continue;
      }
      const columns = [
        part.column,
        ...((_a = part.modifiers) == null ? void 0 : _a.map((m3) => m3.name === "&" ? m3.column : "")) ?? []
      ].filter((c2) => typeof c2 !== "string");
      const visibleColumns = await (0, import_p_filter.default)(
        columns,
        async (c2) => {
          var _a2;
          return !((_a2 = c2.drawHandle) == null ? void 0 : _a2.labelVisible) || await c2.drawHandle.labelVisible({ node, nodeIndex });
        }
      );
      if (!visibleColumns.length) {
        continue;
      }
      const isAllLabelOnly = visibleColumns.every(
        (c2) => {
          var _a2;
          return (_a2 = c2.drawHandle) == null ? void 0 : _a2.labelOnly;
        }
      );
      const contentColumns = visibleColumns.filter(
        async (c2) => {
          var _a2;
          return !((_a2 = c2.drawHandle) == null ? void 0 : _a2.labelOnly);
        }
      );
      const row = await this.viewPainter.drawRow(async (row2) => {
        row2.add(
          visibleColumns.map((column) => column.label).join(" & ") + (isAllLabelOnly ? "" : ":"),
          { hl: labelHighlight }
        );
        row2.add(" ");
        for (const column of contentColumns) {
          await row2.addColumn(node, nodeIndex, column, true);
        }
      });
      const { highlightPositions, content } = await row.draw({
        flexible: false
      });
      drawnList.push({
        content,
        highlightPositions
      });
    }
    return drawnList;
  }
};

// src/view/rendererExplorer.ts
var import_coc45 = require("coc.nvim");

// src/view/rendererSource.ts
var import_coc44 = require("coc.nvim");
var rendererSourceSymbol = Symbol("rendererSource");
var RendererSource = class {
  constructor(view, explorer = view.explorer, source = view.source) {
    this.view = view;
    this.explorer = explorer;
    this.source = source;
    this.requestedRenderNodes = /* @__PURE__ */ new Set();
  }
  nodeAndChildrenRange(node) {
    const startIndex = this.view.flattenedNodes.findIndex(
      (it) => it.uid === node.uid
    );
    if (startIndex === -1) {
      return;
    }
    const parentLevel = node.level ?? 0;
    let endIndex = this.view.flattenedNodes.length - 1;
    for (let i2 = startIndex + 1, len = this.view.flattenedNodes.length; i2 < len; i2++) {
      if ((this.view.flattenedNodes[i2].level ?? 0) <= parentLevel) {
        endIndex = i2 - 1;
        break;
      }
    }
    return { startIndex, endIndex };
  }
  async drawNodes(nodes) {
    const drawnList = compactI2(
      await Promise.all(
        nodes.map(async (node) => {
          const nodeIndex = this.view.flattenedNodes.findIndex(
            (it) => it.uid === node.uid
          );
          if (nodeIndex < 0) {
            return;
          }
          const finalNode = this.view.flattenedNodes[nodeIndex];
          if (!finalNode) {
            return;
          }
          return this.view.sourcePainters.drawNode(finalNode, nodeIndex);
        })
      )
    );
    const startLineIndex = this.view.startLineIndex;
    return {
      drawnList,
      get contents() {
        return drawnList.map((d3) => d3.content);
      },
      get highlightPositions() {
        return flatten_default(
          drawnList.map(
            (d3) => d3.highlightPositions.map((hl) => ({
              lineIndex: startLineIndex + d3.nodeIndex,
              ...hl
            }))
          )
        );
      }
    };
  }
  async emitRequestRenderNodesNotifier() {
    if (this.requestedRenderNodes.size <= 0) {
      return;
    }
    const nodes = Array.from(this.requestedRenderNodes);
    this.requestedRenderNodes.clear();
    return this.renderNodesNotifier(nodes);
  }
  async renderPathsNotifier(paths) {
    if (this.view.isHelpUI) {
      return Notifier.noop();
    }
    const pathArr = paths instanceof Set ? Array.from(paths) : paths;
    if (!pathArr.length) {
      return Notifier.noop();
    }
    const getNodes = (paths2) => this.view.flattenedNodes.filter(
      (n) => n.fullpath && paths2.includes(n.fullpath)
    );
    const renderNodes = pathArr.map(
      (o) => {
        if (typeof o === "string") {
          return {
            nodes: getNodes([o])
          };
        } else {
          return {
            nodes: getNodes([...o.paths]),
            withParents: o.withParents,
            withChildren: o.withChildren
          };
        }
      }
    );
    return this.renderNodesNotifier(renderNodes);
  }
  async renderNodesNotifier(nodes) {
    const nodeArr = nodes instanceof Set ? Array.from(nodes) : nodes;
    const nodeItems = nodeArr.map((o) => {
      if ("uid" in o) {
        return {
          nodes: [o],
          withParents: false,
          withChildren: false
        };
      } else {
        return {
          nodes: [...o.nodes],
          withParents: o.withParents ?? false,
          withChildren: o.withChildren ?? false
        };
      }
    });
    const finalNodes = [];
    for (const node of nodeItems) {
      finalNodes.push(...node.nodes);
      if (node.withParents) {
        for (const n of node.nodes) {
          finalNodes.push(...this.view.flattenParents(n));
        }
      }
      if (node.withChildren) {
        for (const n of node.nodes) {
          finalNodes.push(...this.view.flattenNode(n));
        }
      }
    }
    if (!finalNodes.length) {
      return Notifier.noop();
    }
    return await this.view.sourcePainters.drawPre(finalNodes, {
      draw: async () => {
        const { drawnList, highlightPositions } = await this.drawNodes(
          finalNodes
        );
        const drawnRangeList = drawnWithIndexRange(drawnList);
        await this.source.events.fire("drawn");
        return Notifier.create(() => {
          drawnRangeList.forEach((dr) => {
            this.view.setLinesNotifier(
              dr.drawnList.map((d3) => d3.content),
              dr.nodeIndexStart,
              dr.nodeIndexEnd + 1
            ).notify();
          });
          this.source.highlight.addHighlightsNotify(highlightPositions);
          if (import_coc44.workspace.isVim) {
            import_coc44.workspace.nvim.command("redraw", true);
          }
        });
      },
      drawAll: () => this.renderNotifier(),
      abort: () => Notifier.noop()
    });
  }
  async renderNotifier({
    node = this.view.rootNode,
    force = false
  } = {}) {
    if (this.view.isHelpUI) {
      return Notifier.noop();
    }
    const range = this.nodeAndChildrenRange(node);
    if (!range && !node.isRoot) {
      return Notifier.noop();
    }
    const { startIndex: nodeIndex, endIndex } = range ? range : { startIndex: 0, endIndex: this.view.flattenedNodes.length - 1 };
    const oldHeight = endIndex - nodeIndex + 1;
    const needDrawNodes = this.view.flattenNode(node);
    const newHeight = needDrawNodes.length;
    this.view.flattenedNodes = this.view.flattenedNodes.slice(0, nodeIndex).concat(needDrawNodes).concat(this.view.flattenedNodes.slice(endIndex + 1));
    if (newHeight < oldHeight) {
      this.explorer.locator.mark.removeLines(
        this.view.startLineIndex + newHeight + 1,
        this.view.startLineIndex + oldHeight + 1
      );
    }
    this.source.locator.mark.offsetAfterLine(
      newHeight - oldHeight,
      this.view.endLineIndex
    );
    await this.view.sourcePainters.drawPre(needDrawNodes, { force });
    const { contents, highlightPositions } = await this.drawNodes(
      needDrawNodes
    );
    await this.source.events.fire("drawn");
    const sourceIndex = this.view.currentSourceIndex();
    const isLastSource = this.explorer.sources.length - 1 === sourceIndex;
    return Notifier.create(() => {
      this.explorer.setLinesNotifier(
        contents,
        this.view.startLineIndex + nodeIndex,
        isLastSource && node.isRoot ? -1 : this.view.startLineIndex + nodeIndex + oldHeight
      ).notify();
      this.source.highlight.addHighlightsNotify(highlightPositions);
      if (import_coc44.workspace.isVim) {
        import_coc44.workspace.nvim.command("redraw", true);
      }
    });
  }
};

// src/view/rendererExplorer.ts
var rendererExplorerSymbol = Symbol("rendererExplorer");
var RendererExplorer = class {
  constructor(view, explorer = view.explorer) {
    this.view = view;
    this.explorer = explorer;
    this.renderMutex = new import_coc45.Mutex();
  }
  async runQueue(fn) {
    let release = await this.renderMutex.acquire();
    setTimeout(() => {
      if (release) {
        release();
        release = void 0;
        logger.error(
          "view.sync timeout, force render, view.sync may cause deadlock due to recursive calls"
        );
      }
    }, 5e3);
    try {
      return await fn();
    } finally {
      release();
      release = void 0;
    }
  }
  rendererSources() {
    return this.explorer.sources.map((s3) => s3.view[rendererSourceSymbol]);
  }
  async renderAllNotifier() {
    const notifiers = await Promise.all(
      this.rendererSources().map((s3) => s3.renderNotifier({ force: true }))
    );
    return Notifier.combine(notifiers);
  }
};

// src/view/viewNodeStores.ts
var ViewNodeStores = class {
  constructor(viewSource) {
    this.viewSource = viewSource;
    this.internal = (() => {
      const internal = {
        records: /* @__PURE__ */ new Map(),
        store(node) {
          if (!internal.records.has(node.uid)) {
            internal.records.set(node.uid, {
              expanded: false,
              compact: "uncompact"
            });
          }
          return internal.records.get(node.uid);
        },
        clear() {
          internal.records.clear();
        },
        get(node, key) {
          return internal.store(node)[key];
        },
        set(node, key, value) {
          internal.store(node)[key] = value;
        }
      };
      return internal;
    })();
    const context2 = viewSource.source.context;
    const stores = viewSource.config.get("expandStores") ?? true;
    if (typeof stores === "boolean") {
      this.enabled = stores;
    } else if ("includes" in stores) {
      this.enabled = stores.includes.includes(
        this.viewSource.source.sourceType
      );
    } else if ("excludes" in stores) {
      this.enabled = !stores.excludes.includes(
        this.viewSource.source.sourceType
      );
    } else {
      this.enabled = true;
    }
    context2.subscriptions.push(
      viewSource.source.explorer.events.on("open-pre", () => {
        if (!this.enabled) {
          this.internal.clear();
        }
      })
    );
  }
  setExpanded(node, expanded) {
    expanded ? this.expand(node) : this.collapse(node);
  }
  expand(node) {
    this.internal.set(node, "expanded", true);
  }
  collapse(node) {
    this.internal.set(node, "expanded", false);
  }
  isExpanded(node) {
    return this.internal.get(node, "expanded");
  }
  setCompact(node, compact) {
    this.internal.set(node, "compact", compact);
  }
  getCompact(node) {
    return this.internal.get(node, "compact");
  }
};

// src/view/viewSource.ts
var ViewSource = class {
  constructor(source, columnRegistrar, rootNode) {
    this.source = source;
    this.columnRegistrar = columnRegistrar;
    this.rootNode = rootNode;
    this.flattenedNodes = [];
    this.startLineIndex = 0;
    this.endLineIndex = 0;
    this.rootExpandedForOpen = false;
    this.explorer = this.source.explorer;
    this.nodeStores = new ViewNodeStores(this);
    this.sourcePainters = new SourcePainters(
      this.source,
      this.columnRegistrar
    );
    this[rendererSourceSymbol] = new RendererSource(this);
  }
  get isHelpUI() {
    return this.explorer.view.isHelpUI;
  }
  get config() {
    return this.source.config;
  }
  async sync(block) {
    return await this.explorer.view[rendererExplorerSymbol].runQueue(
      () => block(this[rendererSourceSymbol])
    );
  }
  requestRenderNodes(nodes) {
    for (const node of nodes) {
      this[rendererSourceSymbol].requestedRenderNodes.add(node);
    }
  }
  dispose() {
    this.sourcePainters.dispose();
  }
  bootInit(rootExpandedForOpen) {
    this.rootExpandedForOpen = rootExpandedForOpen;
  }
  bootOpen() {
    this.nodeStores.setExpanded(this.rootNode, this.rootExpandedForOpen);
  }
  async load(node) {
    await this.sourcePainters.load(node);
  }
  async parseTemplate(type, template, labelingTemplate) {
    return await this.sourcePainters.parseTemplate(
      type,
      template,
      labelingTemplate
    );
  }
  get currentLineIndex() {
    return this.explorer.view.currentLineIndex - this.startLineIndex;
  }
  currentNode() {
    return this.flattenedNodes[this.currentLineIndex];
  }
  currentSourceIndex() {
    const indexOf = this.explorer.sources.indexOf(this.source);
    return indexOf === -1 ? void 0 : indexOf;
  }
  getNodeByLine(lineIndex) {
    return this.flattenedNodes[lineIndex];
  }
  getLineByNode(node) {
    if (node) {
      const line = this.flattenedNodes.findIndex((it) => it.uid === node.uid);
      return line === -1 ? void 0 : line;
    } else {
      return 0;
    }
  }
  setLinesNotifier(lines, startIndex, endIndex) {
    return this.explorer.setLinesNotifier(
      lines,
      this.startLineIndex + startIndex,
      this.startLineIndex + endIndex
    );
  }
  replaceNodeInSibling(oldNode, newNode) {
    var _a;
    if ((_a = oldNode.parent) == null ? void 0 : _a.children) {
      const index = oldNode.parent.children.indexOf(oldNode);
      if (index !== -1) {
        oldNode.parent.children.splice(index, 1, newNode);
        newNode.level = oldNode.level;
        newNode.parent = oldNode.parent;
        newNode.prevSiblingNode = oldNode.prevSiblingNode;
        newNode.nextSiblingNode = oldNode.nextSiblingNode;
      }
    }
  }
  flattenParents(node) {
    let currentNode = node;
    const result = [];
    while (true) {
      if (currentNode.parent) {
        result.push(currentNode.parent);
        currentNode = currentNode.parent;
      } else {
        break;
      }
    }
    return result;
  }
  flattenNode(node) {
    var _a, _b;
    const result = [];
    const stack = [node];
    while (stack.length) {
      let node2 = stack.shift();
      if (!node2.isRoot) {
        const compactStatus = this.nodeStores.getCompact(node2);
        if (compactStatus === "compact") {
          if (!node2.compactedNodes && ((_a = node2.children) == null ? void 0 : _a.length) === 1 && node2.children[0].expandable) {
            let tail = node2.children[0];
            const compactedNodes = [node2, tail];
            while (((_b = tail.children) == null ? void 0 : _b.length) === 1 && tail.children[0].expandable) {
              this.nodeStores.setCompact(tail, "compact");
              tail = tail.children[0];
              compactedNodes.push(tail);
            }
            this.nodeStores.setCompact(tail, "compact");
            const compactedNode = clone_default(tail);
            compactedNode.name = compactedNodes.map((n) => n.name).join("/");
            compactedNode.compactedNodes = compactedNodes;
            compactedNode.compactedLastNode = tail;
            this.replaceNodeInSibling(node2, compactedNode);
            node2 = compactedNode;
          }
        } else if (compactStatus === "uncompact") {
          if (node2.compactedNodes) {
            const topNode = node2.compactedNodes[0];
            for (const n of node2.compactedNodes) {
              this.nodeStores.setCompact(n, "uncompact");
            }
            this.replaceNodeInSibling(node2, topNode);
            node2 = topNode;
          }
        }
      }
      result.push(node2);
      if (node2.children) {
        for (let i2 = node2.children.length - 1; i2 >= 0; i2--) {
          node2.children[i2].parent = node2;
          node2.children[i2].level = (node2.level ?? 0) + 1;
          stack.unshift(node2.children[i2]);
        }
      }
    }
    return result;
  }
  isExpanded(node) {
    return this.nodeStores.isExpanded(node);
  }
  async expandRender(node) {
    if (this.isHelpUI) {
      return;
    }
    if (!this.isExpanded(node) || !node.children) {
      return;
    }
    await this.sync(async (r) => {
      const range = r.nodeAndChildrenRange(node);
      if (!range) {
        return;
      }
      const { startIndex, endIndex } = range;
      const needDrawNodes = this.flattenNode(node);
      await this.sourcePainters.drawPre(needDrawNodes, {
        draw: async () => {
          this.flattenedNodes = this.flattenedNodes.slice(0, startIndex).concat(needDrawNodes).concat(this.flattenedNodes.slice(endIndex + 1));
          this.source.locator.mark.offsetAfterLine(
            needDrawNodes.length - 1 - (endIndex - startIndex),
            startIndex
          );
          const { contents, highlightPositions } = await r.drawNodes(
            needDrawNodes
          );
          await this.source.events.fire("drawn");
          import_coc46.workspace.nvim.pauseNotification();
          this.setLinesNotifier(contents, startIndex, endIndex + 1).notify();
          this.source.highlight.addHighlightsNotify(highlightPositions);
          if (import_coc46.workspace.isVim) {
            import_coc46.workspace.nvim.command("redraw", true);
          }
          await import_coc46.workspace.nvim.resumeNotification();
        },
        drawAll: async () => (await r.renderNotifier()).run()
      });
    });
  }
  async expandRecursive(node, options) {
    const autoExpandOptions = this.config.get("autoExpandOptions") ?? [
      "compact",
      "uncompact"
    ];
    const compact = options.compact ?? autoExpandOptions.includes("compact");
    const uncompact = options.uncompact ?? autoExpandOptions.includes("uncompact");
    const recursiveSingle = options.recursiveSingle ?? (autoExpandOptions.includes("recursiveSingle") || compact);
    if (node.expandable) {
      const depth = options.depth ?? 1;
      const isExpanded = this.isExpanded(node);
      this.nodeStores.expand(node);
      if (!node.children) {
        node.children = await this.source.loadInitedChildren(node, {
          recursiveExpanded: true
        });
      }
      if (depth > this.config.get("autoExpandMaxDepth")) {
        return;
      }
      const singleExpandableNode = node.children.length === 1 && node.children[0].expandable;
      const compactStatus = this.nodeStores.getCompact(node);
      if (compactStatus === "uncompact") {
        if (singleExpandableNode && compact) {
          this.nodeStores.setCompact(node, "compact");
        }
      } else if (compactStatus === "compact") {
        if (isExpanded && uncompact) {
          this.nodeStores.setCompact(node, "uncompact");
        } else {
          this.nodeStores.setCompact(node, "compact");
        }
      }
      if (options.recursive || singleExpandableNode && recursiveSingle) {
        await Promise.all(
          node.children.map(async (child) => {
            await this.expandRecursive(child, {
              ...options,
              depth: depth + 1
            });
          })
        );
      }
    }
  }
  async expand(node, options = {}) {
    await this.expandRecursive(node, options);
    if (options.render ?? true) {
      await this.expandRender(node);
    }
  }
  async collapseRender(node) {
    if (this.isHelpUI || this.isExpanded(node)) {
      return;
    }
    await this.sync(async (r) => {
      const range = r.nodeAndChildrenRange(node);
      if (!range) {
        return;
      }
      await this.sourcePainters.drawPre([node], {
        draw: async () => {
          const { startIndex, endIndex } = range;
          this.flattenedNodes.splice(startIndex + 1, endIndex - startIndex);
          this.explorer.locator.mark.removeLines(
            this.startLineIndex + startIndex + 1,
            this.startLineIndex + endIndex
          );
          this.source.locator.mark.offsetAfterLine(
            -(endIndex - startIndex),
            endIndex
          );
          const gotoNotifier = await this.source.locator.gotoLineIndexNotifier(
            startIndex,
            0
          );
          const { contents, highlightPositions } = await r.drawNodes([node]);
          await this.source.events.fire("drawn");
          import_coc46.workspace.nvim.pauseNotification();
          this.setLinesNotifier(contents, startIndex, endIndex + 1).notify();
          this.source.highlight.addHighlightsNotify(highlightPositions);
          gotoNotifier.notify();
          if (import_coc46.workspace.isVim) {
            import_coc46.workspace.nvim.command("redraw", true);
          }
          await import_coc46.workspace.nvim.resumeNotification();
        },
        drawAll: async () => (await r.renderNotifier()).run()
      });
    });
  }
  async collapseRecursive(node, recursive) {
    if (node.expandable) {
      this.nodeStores.collapse(node);
      const children = node.children;
      if (!children) {
        return;
      }
      node.children = void 0;
      if (recursive || this.config.get("autoCollapseOptions").includes("recursive")) {
        for (const child of children) {
          await this.collapseRecursive(child, recursive);
        }
      }
    }
  }
  async collapse(node, { recursive = false } = {}) {
    await this.collapseRecursive(node, recursive);
    await this.collapseRender(node);
  }
  async renderNodes(nodes) {
    return await this.sync(async (r) => {
      await (await r.renderNodesNotifier(nodes)).run();
    });
  }
  async renderPaths(paths) {
    await this.sync(async (r) => {
      await (await r.renderPathsNotifier(paths)).run();
    });
  }
  async render(options) {
    await this.sync(async (r) => {
      var _a;
      await ((_a = await r.renderNotifier(options)) == null ? void 0 : _a.run());
    });
  }
};
rendererSourceSymbol;

// src/source/source.ts
var import_coc47 = require("coc.nvim");

// src/actions/actionSource.ts
var ActionSource = class extends ActionRegistrar {
  constructor(owner, globalActionRegistrar) {
    super(owner);
    this.owner = owner;
    this.source = this.owner;
    this.global = globalActionRegistrar;
  }
  registeredActions() {
    return new Map([
      ...this.global.actions,
      ...this.actions
    ]);
  }
  registeredAction(name) {
    return this.actions.get(name) || this.global.actions.get(name);
  }
  async doActionExp(actionExp, nodes, options = {}) {
    const mode = options.mode ?? "n";
    const isSubAction = options.isSubAction ?? false;
    let waitRelease;
    let curNodes = nodes;
    const subOptions = {
      mode,
      isSubAction: true
    };
    try {
      if (Array.isArray(actionExp)) {
        for (let i2 = 0; i2 < actionExp.length; i2++) {
          if (i2 !== 0) {
            curNodes = [this.source.view.currentNode()];
          }
          const action = actionExp[i2];
          if (Array.isArray(action)) {
            await this.doActionExp(action, curNodes, subOptions);
            continue;
          }
          if (action.name === waitAction.name) {
            const timeout = this.source.config.get(
              "mapping.action.wait.timeout"
            );
            if (timeout === 0 || waitRelease || isSubAction) {
              continue;
            }
            waitRelease = await this.global.waitActionMutex.acquire();
            setTimeout(() => {
              if (waitRelease) {
                logger.warn(`action(${JSON.stringify(actionExp)}) timeout`);
                waitRelease();
                waitRelease = void 0;
              }
            }, timeout);
            continue;
          }
          const rule = conditionActionRules[action.name];
          if (rule) {
            const [trueNodes, falseNodes] = partition_default(
              curNodes,
              (node) => rule.filter(this.source, node, action.args)
            );
            const [trueAction, falseAction] = [
              actionExp[i2 + 1],
              actionExp[i2 + 2]
            ];
            i2 += 2;
            if (trueNodes.length) {
              await this.doActionExp(trueAction, trueNodes, subOptions);
            }
            if (falseNodes.length) {
              await this.doActionExp(falseAction, falseNodes, subOptions);
            }
          } else {
            await this.doActionExp(action, curNodes, subOptions);
          }
        }
      } else {
        if (actionExp.name !== noopAction.name) {
          await this.doAction(actionExp.name, curNodes, actionExp.args, mode);
        }
      }
    } finally {
      waitRelease == null ? void 0 : waitRelease();
      waitRelease = void 0;
    }
  }
  async doAction(name, nodes, args = [], mode = "n") {
    const action = this.registeredAction(name);
    if (!action) {
      return;
    }
    const { select = false, render = false, reload = false } = action.options;
    const finalNodes = Array.isArray(nodes) ? nodes : [nodes];
    const source = this.source;
    try {
      if (select === true) {
        const allNodes = uniq_default([...finalNodes, ...source.selectedNodes]);
        source.selectedNodes.clear();
        source.view.requestRenderNodes(allNodes);
        await action.callback.call(source, {
          source,
          nodes: allNodes,
          args,
          mode
        });
      } else if (select === false) {
        await action.callback.call(source, {
          source,
          nodes: [finalNodes[0]],
          args,
          mode
        });
      } else if (select === "visual") {
        await action.callback.call(source, {
          source,
          nodes: finalNodes,
          args,
          mode
        });
      } else if (select === "keep") {
        const allNodes = uniq_default([...finalNodes, ...source.selectedNodes]);
        await action.callback.call(source, {
          source,
          nodes: allNodes,
          args,
          mode
        });
      }
    } finally {
      if (reload) {
        await source.load(source.view.rootNode);
      } else if (render) {
        await source.view.render();
      }
    }
  }
  async listActionMenu(nodes) {
    var _a;
    const actions = this.registeredActions();
    const source = this.source;
    const reverseMappings = await keyMapping.getReversedMappings(
      source.sourceType
    );
    const task = await startCocList(
      this.source.explorer,
      explorerActionList,
      flatten_default(
        [...actions.entries()].filter(([actionName]) => actionName !== "actionMenu").sort(([aName], [bName]) => aName.localeCompare(bName)).map(([actionName, { callback, options, description }]) => {
          const keys2 = reverseMappings[actionName];
          const key = keys2 ? keys2.vmap ?? keys2.all : "";
          const list = [
            {
              name: actionName,
              key,
              description,
              callback: async () => {
                await task.waitExplorerShow();
                await callback.call(source, {
                  source,
                  nodes,
                  args: [],
                  mode: "n"
                });
              }
            }
          ];
          if (options.menus) {
            list.push(
              ...ActionMenu.getNormalizeMenus(options.menus).map((menu) => {
                const fullActionName = `${actionName}:${menu.args}`;
                const keys3 = reverseMappings[fullActionName];
                const key2 = keys3 ? keys3.vmap ?? keys3.all : "";
                return {
                  name: fullActionName,
                  key: key2,
                  description: `${description} ${menu.description}`,
                  callback: async () => {
                    await task.waitExplorerShow();
                    await callback.call(source, {
                      source,
                      nodes,
                      args: await menu.actionArgs(),
                      mode: "n"
                    });
                  }
                };
              })
            );
          }
          return list;
        })
      )
    );
    (_a = task.waitExplorerShow()) == null ? void 0 : _a.catch(logger.error);
  }
};

// src/highlight/highlightSource.ts
var HighlightSource = class {
  constructor(source, hlSrcId) {
    this.source = source;
    this.hlSrcId = hlSrcId;
  }
  addHighlightsNotify(highlights) {
    this.source.explorer.highlight.addHighlightsNotify(
      this.hlSrcId,
      highlights
    );
  }
  clearHighlightsNotify(lineStart, lineEnd) {
    this.source.explorer.highlight.clearHighlightsNotify(
      this.hlSrcId,
      lineStart,
      lineEnd
    );
  }
};

// src/locator/markSource.ts
var MarkSource = class {
  constructor(source) {
    this.source = source;
    this.explorer = source.explorer;
  }
  get view() {
    return this.source.view;
  }
  add(type, relativeLineIndex) {
    this.explorer.locator.mark.add(
      type,
      this.view.startLineIndex + relativeLineIndex
    );
  }
  remove(type, relativeLineIndex) {
    this.explorer.locator.mark.remove(
      type,
      this.view.startLineIndex + relativeLineIndex
    );
  }
  offsetAfterLine(offset, afterLine) {
    this.explorer.locator.mark.offsetLines(
      offset,
      this.view.startLineIndex + afterLine + 1
    );
    this.view.endLineIndex += offset;
    const sourceIndex = this.view.currentSourceIndex();
    if (sourceIndex === void 0) {
      return;
    }
    this.explorer.sources.slice(sourceIndex + 1).forEach((source) => {
      source.view.startLineIndex += offset;
      source.view.endLineIndex += offset;
    });
  }
};

// src/locator/locatorSource.ts
var LocatorSource = class {
  constructor(source) {
    this.source = source;
    this.explorer = this.source.explorer;
    this.mark = new MarkSource(source);
  }
  get view() {
    return this.source.view;
  }
  async gotoLineIndex(lineIndex, col) {
    return (await this.gotoLineIndexNotifier(lineIndex, col)).run();
  }
  gotoLineIndexNotifier(lineIndex, col) {
    if (lineIndex < 0) {
      lineIndex = 0;
    }
    if (lineIndex >= this.source.height) {
      lineIndex = this.source.height - 1;
    }
    return this.explorer.locator.gotoLineIndexNotifier(
      this.view.startLineIndex + lineIndex,
      col
    );
  }
  async gotoRoot({ col } = {}) {
    return (await this.gotoLineIndexNotifier(0, col)).run();
  }
  gotoRootNotifier({ col } = {}) {
    return this.gotoLineIndexNotifier(0, col);
  }
  async gotoNode(node, options = {}) {
    return (await this.gotoNodeNotifier(node, options)).run();
  }
  async gotoNodeNotifier(node, options = {}) {
    return this.gotoNodeUidNotifier(node.uid, options);
  }
  async gotoNodeUid(nodeUid, options = {}) {
    return (await this.gotoNodeUidNotifier(nodeUid, options)).run();
  }
  async gotoNodeUidNotifier(nodeUid, {
    lineIndex: fallbackLineIndex,
    col = 0
  } = {}) {
    const lineIndex = this.view.flattenedNodes.findIndex(
      (it) => it.uid === nodeUid
    );
    if (lineIndex !== -1) {
      return this.gotoLineIndexNotifier(lineIndex, col);
    } else if (fallbackLineIndex !== void 0) {
      return this.gotoLineIndexNotifier(fallbackLineIndex, col);
    } else {
      return Notifier.noop();
    }
  }
};

// src/source/source.ts
var ExplorerSource = class {
  constructor(sourceType, explorer) {
    this.sourceType = sourceType;
    this.explorer = explorer;
    this.width = 0;
    this.showHidden = false;
    this.selectedNodes = /* @__PURE__ */ new Set();
    this.nvim = import_coc47.workspace.nvim;
    this.bufManager = this.explorer.explorerManager.bufManager;
    this.events = new HelperEventEmitter(logger);
    this.action = new ActionSource(this, this.explorer.action);
    this.locator = new LocatorSource(this);
    this.disposables = [];
    this.isDisposed = false;
    this.config = this.explorer.config;
    this.icons = ((source) => ({
      get expanded() {
        return source.config.get("icon.expanded") || (source.config.get("icon.enableNerdfont") ? "\uF44B" : "-");
      },
      get collapsed() {
        return source.config.get("icon.collapsed") || (source.config.get("icon.enableNerdfont") ? "\uF44A" : "+");
      },
      get selected() {
        return source.config.get("icon.selected");
      },
      get hidden() {
        return source.config.get("icon.hidden");
      },
      get link() {
        return source.config.get("icon.link");
      },
      get readonly() {
        return source.config.get("icon.readonly") || (source.config.get("icon.enableNerdfont") ? "\uF023" : "RO");
      }
    }))(this);
    this.helper = ((source) => ({
      getUid(uid) {
        return generateUri2(uid.toString(), source.sourceType);
      }
    }))(this);
    this.context = this.explorer.context;
    this.highlight = new HighlightSource(
      this,
      `coc-explorer-${sourceType}`
    );
  }
  get root() {
    return import_coc47.workspace.cwd;
  }
  set root(_root) {
  }
  static get enabled() {
    return true;
  }
  dispose() {
    this.isDisposed = true;
    this.view.dispose();
    this.disposables.forEach((s3) => s3.dispose());
  }
  get height() {
    return this.view.flattenedNodes.length;
  }
  bootInit(rootExpandedForOpen) {
    Promise.resolve(this.init()).catch(logger.error);
    this.view.bootInit(rootExpandedForOpen);
  }
  async bootOpen(isFirst) {
    await this.open(isFirst);
    this.view.bootOpen();
  }
  async openedNotifier(renderer, _isFirst) {
    return Notifier.noop();
  }
  async copyToClipboard(content) {
    await this.nvim.call("setreg", ["+", content]);
    await this.nvim.call("setreg", ['"', content]);
  }
  isSelectedAny() {
    return this.selectedNodes.size !== 0;
  }
  isSelectedNode(node) {
    return this.selectedNodes.has(node);
  }
  async loadInitedChildren(parentNode, options) {
    const children = await this.loadChildren(parentNode, options);
    await Promise.all(
      children.map(async (node, i2) => {
        node.level = (parentNode.level ?? 0) + 1;
        node.parent = parentNode;
        node.prevSiblingNode = children[i2 - 1];
        node.nextSiblingNode = children[i2 + 1];
        if ((options == null ? void 0 : options.recursiveExpanded) && node.expandable && this.view.isExpanded(node)) {
          node.children = await this.loadInitedChildren(node, options);
        }
      })
    );
    return children;
  }
  async load(node, options) {
    await this.view.sync(async (r) => {
      return (await this.loadNotifier(r, node, options)).run();
    });
  }
  async loadNotifier(renderer, node, { render = true, force = false } = {}) {
    if (this.isDisposed) {
      return Notifier.noop();
    }
    await this.explorer.refreshWidth();
    this.selectedNodes = /* @__PURE__ */ new Set();
    if (this.view.isExpanded(node)) {
      node.children = await this.loadInitedChildren(node, {
        recursiveExpanded: true,
        force
      });
    } else {
      node.children = void 0;
    }
    await this.events.fire("loaded", node);
    await this.view.load(node);
    if (render) {
      return renderer.renderNotifier({ node, force });
    }
    return Notifier.noop();
  }
};

// src/source/sourceManager.ts
var import_coc48 = require("coc.nvim");
var SourceManager = class {
  constructor() {
    this.registeredSources = {};
  }
  registerSource(name, source) {
    this.registeredSources[name] = source;
    return import_coc48.Disposable.create(() => {
      delete this.registeredSources[name];
    });
  }
  async enabled(name) {
    if (!this.registeredSources[name]) {
      return false;
    }
    return await this.registeredSources[name].enabled;
  }
  createSource(name, explorer, expanded) {
    if (!this.registeredSources[name]) {
      throw new Error(`explorer source(${name}) not found`);
    }
    const source = new this.registeredSources[name](name, explorer);
    source.bootInit(expanded);
    return source;
  }
};
var sourceManager = new SourceManager();

// src/source/sources/buffer/argOptions.ts
var bufferArgOptions = {
  bufferRootTemplate: Args.registerOption("buffer-root-template", {
    getDefault: () => config.get("buffer.root.template")
  }),
  bufferChildTemplate: Args.registerOption("buffer-child-template", {
    getDefault: () => config.get("buffer.child.template")
  }),
  bufferChildLabelingTemplate: Args.registerOption(
    "buffer-child-labeling-template",
    {
      getDefault: () => config.get("buffer.child.labelingTemplate")
    }
  )
};

// src/source/sources/buffer/bufferActions.ts
var import_coc49 = require("coc.nvim");
function loadBufferActions(action) {
  const { nvim } = import_coc49.workspace;
  const buffer2 = action.owner;
  action.addNodeAction(
    "drop",
    async ({ node }) => {
      if (!node.hidden) {
        const info = await nvim.call("getbufinfo", node.bufnr);
        if (info.length && info[0].windows.length) {
          const quitNotifier2 = await buffer2.explorer.tryQuitOnOpenNotifier();
          const winid = info[0].windows[0];
          nvim.pauseNotification();
          nvim.call("win_gotoid", winid, true);
          quitNotifier2.notify();
          await nvim.resumeNotification();
          return;
        }
      }
      const quitNotifier = await buffer2.explorer.tryQuitOnOpenNotifier();
      nvim.pauseNotification();
      nvim.command(`buffer ${node.bufnr}`, true);
      quitNotifier.notify();
      await nvim.resumeNotification();
    },
    "open buffer by drop command",
    { select: true }
  );
  action.addNodeAction(
    "delete",
    async ({ node }) => {
      if (bufferTabOnly()) {
        await tabContainerManager.curTabDelBufnr(node.bufnr);
        if (tabContainerManager.existBufnr(node.bufnr)) {
          const winids = await winidsByBufnrInCurTab(node.bufnr);
          await leaveEmptyInWinids(winids);
          return;
        }
      }
      if (buffer2.bufManager.modified(node.fullpath, {
        directory: false
      }) && await prompt("Buffer is being modified, delete it?") !== "yes") {
        return;
      }
      await buffer2.bufManager.removeBufNode(node, {
        skipModified: true,
        bwipeout: false,
        directory: false
      });
      await buffer2.load(node, { force: true });
    },
    "delete buffer",
    { select: true }
  );
  action.addNodeAction(
    "deleteForever",
    async ({ node }) => {
      if (buffer2.bufManager.modified(node.fullpath, {
        directory: false
      }) && await prompt("Buffer is being modified, wipeout it?") !== "yes") {
        return;
      }
      await buffer2.bufManager.removeBufNode(node, {
        skipModified: true,
        bwipeout: true,
        directory: false
      });
      await buffer2.load(node, { force: true });
    },
    "bwipeout buffer",
    { select: true }
  );
}

// src/source/columnRegistrar.ts
var import_coc50 = require("coc.nvim");
var ColumnRegistrar = class {
  constructor() {
    this.registeredColumns = /* @__PURE__ */ new Map();
  }
  async initColumn(type, source, columnName) {
    var _a, _b;
    if (/\d+/.test(columnName)) {
      return parseInt(columnName, 10);
    }
    const registeredColumn = (_a = this.registeredColumns.get(type)) == null ? void 0 : _a.get(columnName);
    if (!registeredColumn) {
      throw Error(`column(${columnName}) not found`);
    }
    const column = { label: columnName };
    const subscriptions = [];
    Object.assign(
      column,
      registeredColumn.createColumn({
        source,
        column,
        subscriptions
      }),
      { subscriptions }
    );
    if (column.inited) {
      return column;
    }
    if (column.available && !await column.available()) {
      return void 0;
    }
    await ((_b = column.init) == null ? void 0 : _b.call(column));
    column.inited = true;
    return column;
  }
  registerColumn(type, name, createColumn) {
    if (!this.registeredColumns.has(type)) {
      this.registeredColumns.set(type, /* @__PURE__ */ new Map());
    }
    this.registeredColumns.get(type).set(name, {
      createColumn
    });
    return import_coc50.Disposable.create(() => {
      this.registeredColumns.get(type).delete(name);
    });
  }
};

// src/source/sources/buffer/bufferColumnRegistrar.ts
var BufferColumnRegistrar = class extends ColumnRegistrar {
};
var bufferColumnRegistrar = new BufferColumnRegistrar();

// src/source/sources/buffer/root-columns/icon.ts
bufferColumnRegistrar.registerColumn("root", "icon", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(
          source.view.isExpanded(node) ? source.icons.expanded : source.icons.collapsed,
          { hl: bufferHighlights.expandIcon }
        );
      }
    };
  }
}));

// src/source/sources/buffer/root-columns/title.ts
bufferColumnRegistrar.registerColumn("root", "title", () => ({
  draw() {
    return {
      drawNode(row) {
        row.add("[BUFFER]", {
          hl: bufferHighlights.title
        });
      }
    };
  }
}));

// src/source/sources/buffer/root-columns/hidden.ts
bufferColumnRegistrar.registerColumn("root", "hidden", ({ source }) => ({
  draw() {
    return {
      drawNode(row) {
        row.add(source.showHidden ? source.icons.hidden : "", {
          hl: bufferHighlights.hidden
        });
      }
    };
  }
}));

// src/git/config.ts
var getRootStatusIcons = (config4) => {
  const getRootIconConf = (name) => {
    const icon = config4.get(`git.icon.rootStatus.${name}`);
    return {
      icon,
      name
    };
  };
  return {
    [0 /* staged */]: {
      icon: "",
      name: "staged"
    },
    [5 /* stashed */]: getRootIconConf("stashed"),
    [1 /* ahead */]: getRootIconConf("ahead"),
    [2 /* behind */]: getRootIconConf("behind"),
    [3 /* conflicted */]: getRootIconConf("conflicted"),
    [4 /* untracked */]: getRootIconConf("untracked"),
    [6 /* modified */]: getRootIconConf("modified"),
    [7 /* added */]: getRootIconConf("added"),
    [8 /* renamed */]: getRootIconConf("renamed"),
    [9 /* deleted */]: getRootIconConf("deleted")
  };
};
var getStatusIcons = (config4) => {
  const getIconConf = (name) => {
    const icon = config4.get(`git.icon.status.${name}`);
    return {
      icon,
      name
    };
  };
  return {
    ["*" /* mixed */]: getIconConf("mixed"),
    [" " /* unmodified */]: getIconConf("unmodified"),
    ["M" /* modified */]: getIconConf("modified"),
    ["A" /* added */]: getIconConf("added"),
    ["D" /* deleted */]: getIconConf("deleted"),
    ["R" /* renamed */]: getIconConf("renamed"),
    ["C" /* copied */]: getIconConf("copied"),
    ["U" /* unmerged */]: getIconConf("unmerged"),
    ["?" /* untracked */]: getIconConf("untracked"),
    ["!" /* ignored */]: getIconConf("ignored")
  };
};

// src/git/highlights.ts
var import_coc51 = require("coc.nvim");
var import_color_convert3 = __toESM(require_color_convert());
var hlg2 = hlGroupManager.linkGroup.bind(hlGroupManager);
var registerGitHighlights = (disposables) => {
  hlGroupManager.watchColorScheme(disposables, async () => {
    const groups = [
      "String",
      "Character",
      "Number",
      "Boolean",
      "Float",
      "Identifier",
      "Function",
      "Statement",
      "Conditional",
      "Repeat",
      "Label",
      "Operator",
      "Keyword",
      "Exception",
      "PreProc",
      "Include",
      "Define",
      "Macro",
      "PreCondit",
      "Type",
      "StorageClass",
      "Structure",
      "Typedef",
      "Special",
      "SpecialChar",
      "Tag",
      "Delimiter",
      "SpecialComment",
      "Debug",
      "Todo"
    ];
    const highlights = await extractHighlightsColor(groups);
    const fgs = compactI2(
      Object.values(highlights).map((h3) => {
        const guifg = h3.guifg;
        if (!guifg) {
          return;
        }
        const ctermfg = h3.ctermfg ?? import_color_convert3.default.rgb.ansi256([guifg.red, guifg.green, guifg.blue]).toString();
        return {
          guifg,
          ctermfg
        };
      })
    );
    const { nvim } = import_coc51.workspace;
    nvim.pauseNotification();
    const green = findNearestColor(
      createColor(18, 204, 90, 1),
      fgs,
      (it) => it.guifg
    );
    if (green) {
      nvim.command(
        `highlight default CocExplorerGitPathChange_Internal ctermfg=${green.ctermfg} guifg=#${toHex(green.guifg)}`,
        true
      );
    }
    const yellow = findNearestColor(
      createColor(209, 177, 15, 1),
      fgs,
      (it) => it.guifg
    );
    if (yellow) {
      nvim.command(
        `highlight default CocExplorerGitContentChange_Internal ctermfg=${green.ctermfg} guifg=#${toHex(yellow.guifg)}`,
        true
      );
    }
    await nvim.resumeNotification();
  }).catch(logger.error);
};
var gitChangedPath = hlg2(
  "GitPathChange",
  "CocExplorerGitPathChange_Internal"
);
var gitContentChange = hlg2(
  "GitContentChange",
  "CocExplorerGitContentChange_Internal"
);
var gitHighlights = {
  renamed: hlg2("GitRenamed", gitChangedPath.group),
  copied: hlg2("GitCopied", gitChangedPath.group),
  added: hlg2("GitAdded", gitChangedPath.group),
  untracked: hlg2("GitUntracked", gitChangedPath.group),
  unmerged: hlg2("GitUnmerged", gitChangedPath.group),
  mixed: hlg2("GitMixed", gitContentChange.group),
  modified: hlg2("GitModified", gitContentChange.group),
  deleted: hlg2("GitDeleted", internalHighlightGroups.ErrorColor),
  ignored: hlg2("GitIgnored", internalHighlightGroups.CommentColor),
  staged: hlg2("GitStaged", internalHighlightGroups.CommentColor),
  unstaged: hlg2("GitUnstaged", "Operator")
};
var getGitFormatHighlight = (format2) => {
  switch (format2) {
    case "*" /* mixed */:
      return gitHighlights.mixed;
    case "M" /* modified */:
      return gitHighlights.modified;
    case "A" /* added */:
      return gitHighlights.added;
    case "D" /* deleted */:
      return gitHighlights.deleted;
    case "R" /* renamed */:
      return gitHighlights.renamed;
    case "C" /* copied */:
      return gitHighlights.copied;
    case "U" /* unmerged */:
      return gitHighlights.unmerged;
    case "?" /* untracked */:
      return gitHighlights.untracked;
  }
};

// src/diagnostic/manager.ts
var import_coc53 = require("coc.nvim");
var import_path14 = __toESM(require("path"));

// src/diagnostic/binder.ts
var import_coc52 = require("coc.nvim");
var import_path13 = __toESM(require("path"));
var DiagnosticBinder = class {
  constructor() {
    this.sourcesBinding = /* @__PURE__ */ new Map();
    this.prevErrorMixedCount = /* @__PURE__ */ new Map();
    this.prevWarningMixedCount = /* @__PURE__ */ new Map();
    this.reloadDebounceSubject = createSubject(
      (sub) => sub.pipe(
        buffer(sub.pipe(debounceTime(500))),
        switchMap(async (list) => {
          const sources = new Set(list.flat());
          await this.reload([...sources]);
        })
      )
    );
  }
  get sources() {
    return [...this.sourcesBinding.keys()];
  }
  get refTotalCount() {
    return sum_default([...this.sourcesBinding.values()].map((b2) => b2.refCount.total));
  }
  get diagnosticTypes() {
    const types = [];
    const refs = [...this.sourcesBinding.values()].map((ref) => ref.refCount);
    if (refs.some((ref) => ref.error > 0)) {
      types.push("error");
    }
    if (refs.some((ref) => ref.warning > 0)) {
      types.push("warning");
    }
    return types;
  }
  bind(source, type) {
    const binding = mapGetWithDefault(this.sourcesBinding, source, () => ({
      refCount: {
        error: 0,
        warning: 0,
        total: 0
      }
    }));
    binding.refCount[type] += 1;
    binding.refCount.total += 1;
    if (binding.refCount.total === 1) {
      this.registeredForSourceDisposable = this.registerForSource(source);
    }
    if (this.refTotalCount === 1) {
      this.registeredDisposable = this.register();
    }
    return import_coc52.Disposable.create(() => {
      var _a, _b;
      binding.refCount[type] -= 1;
      binding.refCount.total -= 1;
      if (binding.refCount.total === 0) {
        (_a = this.registeredForSourceDisposable) == null ? void 0 : _a.dispose();
        this.registeredForSourceDisposable = void 0;
      }
      if (this.refTotalCount === 0) {
        (_b = this.registeredDisposable) == null ? void 0 : _b.dispose();
        this.registeredDisposable = void 0;
      }
    });
  }
  register() {
    return internalEvents.on("CocDiagnosticChange", () => {
      this.reloadDebounceSubject.next(this.sources);
    });
  }
  registerForSource(source) {
    const reload = source.events.on("loaded", async (node) => {
      const directory = "isRoot" in node ? source.root : node.expandable ? node.fullpath : node.fullpath && import_path13.default.dirname(node.fullpath);
      if (directory) {
        this.reloadDebounceSubject.next([source]);
      }
    });
    const updateMark = source.events.on("drawn", () => {
      for (const [nodeIndex, node] of source.view.flattenedNodes.entries()) {
        if (!node.fullpath) {
          continue;
        }
        const errorCount = diagnosticManager.getMixedError(node.fullpath);
        const warningCount = diagnosticManager.getMixedWarning(node.fullpath);
        let errorMark = false;
        let warningMark = false;
        if (errorCount || warningCount) {
          const display = !(node.expandable && source.view.isExpanded(node));
          if (errorCount && display) {
            errorMark = true;
          }
          if (warningCount && display) {
            warningMark = true;
          }
        }
        if (errorMark) {
          source.locator.mark.add("diagnosticError", nodeIndex);
        } else {
          source.locator.mark.remove("diagnosticError", nodeIndex);
        }
        if (warningMark) {
          source.locator.mark.add("diagnosticWarning", nodeIndex);
        } else {
          source.locator.mark.remove("diagnosticWarning", nodeIndex);
        }
      }
    });
    return import_coc52.Disposable.create(() => {
      reload.dispose();
      updateMark.dispose();
    });
  }
  async reload(sources) {
    const types = this.diagnosticTypes;
    await diagnosticManager.reload(types);
    const updatePaths = /* @__PURE__ */ new Set();
    if (types.includes("error")) {
      for (const [fullpath] of this.prevErrorMixedCount) {
        updatePaths.add(fullpath);
      }
      const newErrorMixedCount = new Map(diagnosticManager.getMixedErrors());
      for (const [fullpath] of newErrorMixedCount) {
        updatePaths.add(fullpath);
      }
      this.prevErrorMixedCount = newErrorMixedCount;
    }
    if (types.includes("warning")) {
      for (const [fullpath] of this.prevWarningMixedCount) {
        updatePaths.add(fullpath);
      }
      const newWarningMixedCount = new Map(
        diagnosticManager.getMixedWarnings()
      );
      for (const [fullpath] of newWarningMixedCount) {
        updatePaths.add(fullpath);
      }
      this.prevWarningMixedCount = newWarningMixedCount;
    }
    for (const source of sources) {
      await source.view.renderPaths(updatePaths);
    }
  }
};

// src/diagnostic/manager.ts
var DiagnosticManager = class {
  constructor() {
    this.errorMixedCountCache = /* @__PURE__ */ new Map();
    this.warningMixedCountCache = /* @__PURE__ */ new Map();
    this.binder = new DiagnosticBinder();
  }
  bindColumn(source, types) {
    const typeSet = new Set(types);
    const disposables = [];
    for (const type of typeSet) {
      disposables.push(this.binder.bind(source, type));
    }
    return import_coc53.Disposable.create(() => {
      (0, import_coc53.disposeAll)(disposables);
    });
  }
  async reload(types) {
    const typeSet = new Set(types);
    const errorPathCount = /* @__PURE__ */ new Map();
    const warningPathCount = /* @__PURE__ */ new Map();
    for (const diagnostic of await import_coc53.diagnosticManager.getDiagnosticList()) {
      const uri = diagnostic.location.uri;
      const path2 = normalizePath(import_coc53.Uri.parse(uri).fsPath);
      if (diagnostic.severity === "Error") {
        const count = errorPathCount.get(path2);
        errorPathCount.set(path2, (count ?? 0) + 1);
      } else {
        const count = warningPathCount.get(path2);
        warningPathCount.set(path2, (count ?? 0) + 1);
      }
    }
    if (typeSet.has("error")) {
      this.reloadMixedErrors(errorPathCount);
    }
    if (typeSet.has("warning")) {
      this.reloadMixedWarnings(warningPathCount);
    }
  }
  reloadMixedErrors(errorPathCount) {
    const errorMixedCount = /* @__PURE__ */ new Map();
    for (const [fullpath, count] of errorPathCount) {
      const parts = fullpath.split(import_path14.default.sep);
      for (let i2 = 1; i2 <= parts.length; i2++) {
        const frontalPath = parts.slice(0, i2).join(import_path14.default.sep);
        const existCount = errorMixedCount.get(frontalPath);
        errorMixedCount.set(frontalPath, (existCount ?? 0) + count);
      }
    }
    this.errorMixedCountCache = errorMixedCount;
  }
  reloadMixedWarnings(warningPathCount) {
    const warningMixedCount = /* @__PURE__ */ new Map();
    for (const [fullpath, count] of warningPathCount) {
      const parts = fullpath.split(import_path14.default.sep);
      for (let i2 = 1; i2 <= parts.length; i2++) {
        const frontalPath = parts.slice(0, i2).join(import_path14.default.sep);
        const existCount = warningMixedCount.get(frontalPath);
        warningMixedCount.set(frontalPath, (existCount ?? 0) + count);
      }
    }
    this.warningMixedCountCache = warningMixedCount;
  }
  getMixedErrors() {
    return this.errorMixedCountCache;
  }
  getMixedWarnings() {
    return this.warningMixedCountCache;
  }
  getMixedError(fullpath) {
    return this.errorMixedCountCache.get(fullpath);
  }
  getMixedWarning(fullpath) {
    return this.warningMixedCountCache.get(fullpath);
  }
};
var diagnosticManager = new DiagnosticManager();

// src/source/sources/file/fileSource.ts
var import_coc61 = require("coc.nvim");
var import_fs11 = __toESM(require("fs"));
var import_os4 = require("os");
var import_path19 = __toESM(require("path"));

// src/diagnostic/highlights.ts
var hlg3 = hlGroupManager.linkGroup.bind(hlGroupManager);
var diagnosticHighlights = {
  diagnosticError: hlg3(
    "DiagnosticError",
    internalHighlightGroups.CocErrorSignColor
  ),
  diagnosticWarning: hlg3(
    "DiagnosticWarning",
    internalHighlightGroups.CocWarningSignColor
  )
};

// src/lists/files.ts
var import_child_process2 = require("child_process");
var import_coc54 = require("coc.nvim");
var import_events6 = require("events");
var import_minimatch2 = __toESM(require_minimatch());
var import_path15 = __toESM(require("path"));
var import_readline2 = __toESM(require("readline"));
var Task = class extends import_events6.EventEmitter {
  constructor() {
    super(...arguments);
    this.processes = [];
  }
  start(cmd, args, cwds, excludePatterns) {
    let remain = cwds.length;
    for (const cwd of cwds) {
      const process3 = (0, import_child_process2.spawn)(cmd, args, { cwd });
      this.processes.push(process3);
      process3.on("error", (e2) => {
        this.emit("error", e2.message);
      });
      const rl = import_readline2.default.createInterface(process3.stdout);
      const range = import_coc54.Range.create(0, 0, 0, 0);
      const hasPattern = excludePatterns.length > 0;
      process3.stderr.on("data", (chunk) => {
        console.error(chunk.toString("utf8"));
      });
      rl.on("line", (line) => {
        const file = import_path15.default.join(cwd, line);
        if (hasPattern && excludePatterns.some((p) => (0, import_minimatch2.default)(file, p))) {
          return;
        }
        const finalPath = file.replace(/\/$/, "");
        const location = import_coc54.Location.create(import_coc54.Uri.file(finalPath).toString(), range);
        this.emit("data", {
          label: line,
          location
        });
      });
      rl.on("close", () => {
        remain = remain - 1;
        if (remain === 0) {
          this.emit("end");
        }
      });
    }
  }
  dispose() {
    for (const process3 of this.processes) {
      if (!process3.killed) {
        process3.kill();
      }
    }
  }
};
var config3 = import_coc54.workspace.getConfiguration("list.source.files");
async function getCommand(arg) {
  const args = [];
  if (await executable("fd")) {
    args.push("--color", "never");
    if (arg.showIgnores) {
      args.push("--no-ignore");
    }
    if (arg.showHidden) {
      args.push("--hidden");
    }
    if (!arg.recursive) {
      args.push("--max-depth", "1");
    }
    return { name: "fd", args };
  } else if (isWindows2) {
    args.push("/a-D", "/B");
    if (arg.recursive) {
      args.push("/S");
    }
    return { name: "dir", args };
  } else if (await executable("find")) {
    args.push(".");
    if (!arg.recursive) {
      args.push("-maxdepth", "1");
    }
    return { name: "find", args };
  } else {
    throw new Error("Unable to find command for files list.");
  }
}
var fileList = registerList({
  name: "explorerFiles",
  defaultAction: "reveal",
  async loadItems(arg) {
    if (!arg.rootPath) {
      return;
    }
    const cmd = await getCommand(arg);
    if (!cmd) {
      return;
    }
    logger.info(`file list task cmd: ${cmd.name}`);
    const task = new Task();
    const excludePatterns = config3.get("excludePatterns", []);
    task.start(cmd.name, cmd.args, [arg.rootPath], excludePatterns);
    return task;
  },
  init() {
    this.addLocationActions();
    this.addAction("reveal", async ({ arg, item }) => {
      const loc = await this.convertLocation(item.location);
      if (arg.revealCallback) {
        await arg.revealCallback(loc);
      }
    });
  }
});

// src/source/sources/file/argOptions.ts
var fileArgOptions = {
  fileRootTemplate: Args.registerOption("file-root-template", {
    getDefault: () => config.get("file.root.template")
  }),
  fileRootLabelingTemplate: Args.registerOption(
    "file-root-labeling-template",
    {
      getDefault: () => config.get("file.root.labelingTemplate")
    }
  ),
  fileChildTemplate: Args.registerOption("file-child-template", {
    getDefault: () => config.get("file.child.template")
  }),
  fileChildLabelingTemplate: Args.registerOption(
    "file-child-labeling-template",
    {
      getDefault: () => config.get("file.child.labelingTemplate")
    }
  )
};

// src/source/sources/file/fileActions.ts
var import_open = __toESM(require_open());
var import_coc57 = require("coc.nvim");
var import_path16 = __toESM(require("path"));

// src/lists/drives.ts
var import_coc55 = require("coc.nvim");
var driveList = registerList({
  name: "explorerDrives",
  defaultAction: "do",
  async loadItems(drives) {
    return drives.map((drive) => ({
      label: drive.name,
      data: drive
    }));
  },
  doHighlight() {
    const { nvim } = import_coc55.workspace;
    nvim.pauseNotification();
    nvim.command("syntax match CocExplorerDriveName /\\v^[\\w:]+/", true);
    nvim.command("highlight default link CocExplorerDriveName PreProc", true);
    nvim.resumeNotification().catch(logger.error);
  },
  init() {
    this.addAction("do", async ({ item }) => {
      await item.data.callback(item.data.name);
    });
  }
});

// src/lists/workspaceFolders.ts
var import_coc56 = require("coc.nvim");
var explorerWorkspaceFolderList = registerList({
  defaultAction: "do",
  name: "ExplorerWorkspaceFolders",
  async loadItems(fileSource) {
    return import_coc56.workspace.folderPaths.map((path2) => ({
      label: path2,
      data: {
        path: path2,
        callback: () => {
          fileSource == null ? void 0 : fileSource.action.doAction("cd", [], [path2]).catch(logger.error);
        }
      }
    }));
  },
  init() {
    this.addAction("do", ({ item }) => {
      item.data.callback();
    });
  },
  doHighlight() {
    const { nvim } = import_coc56.workspace;
    nvim.pauseNotification();
    nvim.command("syntax match CocExplorerWorkspaceFolder /\\v^.*/", true);
    nvim.command(
      "highlight default link CocExplorerWorkspaceFolder PreProc",
      true
    );
    nvim.resumeNotification().catch(logger.error);
  }
});

// src/source/sources/file/fileActions.ts
function loadFileActions(action) {
  const { nvim } = import_coc57.workspace;
  const file = action.owner;
  action.addNodeAction(
    "gotoParent",
    async () => {
      var _a;
      if (file.root === "") {
        return;
      }
      const nodeUid = (_a = file.view.currentNode()) == null ? void 0 : _a.uid;
      if (/^[A-Za-z]:[\\/]$/.test(file.root)) {
        file.root = "";
      } else {
        file.root = import_path16.default.dirname(file.root);
        await file.cd(file.root);
      }
      await file.view.expand(file.view.rootNode);
      if (nodeUid) {
        await file.locator.gotoNodeUid(nodeUid);
      }
    },
    "change directory to parent directory"
  );
  action.addNodeAction(
    "rootStrategies",
    ({ args }) => {
      const originalRootStrategies = args[0];
      if (originalRootStrategies)
        file.rootStrategies = originalRootStrategies.split(",");
    },
    "change root strategies",
    {
      args: [
        {
          name: "root strategies",
          description: `root strategies of ${rootStrategyList.join(" | ")}`
        }
      ],
      menus: {
        "workspace,cwd,sourceBuffer,reveal": "default",
        keep: "keep current root"
      }
    }
  );
  action.addNodeAction(
    "resolveRoot",
    async ({ args, node }) => {
      var _a;
      const targetPath = args[0];
      const root2 = await ((_a = file.explorer.rooter) == null ? void 0 : _a.resolveRoot(
        targetPath,
        file.rootStrategies
      ));
      if (root2)
        await action.doAction("cd", node, [root2]);
    },
    "resolve and change directory to root",
    {
      args: [
        {
          name: "reveal path",
          description: "path string"
        }
      ],
      menus: {
        path: {
          description: "use custom path",
          args: "<reveal-path>",
          async actionArgs() {
            var _a;
            return [
              await input(
                "input a reveal path:",
                ((_a = file.view.currentNode()) == null ? void 0 : _a.fullpath) ?? "",
                "file"
              )
            ];
          }
        }
      }
    }
  );
  action.addNodeAction(
    "reveal",
    async ({ node, args }) => {
      var _a;
      const target = args[0];
      let targetBufnr;
      let targetPath = "";
      if (/\d+/.test(target)) {
        targetBufnr = parseInt(target, 10);
        if (targetBufnr === 0) {
          targetBufnr = await currentBufnr();
        }
      } else {
        const revealStrategy = target ?? "previousWindow";
        const actions = {
          select: async () => {
            await selectWindowsUI(file.explorer.config, file.sourceType, {
              onSelect: async (winnr) => {
                targetBufnr = await bufnrByWinnrOrWinid(winnr);
              }
            });
          },
          sourceWindow: async () => {
            targetBufnr = await bufnrByWinnrOrWinid(
              await file.explorer.sourceWinnr()
            );
          },
          previousBuffer: async () => {
            targetBufnr = await file.explorer.explorerManager.previousBufnr.get();
          },
          previousWindow: async () => {
            targetBufnr = await bufnrByWinnrOrWinid(
              await file.explorer.explorerManager.prevWinnrByPrevWindowID()
            );
          },
          path: async () => {
            var _a2;
            targetPath = args[1];
            if (!targetPath) {
              targetPath = await input(
                "Input a reveal path:",
                ((_a2 = file.view.currentNode()) == null ? void 0 : _a2.fullpath) ?? "",
                "file"
              );
            }
          }
        };
        await ((_a = actions[revealStrategy]) == null ? void 0 : _a.call(actions));
      }
      if (targetBufnr) {
        const bufinfo = await nvim.call("getbufinfo", [targetBufnr]);
        if (!bufinfo[0] || !bufinfo[0].name) {
          return;
        }
        targetPath = bufinfo[0].name;
      }
      if (!targetPath) {
        return;
      }
      if (!isParentFolder(file.root, targetPath)) {
        await action.doAction("resolveRoot", node, [targetPath]);
      }
      await file.view.sync(async (r) => {
        const expandOptions = args[1] ?? "";
        const compact = expandOptions.includes("compact") || void 0;
        const [revealNode, notifiers] = await file.revealNodeByPathNotifier(
          r,
          targetPath,
          {
            compact
          }
        );
        if (revealNode) {
          await Notifier.runAll(notifiers);
        }
      });
    },
    "reveal buffer in explorer",
    {
      args: [
        {
          name: "target",
          description: `bufnr number | ${revealStrategyList.join(" | ")}`
        }
      ],
      menus: {
        "0": "use current buffer",
        "0:compact": "use current buffer and compact",
        select: "use select windows UI",
        previousBuffer: "use last used buffer",
        previousWindow: "use last used window",
        sourceWindow: "use the window where explorer opened",
        path: {
          description: "use custom path",
          args: "path:<path>",
          async actionArgs() {
            return ["path"];
          }
        }
      }
    }
  );
  action.addNodeAction(
    "cd",
    async ({ node, args }) => {
      const cdTo = async (fullpath) => {
        await file.cd(fullpath);
        file.root = fullpath;
        await file.view.expand(file.view.rootNode);
      };
      const path2 = args[0];
      if (path2 !== void 0) {
        await cdTo(path2);
      } else {
        if (node.directory) {
          await cdTo(node.fullpath);
        }
      }
    },
    "change directory to current node",
    {
      args: [
        {
          name: "path"
        }
      ],
      menus: {
        path: {
          description: "",
          args: "<path>",
          async actionArgs() {
            var _a;
            return [
              await input(
                "input a cd path:",
                ((_a = file.view.currentNode()) == null ? void 0 : _a.fullpath) ?? "",
                "file"
              )
            ];
          }
        }
      }
    }
  );
  action.addNodeAction(
    "workspaceFolders",
    async () => {
      await startCocList(file.explorer, explorerWorkspaceFolderList, file, [
        "--normal"
      ]);
    },
    "change directory to current node"
  );
  action.addNodeAction(
    "drop",
    async ({ node }) => {
      if (!node.directory) {
        const quitNotifier = await file.explorer.tryQuitOnOpenNotifier();
        nvim.pauseNotification();
        nvim.command(`drop ${node.fullpath}`, true);
        quitNotifier.notify();
        await nvim.resumeNotification();
      }
    },
    "open file by drop command",
    { select: true }
  );
  action.addNodesAction(
    "copyFilepath",
    async ({ nodes }) => {
      await file.copyToClipboard(
        nodes ? nodes.map((it) => it.fullpath).join("\n") : file.root
      );
      await import_coc57.window.showInformationMessage("Copy filepath to clipboard");
    },
    "copy full filepath to clipboard"
  );
  action.addNodesAction(
    "copyRelativeFilepath",
    async ({ nodes }) => {
      await file.copyToClipboard(
        nodes ? nodes.map((it) => import_path16.default.relative(file.root, it.fullpath)).join("\n") : file.root
      );
      await import_coc57.window.showInformationMessage(
        "Copy relative filepath to clipboard"
      );
    },
    "copy relative filepath to clipboard"
  );
  action.addNodesAction(
    "copyFilename",
    async ({ nodes }) => {
      await file.copyToClipboard(
        nodes ? nodes.map((it) => it.name).join("\n") : import_path16.default.basename(file.root)
      );
      await import_coc57.window.showInformationMessage("Copy filename to clipboard");
    },
    "copy filename to clipboard"
  );
  const copyOrCutFileOptions = {
    args: [
      {
        name: "type",
        description: `${copyOrCutFileTypeList.join(" | ")}, default: replace`
      }
    ],
    menus: {
      toggle: "toggle copy/cut",
      append: "append to copy/cut",
      replace: "replace copy/cut "
    }
  };
  action.addNodesAction(
    "copyFile",
    async ({ nodes, args }) => {
      const type = args[0] ?? "replace";
      const clipboardStorage = file.explorer.explorerManager.clipboardStorage;
      if (type === "replace") {
        const content = await clipboardStorage.getFiles();
        const oldNodes = file.getNodesByPaths(content.fullpaths);
        file.view.requestRenderNodes(oldNodes);
        await clipboardStorage.setFiles(
          "copy",
          nodes.map((it) => it.fullpath)
        );
      } else if (type === "toggle") {
        const content = await clipboardStorage.getFiles();
        const fullpathSet = new Set(content.fullpaths);
        for (const node of nodes) {
          if (fullpathSet.has(node.fullpath)) {
            fullpathSet.delete(node.fullpath);
          } else {
            fullpathSet.add(node.fullpath);
          }
        }
        await clipboardStorage.setFiles("copy", [...fullpathSet]);
      } else if (type === "append") {
        const content = await clipboardStorage.getFiles();
        const fullpathSet = new Set(content.fullpaths);
        for (const node of nodes) {
          fullpathSet.add(node.fullpath);
        }
        await clipboardStorage.setFiles("copy", [...fullpathSet]);
      }
      file.view.requestRenderNodes(nodes);
    },
    "copy file for paste",
    copyOrCutFileOptions
  );
  action.addNodesAction(
    "cutFile",
    async ({ nodes, args }) => {
      const type = args[0] ?? "replace";
      const clipboardStorage = file.explorer.explorerManager.clipboardStorage;
      if (type === "replace") {
        const content = await clipboardStorage.getFiles();
        const oldNodes = file.getNodesByPaths(content.fullpaths);
        file.view.requestRenderNodes(oldNodes);
        await clipboardStorage.setFiles(
          "cut",
          nodes.map((it) => it.fullpath)
        );
      } else if (type === "toggle") {
        const content = await clipboardStorage.getFiles();
        const fullpathSet = new Set(content.fullpaths);
        for (const node of nodes) {
          if (fullpathSet.has(node.fullpath)) {
            fullpathSet.delete(node.fullpath);
          } else {
            fullpathSet.add(node.fullpath);
          }
        }
        await clipboardStorage.setFiles("cut", [...fullpathSet]);
      } else if (type === "append") {
        const content = await clipboardStorage.getFiles();
        const fullpathSet = new Set(content.fullpaths);
        for (const node of nodes) {
          fullpathSet.add(node.fullpath);
        }
        await clipboardStorage.setFiles("cut", [...fullpathSet]);
      }
      file.view.requestRenderNodes(nodes);
    },
    "cut file for paste",
    copyOrCutFileOptions
  );
  action.addNodeAction(
    "clearCopyOrCut",
    async () => {
      const clipboardStorage = file.explorer.explorerManager.clipboardStorage;
      const content = await clipboardStorage.getFiles();
      await clipboardStorage.clear();
      file.view.requestRenderNodes(file.getNodesByPaths(content.fullpaths));
    },
    "clear cut/copy clipboard of files"
  );
  action.addNodeAction(
    "pasteFile",
    async ({ node }) => {
      const clipboardStorage = file.explorer.explorerManager.clipboardStorage;
      const content = await clipboardStorage.getFiles();
      if (content.type === "none" || content.fullpaths.length <= 0) {
        await import_coc57.window.showInformationMessage(
          "Copied or cut files is empty",
          "error"
        );
        return;
      }
      const fullpaths = content.fullpaths;
      const targetNode = file.getPutTargetNode(node);
      const targetDir = targetNode.fullpath;
      let overwriteResult;
      if (content.type === "copy") {
        overwriteResult = await overwritePrompt(
          "paste",
          fullpaths.map((fullpath) => ({
            source: fullpath,
            target: import_path16.default.join(targetDir, import_path16.default.basename(fullpath))
          })),
          fsCopyFileRecursive
        );
      } else if (content.type === "cut") {
        overwriteResult = await overwritePrompt(
          "paste",
          fullpaths.map((fullpath) => ({
            source: fullpath,
            target: import_path16.default.join(targetDir, import_path16.default.basename(fullpath))
          })),
          fsRename
        );
        await clipboardStorage.setFiles("cut", overwriteResult.endFullpaths);
      }
      await file.load(file.view.rootNode);
      await file.view.sync(async (r) => {
        await file.revealNodeByPathNotifier(r, fullpaths[0], {
          startNode: targetNode
        });
      });
    },
    "paste files to here"
  );
  action.addNodesAction(
    "delete",
    async ({ nodes }) => {
      if (nodes.some(
        (node) => file.bufManager.modified(node.fullpath, {
          directory: node.directory
        })
      ) && await prompt("Buffer is being modified, discard it?") !== "yes") {
        return;
      }
      const list = nodes.map((node) => node.fullpath).join("\n");
      if (await prompt(`Move these files or directories to trash?
${list}`) !== "yes") {
        return;
      }
      await fsTrash(nodes.map((node) => node.fullpath));
      for (const node of nodes) {
        await file.bufManager.remove(node.fullpath, {
          skipModified: true,
          bwipeout: true,
          directory: node.directory
        });
      }
    },
    "move file or directory to trash",
    { reload: true }
  );
  action.addNodesAction(
    "deleteForever",
    async ({ nodes }) => {
      if (nodes.some(
        (node) => file.bufManager.modified(node.fullpath, {
          directory: node.directory
        })
      ) && await prompt("Buffer is being modified, discard it?") !== "yes") {
        return;
      }
      const list = nodes.map((node) => node.fullpath).join("\n");
      if (await prompt(
        `Delete these files or directories permanently?
${list}`
      ) !== "yes") {
        return;
      }
      for (const node of nodes) {
        await fsRemove(node.fullpath, void 0);
        await file.bufManager.remove(node.fullpath, {
          skipModified: true,
          bwipeout: true,
          directory: node.directory
        });
      }
    },
    "delete file or directory permanently",
    { reload: true }
  );
  action.addNodeAction(
    "addFile",
    async ({ node, args }) => {
      let filename;
      const promptText = "Input a new filename:";
      if (args[0]) {
        filename = args[0];
      } else {
        filename = await input(promptText, "", "file");
      }
      filename = filename == null ? void 0 : filename.trim();
      if (!filename) {
        return;
      }
      if (["/", "\\"].includes(filename[filename.length - 1])) {
        await action.doAction("addDirectory", node, [filename]);
        return;
      }
      const putTargetNode = file.getPutTargetNode(node);
      const targetPath = import_path16.default.join(putTargetNode.fullpath, filename);
      await overwritePrompt(
        "add file",
        [
          {
            source: void 0,
            target: targetPath
          }
        ],
        async (_source, target) => {
          await fsTouch(target);
        }
      );
      await file.view.sync(async (r) => {
        const loadNode = putTargetNode.parent ?? putTargetNode;
        const reloadNotifier = await file.loadNotifier(r, loadNode);
        const [, notifiers] = await file.revealNodeByPathNotifier(
          r,
          targetPath.replace(/(\/|\\)$/, ""),
          {
            startNode: loadNode
          }
        );
        await Notifier.runAll([reloadNotifier, ...notifiers]);
      });
    },
    "add a new file"
  );
  action.addNodeAction(
    "addDirectory",
    async ({ node, args }) => {
      let directoryName = args[0] ?? await input("Input a new directory name:", "", "file");
      directoryName = directoryName.trim().replace(/(\/|\\)*$/g, "");
      if (!directoryName) {
        return;
      }
      const putTargetNode = file.getPutTargetNode(node);
      const targetPath = import_path16.default.join(putTargetNode.fullpath, directoryName);
      await overwritePrompt(
        "add directory",
        [
          {
            source: void 0,
            target: targetPath
          }
        ],
        async (_source, target) => {
          await fsMkdirp(target);
        }
      );
      await file.view.sync(async (r) => {
        const revealRoot = putTargetNode.parent ?? putTargetNode;
        const reloadNotifier = await file.loadNotifier(r, revealRoot);
        const [, revealNotifiers] = await file.revealNodeByPathNotifier(
          r,
          targetPath,
          {
            startNode: revealRoot
          }
        );
        await Notifier.runAll([reloadNotifier, ...revealNotifiers]);
      });
    },
    "add a new directory"
  );
  action.addNodeAction(
    "rename",
    async ({ node }) => {
      if (file.bufManager.modified(node.fullpath, {
        directory: node.directory
      }) && await prompt("Buffer is being modified, discard it?") !== "yes") {
        return;
      }
      let targetPath;
      targetPath = await input(
        `Rename: ${node.fullpath} ->`,
        node.fullpath,
        "file"
      );
      targetPath = targetPath == null ? void 0 : targetPath.trim();
      if (!targetPath) {
        return;
      }
      await overwritePrompt(
        "rename",
        [
          {
            source: node.fullpath,
            target: targetPath
          }
        ],
        fsRename
      );
      await file.bufManager.replace(node.fullpath, targetPath, {
        skipModified: true,
        bwipeout: true,
        directory: node.directory
      });
    },
    "rename a file or directory",
    { reload: true }
  );
  action.addNodesAction(
    "systemExecute",
    async ({ nodes }) => {
      if (nodes) {
        await Promise.all(nodes.map((node) => (0, import_open.default)(node.fullpath)));
      } else {
        await (0, import_open.default)(file.root);
      }
    },
    "use system application open file or directory"
  );
  if (isWindows2) {
    action.addNodeAction(
      "listDrive",
      async () => {
        const drives = await listDrive();
        await startCocList(
          file.explorer,
          driveList,
          drives.map((drive) => ({
            name: drive,
            callback: async (drive2) => {
              file.root = drive2;
              await file.view.expand(file.view.rootNode);
            }
          })),
          ["--normal", "--number-select"]
        );
      },
      "list drives"
    );
  }
  action.addNodeAction(
    "search",
    async ({ node, args }) => {
      const searchOptions = (args[0] ?? "").split("|");
      const recursive = searchOptions.includes("recursive");
      const strict = searchOptions.includes("strict");
      const noIgnore = searchOptions.includes("noIgnore");
      await file.searchByCocList(
        node.isRoot ? node.fullpath : import_path16.default.dirname(node.fullpath),
        { recursive, noIgnore, strict }
      );
    },
    "search by coc-list, the ignore function requires the fd command",
    {
      args: [
        {
          name: "search options",
          description: searchOptionList.join(" | ")
        }
      ],
      menus: {
        noIgnore: "no ignore",
        recursive: "recursively",
        "recursive|noIgnore": "recursively and no ignore",
        strict: "exact match",
        "recursive|strict": "recursively and strict"
      }
    }
  );
  action.addNodeAction(
    "searchRecursive",
    async ({ node }) => {
      logger.error(
        'searchRecursive action has been deprecated, please use "search:recursive" instead of it'
      );
      await file.searchByCocList(import_path16.default.dirname(node.fullpath), {
        recursive: true,
        noIgnore: false,
        strict: false
      });
    },
    "search by coc-list recursively"
  );
  action.addNodeAction(
    "toggleOnlyGitChange",
    async () => {
      file.showOnlyGitChange = !file.showOnlyGitChange;
      await file.view.sync(async (r) => {
        const loadNotifier = await file.loadNotifier(r, file.view.rootNode, {
          force: true
        });
        nvim.pauseNotification();
        file.highlight.clearHighlightsNotify();
        loadNotifier == null ? void 0 : loadNotifier.notify();
        await nvim.resumeNotification();
      });
    },
    "toggle visibility of git change node",
    { reload: true }
  );
}

// src/source/sources/file/fileColumnRegistrar.ts
var FileColumnRegistrar = class extends ColumnRegistrar {
};
var fileColumnRegistrar = new FileColumnRegistrar();

// src/source/sources/file/root-columns/icon.ts
fileColumnRegistrar.registerColumn("root", "icon", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(
          source.view.isExpanded(node) ? source.icons.expanded : source.icons.collapsed,
          { hl: fileHighlights.expandIcon }
        );
      }
    };
  }
}));

// src/source/sources/file/root-columns/git.ts
fileColumnRegistrar.registerColumn(
  "root",
  "git",
  ({ source, subscriptions }) => {
    const icons = getRootStatusIcons(source.config);
    return {
      init() {
        subscriptions.push(gitManager.bindColumn(source));
      },
      async draw() {
        return {
          labelVisible({ node }) {
            var _a;
            return !!((_a = gitManager.getRootStatus(node.fullpath)) == null ? void 0 : _a.formats.length);
          },
          async available() {
            return await gitManager.cmd.available();
          },
          drawNode(row, { node, isLabeling }) {
            const status = gitManager.getRootStatus(node.fullpath);
            if (status == null ? void 0 : status.formats.length) {
              const statusChars = [];
              for (const f of status.formats) {
                if (isLabeling) {
                  statusChars.push(`${icons[f].name}(${icons[f].icon})`);
                } else {
                  statusChars.push(icons[f].icon);
                }
              }
              const hl = status.allStaged ? gitHighlights.staged : gitHighlights.unstaged;
              if (isLabeling) {
                row.add(statusChars.join(" & "), {
                  hl
                });
              } else {
                row.add(`{${statusChars.join("")}}`, {
                  hl
                });
              }
            }
          }
        };
      }
    };
  }
);

// src/source/sources/file/root-columns/title.ts
fileColumnRegistrar.registerColumn("root", "title", () => ({
  draw() {
    return {
      drawNode(row) {
        row.add("[FILE]", {
          hl: fileHighlights.title
        });
      }
    };
  }
}));

// src/source/sources/file/root-columns/hidden.ts
fileColumnRegistrar.registerColumn("root", "hidden", ({ source }) => ({
  draw() {
    return {
      drawNode(row) {
        row.add(source.showHidden ? source.icons.hidden : "", {
          hl: fileHighlights.hidden
        });
      }
    };
  }
}));

// src/source/sources/file/root-columns/root.ts
var import_path17 = __toESM(require("path"));
fileColumnRegistrar.registerColumn("root", "root", ({ source }) => ({
  draw() {
    return {
      drawNode(row) {
        row.add(import_path17.default.basename(source.root), { hl: fileHighlights.rootName });
      }
    };
  }
}));

// src/source/sources/file/root-columns/fullpath.ts
fileColumnRegistrar.registerColumn("root", "fullpath", () => ({
  draw() {
    return {
      drawNode(row, { node, isLabeling }) {
        row.add(displayedFullpath(node.fullpath), {
          hl: isLabeling ? fileHighlights.directory : fileHighlights.fullpath
        });
      }
    };
  }
}));

// src/source/sources/file/child-columns/git.ts
fileColumnRegistrar.registerColumn(
  "child",
  "git",
  ({ source, subscriptions }) => {
    const filenameHighlight = new FilenameHighlight(source.config);
    const icons = getStatusIcons(source.config);
    const getHighlight = (fullpath, staged, isDirectory) => {
      if (staged) {
        return gitHighlights.staged;
      } else {
        return filenameHighlight.getHighlight(fullpath, isDirectory, ["git"]) ?? gitHighlights.unstaged;
      }
    };
    return {
      init() {
        subscriptions.push(gitManager.bindColumn(source));
      },
      async available() {
        return await gitManager.cmd.available();
      },
      async draw() {
        return {
          async labelVisible({ node }) {
            const status = gitManager.getMixedStatus(
              node.fullpath,
              node.directory
            );
            if (!status) {
              return false;
            }
            return status.x !== " " /* unmodified */ || status.y !== " " /* unmodified */;
          },
          drawNode(row, { node, nodeIndex, isLabeling }) {
            const showFormat = (f, staged) => {
              const hl = getHighlight(node.fullpath, staged, node.directory);
              if (isLabeling) {
                row.add(`${icons[f].name}(${icons[f].icon})`, {
                  hl
                });
              } else {
                row.add(icons[f].icon, {
                  hl
                });
              }
            };
            const status = gitManager.getMixedStatus(
              node.fullpath,
              node.directory
            );
            if (status) {
              showFormat(status.x, true);
              if (isLabeling) {
                row.add(" ");
              }
              showFormat(status.y, false);
              if (status.x === "!" /* ignored */) {
                source.locator.mark.remove("git", nodeIndex);
                source.locator.mark.remove("gitStaged", nodeIndex);
                source.locator.mark.remove("gitUnstaged", nodeIndex);
              } else {
                source.locator.mark.add("git", nodeIndex);
                if (status.x !== " " /* unmodified */) {
                  source.locator.mark.add("gitStaged", nodeIndex);
                } else {
                  source.locator.mark.remove("gitStaged", nodeIndex);
                }
                if (status.y !== " " /* unmodified */) {
                  source.locator.mark.add("gitUnstaged", nodeIndex);
                } else {
                  source.locator.mark.remove("gitUnstaged", nodeIndex);
                }
              }
            } else {
              source.locator.mark.remove("git", nodeIndex);
              source.locator.mark.remove("gitStaged", nodeIndex);
              source.locator.mark.remove("gitUnstaged", nodeIndex);
            }
          }
        };
      }
    };
  }
);

// src/source/sources/file/child-columns/selection.ts
fileColumnRegistrar.registerColumn("child", "selection", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (source.isSelectedNode(node)) {
          row.add(source.icons.selected);
        }
      }
    };
  }
}));

// src/icon/loader.ts
var IconLoader = class {
};
var getLoaders = {};
function registerLoader(iconSourceType, getLoader2) {
  getLoaders[iconSourceType] = getLoader2;
}
var loadersCache = /* @__PURE__ */ new Map();
function getLoader(source) {
  if (!loadersCache.has(source)) {
    const getLoader2 = getLoaders[source];
    if (!getLoader2) {
      return;
    }
    loadersCache.set(source, getLoader2());
  }
  return loadersCache.get(source);
}

// src/icon/nerdfont.ts
var import_color_convert4 = __toESM(require_color_convert());

// src/icon/icons.nerdfont.json
var icons_nerdfont_default = {
  $schema: "./icons.nerdfont.schema.json",
  icons: {
    folderClosed: {
      code: "\uE5FF",
      color: "#00afaf"
    },
    folderOpened: {
      code: "\uE5FE",
      color: "#00afaf"
    },
    folderSymlink: {
      code: "\uEAED",
      color: "#00afaf"
    },
    folderNpm: {
      code: "\uE5FA",
      color: "#00afaf"
    },
    file: {
      code: "\uF15B",
      color: "#999999"
    },
    fileSymlink: {
      code: "\uF481",
      color: "#999999"
    },
    fileHidden: {
      code: "\uF016",
      color: "#999999"
    },
    excel: {
      code: "\uF1C3",
      color: "#207245"
    },
    word: {
      code: "\uF1C2",
      color: "#185abd"
    },
    ppt: {
      code: "\uF1C4",
      color: "#cb4a32"
    },
    stylus: {
      code: "\uE600",
      color: "#8dc149"
    },
    sass: {
      code: "\uE603",
      color: "#f55385"
    },
    html: {
      code: "\uE60E",
      color: "#e37933"
    },
    xml: {
      code: "\uE60E",
      "code.origin": "\uE619",
      color: "#e37933"
    },
    ejs: {
      code: "\uE618",
      color: "#cbcb41"
    },
    css: {
      code: "\uE614",
      color: "#519aba"
    },
    webpack: {
      code: "\uE6A3",
      color: "#519aba"
    },
    markdown: {
      code: "\uE609",
      color: "#519aba"
    },
    json: {
      code: "\uE60B",
      color: "#cbcb41"
    },
    javascript: {
      code: "\uE60C",
      color: "#cbcb41"
    },
    javascriptreact: {
      code: "\uE7BA",
      color: "#519aba"
    },
    ruby: {
      code: "\uE791",
      color: "#cc3e44"
    },
    php: {
      code: "\uE608",
      color: "#a074c4"
    },
    python: {
      code: "\uE606",
      color: "#519aba"
    },
    coffee: {
      code: "\uE61B",
      color: "#cbcb41"
    },
    mustache: {
      code: "\uE60F",
      color: "#e37933"
    },
    conf: {
      code: "\uE615",
      color: "#6d8086"
    },
    video: {
      code: "\uEAD9",
      color: "#dc5285"
    },
    audio: {
      code: "\uE638",
      color: "#a074c4"
    },
    photoshop: {
      code: "\uE67F",
      color: "#001d34"
    },
    image: {
      code: "\uE60D",
      color: "#a074c4"
    },
    ai: {
      code: "\uE7B4",
      color: "#cbcb41"
    },
    psd: {
      code: "\uE7B8",
      color: "#519aba"
    },
    ico: {
      code: "\uE60D",
      color: "#cbcb41"
    },
    twig: {
      code: "\uE61C",
      color: "#8dc149"
    },
    c: {
      code: "\uE61E",
      color: "#a074c4"
    },
    cpp: {
      code: "\uE61D",
      color: "#519aba"
    },
    h: {
      code: "\uF0FD",
      color: "#a074c4"
    },
    haskell: {
      code: "\uE61F",
      color: "#a074c4"
    },
    lua: {
      code: "\uE620",
      color: "#519aba"
    },
    java: {
      code: "\uE738",
      color: "#cc3e44"
    },
    kotlin: {
      code: "\u0138",
      color: "#5674d4"
    },
    terminal: {
      code: "\uE795",
      color: "#4d5a5e"
    },
    ml: {
      code: "\u03BB",
      color: "#e37933"
    },
    diff: {
      code: "\uE728",
      color: "#41535b"
    },
    sql: {
      code: "\uE706",
      color: "#f55385"
    },
    clojure: {
      code: "\uE768",
      color: "#8dc149"
    },
    edn: {
      code: "\uE76A",
      color: "#519aba"
    },
    scala: {
      code: "\uE737",
      color: "#cc3e44"
    },
    go: {
      code: "\uE627",
      color: "#519aba"
    },
    dart: {
      code: "\uE798",
      color: "#03589C"
    },
    firefox: {
      code: "\uE745",
      color: "#e37933"
    },
    vs: {
      code: "\uE70C",
      color: "#854CC7"
    },
    perl: {
      code: "\uE769",
      color: "#519aba"
    },
    rss: {
      code: "\uE619",
      color: "#fb9d3b"
    },
    csharp: {
      code: "\uE648",
      color: "#519aba"
    },
    fsharp: {
      code: "\uE7A7",
      color: "#519aba"
    },
    rust: {
      code: "\uE7A8",
      color: "#519aba"
    },
    dlang: {
      code: "\uE7AF",
      color: "#cc3e44"
    },
    erlang: {
      code: "\uE7B1",
      color: "#A90533"
    },
    elixir: {
      code: "\uE62D",
      color: "#a074c4"
    },
    elm: {
      code: "\uE62C",
      color: "#519aba"
    },
    mix: {
      code: "\uE62D",
      color: "#cc3e44"
    },
    vim: {
      code: "\uE62B",
      color: "#019833"
    },
    typescript: {
      code: "\uE628",
      color: "#519aba"
    },
    typescriptreact: {
      code: "\uE7BA",
      color: "#519aba"
    },
    julia: {
      code: "\uE624",
      color: "#a074c4"
    },
    puppet: {
      code: "\uF499",
      color: "#cbcb41"
    },
    vue: {
      code: "\uE6A0",
      color: "#8dc149"
    },
    swift: {
      code: "\uE755",
      color: "#e37933"
    },
    git: {
      code: "\uE725",
      color: "#41535b"
    },
    bashrc: {
      code: "\uE615",
      color: "#4d5a5e"
    },
    favicon: {
      code: "\uE623",
      color: "#cbcb41"
    },
    docker: {
      code: "\uE7B0",
      color: "#519aba"
    },
    gruntfile: {
      code: "\uE611",
      color: "#e37933"
    },
    gulpfile: {
      code: "\uE610",
      color: "#cc3e44"
    },
    dropbox: {
      code: "\uE707",
      color: "#0061FE"
    },
    license: {
      code: "\uE60A",
      color: "#cbcb41"
    },
    procfile: {
      code: "\uE607",
      color: "#a074c4"
    },
    jquery: {
      code: "\uE750",
      color: "#1B75BB"
    },
    angular: {
      code: "\uE753",
      color: "#E23237"
    },
    backbone: {
      code: "\uE752",
      color: "#0071B5"
    },
    requirejs: {
      code: "\uE770",
      color: "#F44A41"
    },
    materialize: {
      code: "\uE7B6",
      color: "#EE6E73"
    },
    mootools: {
      code: "\uE78F",
      color: "#ECECEC"
    },
    vagrant: {
      code: "\uF2B8",
      color: "#1563FF"
    },
    svg: {
      code: "\uE698",
      color: "#FFB13B"
    },
    font: {
      code: "\uF031",
      color: "#999999"
    },
    text: {
      code: "\uF15C",
      color: "#999999"
    },
    archive: {
      code: "\uF1C6",
      color: "#cc3e44"
    },
    lock: {
      code: "\uF023",
      color: "#999999"
    }
  },
  extensions: {
    styl: "stylus",
    sass: "sass",
    scss: "sass",
    htm: "html",
    html: "html",
    slim: "html",
    xml: "xml",
    xaml: "xml",
    ejs: "ejs",
    css: "css",
    less: "css",
    md: "markdown",
    mdx: "markdown",
    markdown: "markdown",
    rmd: "markdown",
    lock: "lock",
    json: "json",
    js: "javascript",
    cjs: "javascript",
    mjs: "javascript",
    es6: "javascript",
    jsx: "javascriptreact",
    rb: "ruby",
    ru: "ruby",
    php: "php",
    py: "python",
    pyc: "python",
    pyo: "python",
    pyd: "python",
    coffee: "coffee",
    mustache: "mustache",
    hbs: "mustache",
    config: "conf",
    conf: "conf",
    ini: "conf",
    yml: "conf",
    yaml: "conf",
    toml: "conf",
    avi: "video",
    flv: "video",
    m1v: "video",
    m2v: "video",
    mk3d: "video",
    mks: "video",
    mkv: "video",
    mov: "video",
    movie: "video",
    mp4: "video",
    mp4v: "video",
    mpe: "video",
    mpeg: "video",
    mpg: "video",
    mpg4: "video",
    ogv: "video",
    qt: "video",
    webm: "video",
    wmv: "video",
    aac: "audio",
    m2a: "audio",
    m3a: "audio",
    mid: "audio",
    midi: "audio",
    mp2: "audio",
    mp2a: "audio",
    mp3: "audio",
    mp4a: "audio",
    mpga: "audio",
    oga: "audio",
    ogg: "audio",
    opus: "audio",
    spx: "audio",
    wav: "audio",
    wma: "audio",
    jpg: "image",
    jpe: "image",
    jpeg: "image",
    bmp: "image",
    png: "image",
    gif: "image",
    webp: "image",
    tga: "image",
    tif: "image",
    tiff: "image",
    ai: "ai",
    psd: "psd",
    psb: "psd",
    ico: "ico",
    twig: "twig",
    cpp: "cpp",
    "c++": "cpp",
    cxx: "cpp",
    cc: "cpp",
    cp: "cpp",
    c: "c",
    h: "h",
    hh: "h",
    hpp: "h",
    hxx: "h",
    hs: "haskell",
    lhs: "haskell",
    lua: "lua",
    java: "java",
    jar: "java",
    kt: "kotlin",
    kts: "kotlin",
    sh: "terminal",
    fish: "terminal",
    bash: "terminal",
    zsh: "terminal",
    ksh: "terminal",
    csh: "terminal",
    awk: "terminal",
    ps1: "terminal",
    bat: "terminal",
    cmd: "terminal",
    ml: "ml",
    mli: "ml",
    diff: "diff",
    db: "sql",
    sql: "sql",
    dump: "sql",
    accdb: "sql",
    clj: "clojure",
    cljc: "clojure",
    cljs: "clojure",
    edn: "edn",
    scala: "scala",
    go: "go",
    dart: "dart",
    xul: "firefox",
    pl: "perl",
    pm: "perl",
    t: "perl",
    rss: "rss",
    sln: "vs",
    suo: "vs",
    csproj: "vs",
    cs: "csharp",
    fsscript: "fsharp",
    fsx: "fsharp",
    fs: "fsharp",
    fsi: "fsharp",
    rs: "rust",
    rlib: "rust",
    d: "dlang",
    erl: "erlang",
    hrl: "erlang",
    ex: "elixir",
    eex: "elixir",
    exs: "elixir",
    exx: "elixir",
    leex: "elixir",
    vim: "vim",
    ts: "typescript",
    tsx: "javascriptreact",
    jl: "julia",
    pp: "puppet",
    vue: "vue",
    elm: "elm",
    swift: "swift",
    xcplayground: "swift",
    svg: "svg",
    otf: "font",
    ttf: "font",
    fnt: "font",
    txt: "text",
    text: "text",
    zip: "archive",
    tar: "archive",
    gz: "archive",
    gzip: "archive",
    rar: "archive",
    "7z": "archive",
    iso: "archive",
    doc: "word",
    docx: "word",
    docm: "word",
    csv: "excel",
    xls: "excel",
    xlsx: "excel",
    xlsm: "excel",
    ppt: "ppt",
    pptx: "ppt",
    pptm: "ppt"
  },
  filenames: {
    gruntfile: "gruntfile",
    gulpfile: "gulpfile",
    gemfile: "ruby",
    guardfile: "ruby",
    capfile: "ruby",
    rakefile: "ruby",
    gradlew: "terminal",
    mix: "mix",
    dropbox: "dropbox",
    vimrc: "vim",
    ".vimrc": "vim",
    ".gvimrc": "vim",
    _vimrc: "vim",
    _gvimrc: "vim",
    license: "license",
    procfile: "procfile",
    Vagrantfile: "vagrant",
    "docker-compose.yml": "docker",
    ".gitconfig": "git",
    ".gitignore": "git",
    webpack: "webpack",
    ".bashrc": "bashrc",
    ".zshrc": "bashrc",
    ".bashprofile": "bashrc",
    "favicon.ico": "favicon",
    dockerfile: "docker",
    ".dockerignore": "docker"
  },
  patternMatches: {
    ".*jquery.*.js$": "jquery",
    ".*angular.*.js$": "angular",
    ".*backbone.*.js$": "backbone",
    ".*require.*.js$": "requirejs",
    ".*materialize.*.js$": "materialize",
    ".*materialize.*.css$": "materialize",
    ".*mootools.*.js$": "mootools"
  },
  dirnames: {
    ".git": "git",
    node_modules: "javascript"
  },
  dirPatternMatches: {}
};

// src/icon/nerdfont.ts
var nerdfont = icons_nerdfont_default;
var customIcon = config.get("icon.customIcons", {});
Object.assign(nerdfont.icons, customIcon.icons);
Object.assign(nerdfont.extensions, customIcon.extensions);
Object.assign(nerdfont.filenames, customIcon.filenames);
Object.assign(nerdfont.dirnames, customIcon.dirnames);
Object.assign(nerdfont.patternMatches, customIcon.patternMatches);
Object.assign(nerdfont.dirPatternMatches, customIcon.dirPatternMatches);
var nerdfontHighlights = {};
Object.entries(nerdfont.icons).forEach(([name, icon]) => {
  const color = parseColor(icon.color);
  if (!color) {
    return;
  }
  const ansiColor = import_color_convert4.default.rgb.ansi256([color.red, color.green, color.blue]);
  const hlExpr = `ctermfg=${ansiColor} guifg=${icon.color}`;
  nerdfontHighlights[name] = hlGroupManager.createGroup(
    `FileIconNerdfont_${name}`,
    hlExpr
  );
});

// src/icon/loaders/builtin-icons.ts
var BuiltinIconLoader = class extends IconLoader {
  async loadIcons(targets) {
    var _a;
    const loaded = [];
    for (const target of targets) {
      const icon = target.isDirectory ? this.getDirectoryIcon(target) : this.getFileIcon(target);
      if (icon) {
        icon.highlight = (_a = nerdfontHighlights[icon.name]) == null ? void 0 : _a.group;
        loaded.push({
          icon,
          target
        });
      }
    }
    return loaded;
  }
  nerdfontToIcon(name) {
    const icon = nerdfont.icons[name];
    if (icon) {
      return {
        name,
        ...nerdfont.icons[name]
      };
    }
  }
  getFileIcon(target) {
    const { fullname, basename: basename2, extensions: extensions3 } = target;
    const extname = extensions3[extensions3.length - 1];
    if (hasOwnProperty14(nerdfont.filenames, basename2)) {
      const name = nerdfont.filenames[basename2];
      return this.nerdfontToIcon(name);
    }
    if (hasOwnProperty14(nerdfont.filenames, fullname)) {
      const name = nerdfont.filenames[fullname];
      return this.nerdfontToIcon(name);
    }
    const matched = Object.entries(nerdfont.patternMatches).find(
      ([pattern]) => new RegExp(pattern).test(fullname)
    );
    if (matched) {
      const name = matched[1];
      return this.nerdfontToIcon(name);
    }
    if (hasOwnProperty14(nerdfont.extensions, extname)) {
      const name = nerdfont.extensions[extname];
      return this.nerdfontToIcon(name);
    }
  }
  getDirectoryIcon(target) {
    const { basename: basename2, fullname: dirname } = target;
    if (hasOwnProperty14(nerdfont.dirnames, basename2)) {
      const name = nerdfont.dirnames[basename2];
      return this.nerdfontToIcon(name);
    }
    if (hasOwnProperty14(nerdfont.dirnames, dirname)) {
      const name = nerdfont.dirnames[dirname];
      return this.nerdfontToIcon(name);
    }
    const matched = Object.entries(nerdfont.dirPatternMatches).find(
      ([pattern]) => new RegExp(pattern).test(dirname)
    );
    if (matched) {
      const name = matched[1];
      return this.nerdfontToIcon(name);
    }
  }
};
registerLoader("builtin", () => new BuiltinIconLoader());

// src/icon/loaders/nvim-web-devicons.ts
var import_coc58 = require("coc.nvim");
var NvimWebDeviconsLoader = class extends IconLoader {
  escapeLuaString(name, qoute = "'") {
    return name ? name.replace(/\\/g, "\\").replace(new RegExp(qoute, "g"), "\\'") : name;
  }
  async loadIcons(targets) {
    const loaded = [];
    for (const target of targets) {
      if (target.isDirectory) {
        continue;
      }
      const ext = target.extensions[target.extensions.length - 1];
      const result = await import_coc58.workspace.nvim.call("luaeval", [
        "{require'nvim-web-devicons'.get_icon(_A[1], _A[2])}",
        [target.fullname, ext]
      ]);
      const [code, highlight] = result;
      if (!code) {
        continue;
      }
      loaded.push({
        target,
        icon: {
          code,
          highlight
        }
      });
    }
    return loaded;
  }
};
registerLoader("nvim-web-devicons", () => new NvimWebDeviconsLoader());

// src/icon/loaders/vim-devicons.ts
var import_coc59 = require("coc.nvim");
var VimDeviconsLoader = class extends IconLoader {
  async loadIcons(targets) {
    const loaded = [];
    await Promise.all(
      targets.map(async (target) => {
        if (target.isDirectory) {
          return;
        }
        const code = await import_coc59.workspace.nvim.call("WebDevIconsGetFileTypeSymbol", [
          target.fullname,
          false
        ]);
        if (!code) {
          return;
        }
        loaded.push({
          target,
          icon: {
            code
          }
        });
      })
    );
    return loaded;
  }
};
registerLoader("vim-devicons", () => new VimDeviconsLoader());

// src/icon/loaders/nerdfont.vim.ts
var import_coc60 = require("coc.nvim");
var NerdfontVimLoader = class extends IconLoader {
  async loadIcons(targets) {
    const loaded = [];
    await Promise.all(
      targets.map(async (target) => {
        const code = await import_coc60.workspace.nvim.call("nerdfont#find", [
          target.fullname,
          target.isDirectory
        ]);
        if (!code) {
          return;
        }
        loaded.push({
          target,
          icon: {
            code
          }
        });
      })
    );
    return loaded;
  }
};
registerLoader("nerdfont.vim", () => new NerdfontVimLoader());

// src/icon/icons.ts
function parseTargets(targets) {
  return targets.map((target) => {
    return {
      fullname: target.fullname,
      ...getExtensions(target.fullname.toLowerCase()),
      isDirectory: target.isDirectory,
      hidden: target.hidden,
      expanded: target.expanded
    };
  });
}
async function loadIcons(sourceType, targets) {
  const parsedTargets = parseTargets(targets);
  const loader = getLoader(sourceType);
  if (!loader) {
    return;
  }
  const loadedIcons = await loader.loadIcons(parsedTargets);
  const [directoryIcons, fileIcons] = partition_default(
    loadedIcons,
    (it) => it.target.isDirectory
  );
  const fullname2directoryIcon = keyBy_default(
    directoryIcons,
    (it) => it.target.fullname
  );
  const fullname2fileIcon = keyBy_default(fileIcons, (it) => it.target.fullname);
  const result = {
    files: /* @__PURE__ */ new Map(),
    directories: /* @__PURE__ */ new Map()
  };
  for (const target of targets) {
    if (hasOwnProperty14(fullname2directoryIcon, target.fullname)) {
      result.directories.set(
        target.fullname,
        fullname2directoryIcon[target.fullname].icon
      );
    } else if (hasOwnProperty14(fullname2fileIcon, target.fullname)) {
      result.files.set(
        target.fullname,
        fullname2fileIcon[target.fullname].icon
      );
    } else if (target.isDirectory) {
      const code = target.expanded ? nerdfont.icons.folderOpened.code : nerdfont.icons.folderClosed.code;
      result.directories.set(target.fullname, {
        code
      });
    } else {
      const code = target.hidden ? nerdfont.icons.fileHidden.code : nerdfont.icons.file.code;
      result.files.set(target.fullname, { code });
    }
  }
  return result;
}
async function loadIconsByConfig(config4, targets) {
  const enabledVimDevicons = config4.get("icon.enableVimDevicons");
  if (enabledVimDevicons) {
    logger.error(
      'The configuration `explorer.icon.enableVimDevicons` has been deprecated, please use `{"explorer.icon.enableNerdFont": true, "explorer.icon.source": "vim-devicons"}` instead of it'
    );
    return loadIcons("vim-devicons", targets);
  }
  const enabledNerdFont = config4.get("icon.enableNerdfont");
  if (!enabledNerdFont) {
    return;
  }
  const source = config4.get("icon.source");
  return loadIcons(source, targets);
}

// src/source/sources/file/child-columns/icon.ts
fileColumnRegistrar.registerColumn("child", "icon", ({ source }) => ({
  async draw(nodes) {
    const iconTargets = nodes.map((node) => {
      var _a;
      return {
        fullname: ((_a = node.compactedLastNode) == null ? void 0 : _a.name) ?? node.name,
        hidden: node.hidden,
        isDirectory: node.directory,
        expanded: node.directory ? source.view.isExpanded(node) : void 0
      };
    });
    const icons = await loadIconsByConfig(source.config, iconTargets);
    return {
      async drawNode(row, { node }) {
        var _a;
        if (node.directory) {
          const hl = source.view.isExpanded(node) ? fileHighlights.directoryExpanded : fileHighlights.directoryCollapsed;
          const icon = icons == null ? void 0 : icons.directories.get(
            ((_a = node.compactedLastNode) == null ? void 0 : _a.name) ?? node.name
          );
          if (icon) {
            row.add(icon.code, { hl });
          } else {
            row.add(
              source.view.isExpanded(node) ? source.icons.expanded : source.icons.collapsed,
              { hl }
            );
          }
        } else {
          const icon = icons == null ? void 0 : icons.files.get(node.name);
          if (icon) {
            row.add(icon.code, {
              hl: icon.highlight ?? nerdfontHighlights.file
            });
          }
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/filename.ts
fileColumnRegistrar.registerColumn(
  "child",
  "filename",
  ({ source, subscriptions }) => {
    const filenameHighlight = new FilenameHighlight(source.config);
    const getHighlight = (fullpath, isDirectory) => {
      return filenameHighlight.getHighlight(fullpath, isDirectory, [
        "diagnosticError",
        "diagnosticWarning",
        "git"
      ]) ?? (isDirectory ? fileHighlights.directory : fileHighlights.filename);
    };
    const diagnosticTypes = [];
    if (filenameHighlight.enabledErrorStatus) {
      diagnosticTypes.push("error");
    }
    if (filenameHighlight.enabledWarningStatus) {
      diagnosticTypes.push("warning");
    }
    return {
      init() {
        subscriptions.push(
          diagnosticManager.bindColumn(source, diagnosticTypes),
          gitManager.bindColumn(source)
        );
      },
      draw() {
        return {
          async drawNode(row, { node }) {
            row.add(node.name, {
              hl: getHighlight(node.fullpath, node.directory),
              unicode: true
            });
          }
        };
      }
    };
  }
);

// src/source/sources/file/child-columns/linkIcon.ts
fileColumnRegistrar.registerColumn("child", "linkIcon", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (node.symbolicLink) {
          row.add(source.icons.link, { hl: fileHighlights.linkTarget });
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/link.ts
fileColumnRegistrar.registerColumn("child", "link", () => ({
  draw() {
    return {
      labelVisible: ({ node }) => node.symbolicLink,
      async drawNode(row, { node }) {
        const linkTarget = node.symbolicLink ? await fsReadlink(node.fullpath).then((link) => link).catch(() => "") : "";
        if (linkTarget) {
          row.add(linkTarget, { hl: fileHighlights.linkTarget, unicode: true });
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/fullpath.ts
var import_path18 = __toESM(require("path"));
fileColumnRegistrar.registerColumn("child", "fullpath", () => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (node.directory) {
          row.add(displayedFullpath(node.fullpath) + import_path18.default.sep, {
            hl: fileHighlights.directory
          });
        } else {
          row.add(node.fullpath);
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/indent.ts
function printIndentLine(node) {
  var _a, _b;
  let row = "";
  if ((_a = node.parent) == null ? void 0 : _a.isRoot) {
    return row;
  }
  if (node.nextSiblingNode === void 0) {
    row = "\u2514 ";
  } else {
    row = "\u2502 ";
  }
  let curNode = node.parent;
  while (curNode) {
    if ((_b = curNode.parent) == null ? void 0 : _b.isRoot) {
      break;
    }
    if (curNode.nextSiblingNode === void 0) {
      row = `  ${row}`;
    } else {
      row = `\u2502 ${row}`;
    }
    curNode = curNode.parent;
  }
  return row;
}
fileColumnRegistrar.registerColumn("child", "indent", ({ source }) => ({
  draw() {
    const enabledNerdFont = source.config.get("icon.enableNerdfont");
    const enableIndentLine = (() => {
      const indentLine = source.getColumnConfig(
        "indent.indentLine"
      );
      if (enabledNerdFont && indentLine === void 0) {
        return true;
      } else {
        return indentLine;
      }
    })();
    return {
      drawNode(row, { node }) {
        if (enableIndentLine) {
          row.add(printIndentLine(node), { hl: fileHighlights.indentLine });
        } else {
          row.add(
            source.getColumnConfig("indent.chars").repeat((node.level ?? 0) - 1)
          );
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/clip.ts
fileColumnRegistrar.registerColumn("child", "clip", ({ source }) => ({
  async draw() {
    let copy = source.getColumnConfig("clip.copy");
    let cut = source.getColumnConfig("clip.cut");
    if (source.config.get("icon.enableNerdfont")) {
      copy = copy ?? "\uF0C5";
      cut = cut ?? "\uF0C4";
    } else {
      copy = copy ?? "C";
      cut = cut ?? "X";
    }
    const clipboardStorage = source.explorer.explorerManager.clipboardStorage;
    const content = await clipboardStorage.getFiles();
    const fullpathSet = new Set(content.fullpaths);
    return {
      drawNode(row, { node }) {
        if (content.type === "none") {
          return;
        }
        const ch = fullpathSet.has(node.fullpath) ? content.type === "cut" ? cut : copy : "";
        if (ch) {
          row.add(ch, { hl: fileHighlights.clip });
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/size.ts
var import_pretty_bytes = __toESM(require_pretty_bytes());
fileColumnRegistrar.registerColumn("child", "size", () => ({
  draw() {
    return {
      labelVisible: ({ node }) => !node.directory,
      drawNode(row, { node }) {
        if (node.lstat) {
          row.add((0, import_pretty_bytes.default)(node.lstat.size), { hl: fileHighlights.size });
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/readonly.ts
fileColumnRegistrar.registerColumn("child", "readonly", ({ source }) => ({
  draw() {
    return {
      labelOnly: true,
      labelVisible: ({ node }) => node.readonly,
      drawNode(row, { node }) {
        if (node.readonly) {
          row.add(node.readonly ? source.icons.readonly : "", {
            hl: fileHighlights.readonly
          });
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/modified.ts
fileColumnRegistrar.registerColumn(
  "child",
  "modified",
  ({ source, subscriptions }) => {
    return {
      async init() {
        if (!source.explorer.isFloating) {
          subscriptions.push(
            source.bufManager.onModifiedDebounce(
              (fullpaths) => source.view.renderPaths(fullpaths)
            )
          );
        }
      },
      draw() {
        return {
          labelOnly: true,
          labelVisible: ({ node }) => source.bufManager.modified(node.fullpath, {
            directory: node.directory
          }),
          drawNode(row, { node, nodeIndex }) {
            const modified = source.bufManager.modified(
              node.fullpath,
              {
                directory: node.directory && !source.view.isExpanded(node)
              }
            );
            row.add(modified ? "+" : "", {
              hl: fileHighlights.readonly
            });
            modified ? source.locator.mark.add("modified", nodeIndex) : source.locator.mark.remove("modified", nodeIndex);
          }
        };
      }
    };
  }
);

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger2(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// node_modules/date-fns/esm/toDate/index.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof3(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

// node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger2(dirtyAmount);
  return new Date(timestamp + amount);
}

// node_modules/date-fns/esm/_lib/defaultOptions/index.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

// node_modules/date-fns/esm/isDate/index.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof3(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof2(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/esm/isValid/index.js
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

// node_modules/date-fns/esm/subMilliseconds/index.js
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger2(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

// node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger2((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger2((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger2((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}

// node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}

// node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
var formatters = {
  y: function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var lightFormatters_default = formatters;

// node_modules/date-fns/esm/_lib/format/formatters/index.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters2 = {
  G: function G(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function y2(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters_default.y(date, token);
  },
  Y: function Y(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  Q: function Q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function M2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters_default.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function L(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function w(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function I(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function d2(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters_default.d(date, token);
  },
  D: function D(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function E(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function e(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function c(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function i(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function a2(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function b(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function B(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function h2(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters_default.h(date, token);
  },
  H: function H2(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters_default.H(date, token);
  },
  K: function K(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function k(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function m2(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters_default.m(date, token);
  },
  s: function s2(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters_default.s(date, token);
  },
  S: function S2(date, token) {
    return lightFormatters_default.S(date, token);
  },
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var formatters_default = formatters2;

// node_modules/date-fns/esm/_lib/format/longFormatters/index.js
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters_default = longFormatters;

// node_modules/date-fns/esm/_lib/protectedTokens/index.js
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input2) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input2, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input2, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input2, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input2, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance_default = formatDistance;

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;

// node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
var formatRelative_default = formatRelative;

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context2 = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context2 === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex2(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex2(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;

// node_modules/date-fns/esm/locale/en-US/index.js
var locale = {
  code: "en-US",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var en_US_default = locale;

// node_modules/date-fns/esm/_lib/defaultLocale/index.js
var defaultLocale_default = en_US_default;

// node_modules/date-fns/esm/format/index.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  var firstWeekContainsDate = toInteger2((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input2) {
  var matched = input2.match(escapedStringRegExp);
  if (!matched) {
    return input2;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// src/source/sources/file/child-columns/timeModified.ts
fileColumnRegistrar.registerColumn("child", "timeModified", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (node.lstat) {
          row.add(
            format(node.lstat.mtime, source.config.get("datetime.format")),
            {
              hl: fileHighlights.timeModified
            }
          );
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/timeCreated.ts
fileColumnRegistrar.registerColumn("child", "timeCreated", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (node.lstat) {
          row.add(
            format(node.lstat.birthtime, source.config.get("datetime.format")),
            {
              hl: fileHighlights.timeCreated
            }
          );
        }
      }
    };
  }
}));

// src/source/sources/file/child-columns/timeAccessed.ts
fileColumnRegistrar.registerColumn("child", "timeAccessed", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (node.lstat) {
          row.add(
            format(node.lstat.atime, source.config.get("datetime.format")),
            {
              hl: fileHighlights.timeAccessed
            }
          );
        } else {
          row.add("                 ");
        }
      }
    };
  }
}));

// src/diagnostic/config.ts
var getDiagnosticConfig = (config4) => {
  const diagnosticConfig = {
    displayMax: config4.get("diagnostic.displayMax"),
    enableSubscriptNumber: config4.get(
      "diagnostic.enableSubscriptNumber"
    )
  };
  return diagnosticConfig;
};
var printDiagnosticCount = (count, config4) => {
  if (count > config4.displayMax) {
    return "\u2717";
  } else if (config4.enableSubscriptNumber) {
    return toSubscriptNumbers(count);
  } else {
    return count.toString();
  }
};

// src/source/sources/file/child-columns/diagnosticError.ts
fileColumnRegistrar.registerColumn(
  "child",
  "diagnosticError",
  ({ source, subscriptions }) => {
    const diagnosticConfig = getDiagnosticConfig(source.config);
    return {
      init() {
        subscriptions.push(diagnosticManager.bindColumn(source, ["error"]));
      },
      draw() {
        return {
          labelVisible: ({ node }) => !!diagnosticManager.getMixedError(node.fullpath),
          drawNode(row, { node, isLabeling }) {
            const errorCount = diagnosticManager.getMixedError(node.fullpath);
            if (isLabeling) {
              row.add((errorCount ?? 0).toString(), {
                hl: fileHighlights.diagnosticError
              });
              return;
            }
            if (!errorCount) {
              return;
            }
            if (node.directory && source.view.isExpanded(node)) {
              return;
            }
            row.add(printDiagnosticCount(errorCount, diagnosticConfig), {
              hl: fileHighlights.diagnosticError
            });
          }
        };
      }
    };
  }
);

// src/source/sources/file/child-columns/diagnosticWarning.ts
fileColumnRegistrar.registerColumn(
  "child",
  "diagnosticWarning",
  ({ source, subscriptions }) => {
    const diagnosticConfig = getDiagnosticConfig(source.config);
    return {
      init() {
        subscriptions.push(diagnosticManager.bindColumn(source, ["warning"]));
      },
      draw() {
        return {
          labelVisible: ({ node }) => !!diagnosticManager.getMixedWarning(node.fullpath),
          drawNode(row, { node, isLabeling }) {
            const warningCount = diagnosticManager.getMixedWarning(
              node.fullpath
            );
            if (isLabeling) {
              row.add((warningCount ?? 0).toString(), {
                hl: fileHighlights.diagnosticWarning
              });
              return;
            }
            if (!warningCount) {
              return;
            }
            if (node.expandable && source.view.isExpanded(node)) {
              return;
            }
            row.add(printDiagnosticCount(warningCount, diagnosticConfig), {
              hl: fileHighlights.diagnosticWarning
            });
          }
        };
      }
    };
  }
);

// src/source/sources/file/fileSource.ts
var hlg4 = hlGroupManager.linkGroup.bind(hlGroupManager);
var directoryHighlight = hlg4("FileDirectory", "Directory");
var fileHighlights = {
  title: hlg4("FileRoot", "Constant"),
  hidden: hlg4("FileHidden", internalHighlightGroups.CommentColor),
  rootName: hlg4("FileRootName", "Identifier"),
  expandIcon: hlg4("FileExpandIcon", "Directory"),
  fullpath: hlg4("FileFullpath", internalHighlightGroups.CommentColor),
  filename: hlg4("FileFilename", "None"),
  directory: directoryHighlight,
  directoryExpanded: hlg4("FileDirectoryExpanded", directoryHighlight.group),
  directoryCollapsed: hlg4("FileDirectoryCollapsed", directoryHighlight.group),
  linkTarget: hlg4("FileLinkTarget", internalHighlightGroups.CommentColor),
  indentLine: hlg4("IndentLine", internalHighlightGroups.CommentColor),
  clip: hlg4("FileClip", "Statement"),
  size: hlg4("FileSize", "Constant"),
  readonly: hlg4("FileReadonly", "Operator"),
  modified: hlg4("FileModified", "Operator"),
  timeAccessed: hlg4("TimeAccessed", "Identifier"),
  timeModified: hlg4("TimeModified", "Identifier"),
  timeCreated: hlg4("TimeCreated", "Identifier"),
  diagnosticError: hlg4(
    "FileDiagnosticError",
    diagnosticHighlights.diagnosticError.group
  ),
  diagnosticWarning: hlg4(
    "FileDiagnosticWarning",
    diagnosticHighlights.diagnosticWarning.group
  ),
  filenameDiagnosticError: hlg4("FileFilenameDiagnosticError", "CocErrorSign"),
  filenameDiagnosticWarning: hlg4(
    "FileFilenameDiagnosticWarning",
    "CocWarningSign"
  )
};
var FileSource = class extends ExplorerSource {
  constructor() {
    super(...arguments);
    this.scheme = "file";
    this.showHidden = this.config.get("file.showHiddenFiles");
    this.showOnlyGitChange = false;
    this.view = new ViewSource(
      this,
      fileColumnRegistrar,
      {
        type: "root",
        isRoot: true,
        uid: this.helper.getUid(import_path19.default.sep),
        name: "root",
        fullpath: (0, import_os4.homedir)(),
        expandable: true,
        directory: true,
        readonly: true,
        executable: false,
        readable: true,
        writable: true,
        hidden: false,
        symbolicLink: true,
        lstat: void 0
      }
    );
    this.rootStrategies = [];
  }
  get root() {
    return this.view.rootNode.fullpath;
  }
  set root(root2) {
    this.view.rootNode.uid = this.helper.getUid(root2);
    this.view.rootNode.fullpath = root2;
    this.view.rootNode.children = void 0;
  }
  getHiddenRules() {
    return this.config.get("file.hiddenRules");
  }
  isHidden(filename) {
    const hiddenRules = this.getHiddenRules();
    const { basename: basename2, extensions: extensions3 } = getExtensions(filename);
    const extname = extensions3[extensions3.length - 1];
    return hiddenRules.filenames.includes(basename2) || hiddenRules.extensions.includes(extname) || hiddenRules.patternMatches.some(
      (pattern) => new RegExp(pattern).test(filename)
    );
  }
  getNodesByPaths(fullpaths) {
    const fullpathSet = new Set(fullpaths);
    return this.view.flattenedNodes.filter(
      (node) => fullpathSet.has(node.fullpath)
    );
  }
  isGitChange(parentNode, filename) {
    return !!gitManager.getMixedStatus(
      `${parentNode.fullpath}/${filename}`,
      false
    );
  }
  getColumnConfig(name, defaultValue) {
    return this.config.get(`file.column.${name}`, defaultValue);
  }
  async init() {
    if (getRevealAuto(this.config)) {
      this.disposables.push(
        onBufEnter(async (bufnr) => {
          if (bufnr === this.explorer.bufnr) {
            return;
          }
          if (!this.explorer.visible()) {
            return;
          }
          if (this.explorer.isFloating) {
            return;
          }
          await this.view.sync(async (r) => {
            var _a;
            const fullpath = (_a = this.bufManager.getBufferNode(bufnr)) == null ? void 0 : _a.fullpath;
            if (!fullpath) {
              return;
            }
            const [revealNode, notifiers] = await this.revealNodeByPathNotifier(
              r,
              fullpath
            );
            if (revealNode) {
              await Notifier.runAll(notifiers);
            }
          });
        }, 200)
      );
    }
    loadFileActions(this.action);
  }
  async open() {
    await this.view.parseTemplate(
      "root",
      await this.explorer.args.value(fileArgOptions.fileRootTemplate),
      await this.explorer.args.value(fileArgOptions.fileRootLabelingTemplate)
    );
    await this.view.parseTemplate(
      "child",
      await this.explorer.args.value(fileArgOptions.fileChildTemplate),
      await this.explorer.args.value(fileArgOptions.fileChildLabelingTemplate)
    );
    this.root = this.explorer.root;
    this.rootStrategies = this.explorer.argValues.rootStrategies;
  }
  async cd(fullpath) {
    const { nvim } = this;
    const escapePath = await nvim.call("fnameescape", fullpath);
    let cdCmd;
    const tabCd = this.config.get("file.tabCD");
    if (tabCd !== void 0 && tabCd !== null) {
      logger.error(
        "explorer.file.tabCD has been deprecated, please use explorer.file.cdCommand instead of it"
      );
      if (tabCd) {
        cdCmd = "tcd";
      } else {
        cdCmd = "cd";
      }
    } else {
      cdCmd = this.config.get("file.cdCommand");
    }
    if (cdCmd === "tcd") {
      if (import_coc61.workspace.isNvim || await nvim.call("exists", [":tcd"])) {
        await nvim.command(`tcd ${escapePath}`);
        await import_coc61.window.showInformationMessage(`Tab's CWD is: ${fullpath}`);
      }
    } else if (cdCmd === "cd") {
      await nvim.command(`cd ${escapePath}`);
      await import_coc61.window.showInformationMessage(`CWD is: ${fullpath}`);
    }
  }
  async openedNotifier(renderer, isFirst) {
    const args = this.explorer.args;
    const revealPath = await this.explorer.revealPath();
    if (!revealPath) {
      if (isFirst) {
        return this.locator.gotoRootNotifier({ col: 1 });
      }
      return Notifier.noop();
    }
    const hasRevealPath = args.has(argOptions.reveal);
    if (getRevealAuto(this.config) || getRevealWhenOpen(this.config, this.explorer.argValues.revealWhenOpen) || hasRevealPath) {
      const [revealNode, notifiers] = await this.revealNodeByPathNotifier(
        renderer,
        revealPath
      );
      if (revealNode !== void 0) {
        return Notifier.combine(notifiers);
      } else if (isFirst) {
        return Notifier.combine([
          ...notifiers,
          await this.locator.gotoRootNotifier({ col: 1 })
        ]);
      }
    } else if (isFirst) {
      return this.locator.gotoRootNotifier({ col: 1 });
    }
    return Notifier.noop();
  }
  getPutTargetNode(node) {
    if (node.isRoot) {
      return this.view.rootNode;
    } else if (node.expandable && this.view.isExpanded(node)) {
      return node;
    } else if (node.parent) {
      return node.parent;
    } else {
      return this.view.rootNode;
    }
  }
  async searchByCocList(path2, {
    recursive,
    noIgnore,
    strict
  }) {
    var _a;
    const listArgs = strict ? ["--strict"] : [];
    const task = await startCocList(
      this.explorer,
      fileList,
      {
        showHidden: this.showHidden,
        showIgnores: noIgnore,
        rootPath: path2,
        recursive,
        revealCallback: async (loc) => {
          await task.waitExplorerShow();
          await this.view.sync(async (r) => {
            const [, notifiers] = await this.revealNodeByPathNotifier(
              r,
              import_coc61.Uri.parse(loc.uri).fsPath
            );
            await Notifier.runAll(notifiers);
          });
        }
      },
      listArgs
    );
    (_a = task.waitExplorerShow()) == null ? void 0 : _a.catch(logger.error);
  }
  filterForReveal(path2, root2) {
    const filter = this.config.get("file.reveal.filter");
    const relativePath = path2.slice(root2.length);
    for (const literal of filter.literals ?? []) {
      if (relativePath.includes(literal)) {
        return true;
      }
    }
    for (const pattern of filter.patterns ?? []) {
      if (new RegExp(pattern).test(relativePath)) {
        return true;
      }
    }
    return false;
  }
  async revealNodeByPathNotifier(renderer, path2, {
    startNode = this.view.rootNode,
    goto = true,
    render = true,
    compact
  } = {}) {
    path2 = normalizePath(path2);
    if (this.filterForReveal(path2, startNode.fullpath)) {
      return [void 0, []];
    }
    const notifiers = [];
    const revealRecursive = async (path3, {
      startNode: startNode2,
      goto: goto2,
      render: render2
    }) => {
      if (path3 === startNode2.fullpath) {
        return startNode2;
      } else if (startNode2.directory && path3.startsWith(startNode2.fullpath + import_path19.default.sep)) {
        let foundNode2 = void 0;
        const isRender = render2 && !this.view.isExpanded(startNode2);
        if (!startNode2.children) {
          startNode2.children = await this.loadInitedChildren(startNode2);
        }
        for (const child of startNode2.children) {
          const childFoundNode = await revealRecursive(path3, {
            startNode: child,
            goto: false,
            render: isRender ? false : render2
          });
          foundNode2 = childFoundNode;
          if (foundNode2) {
            await this.view.expand(startNode2, {
              compact,
              uncompact: false,
              render: false
            });
            break;
          }
        }
        if (foundNode2) {
          if (isRender) {
            const renderNotifier = await renderer.renderNotifier({
              node: startNode2
            });
            if (renderNotifier) {
              notifiers.push(renderNotifier);
            }
          }
          if (goto2) {
            notifiers.push(await this.locator.gotoNodeNotifier(foundNode2));
            notifiers.push(
              Notifier.create(() => this.nvim.command("redraw!", true))
            );
          }
        }
        return foundNode2;
      }
    };
    const foundNode = await revealRecursive(path2, {
      startNode,
      goto,
      render
    });
    return [foundNode, notifiers];
  }
  sortFiles(files) {
    return files.sort((a3, b2) => {
      if (a3.directory && !b2.directory) {
        return -1;
      } else if (b2.directory && !a3.directory) {
        return 1;
      } else {
        return a3.name.localeCompare(b2.name);
      }
    });
  }
  async loadChildren(parentNode) {
    let filenames;
    if (isWindows2 && parentNode.fullpath === "") {
      filenames = await listDrive();
    } else {
      filenames = await fsReaddir(parentNode.fullpath);
    }
    const files = await Promise.all(
      filenames.map(async (filename) => {
        try {
          if (this.showOnlyGitChange && !this.isGitChange(parentNode, filename)) {
            return;
          }
          const hidden = this.isHidden(filename);
          if (!this.showHidden && hidden) {
            return;
          }
          const fullpath = normalizePath(
            import_path19.default.join(parentNode.fullpath, filename)
          );
          const stat3 = await fsStat(fullpath).catch(() => {
          });
          const lstat = await fsLstat(fullpath).catch(() => {
          });
          const executable2 = await fsAccess(fullpath, import_fs11.default.constants.X_OK);
          const writable = await fsAccess(fullpath, import_fs11.default.constants.W_OK);
          const readable = await fsAccess(fullpath, import_fs11.default.constants.R_OK);
          const directory = isWindows2 && /^[A-Za-z]:[\\/]$/.test(fullpath) ? true : stat3 ? stat3.isDirectory() : false;
          const child = {
            type: "child",
            uid: this.helper.getUid(fullpath),
            expandable: directory,
            name: filename,
            fullpath,
            directory,
            readonly: !writable && readable,
            executable: executable2,
            readable,
            writable,
            hidden,
            symbolicLink: lstat ? lstat.isSymbolicLink() : false,
            lstat: lstat || void 0
          };
          return child;
        } catch (error) {
          logger.error(error);
        }
      })
    );
    return this.sortFiles(files.filter((r) => !!r));
  }
};
sourceManager.registerSource("file", FileSource);

// src/highlight/filename.ts
var FilenameHighlight = class {
  constructor(config4) {
    const configKey = "filename.colored.enable";
    const enabledCompletely = config4.get(
      configKey,
      false
    ) === true;
    this.enabledGitStatus = enabledCompletely || config4.get(`${configKey}.git`, false);
    this.enabledErrorStatus = enabledCompletely || config4.get(`${configKey}.diagnosticError`, false);
    this.enabledWarningStatus = enabledCompletely || config4.get(`${configKey}.diagnosticWarning`, false);
  }
  getGitHighlight(status) {
    if (status.x === "!" /* ignored */) {
      return gitHighlights.ignored;
    }
    return getGitFormatHighlight(status.y);
  }
  getHighlight(fullpath, isDirectory, highlightOrder) {
    for (const type of highlightOrder) {
      if (type === "diagnosticWarning") {
        if (this.enabledWarningStatus) {
          const warning = diagnosticManager.getMixedWarning(fullpath);
          if (warning) {
            return fileHighlights.diagnosticWarning;
          }
        }
      } else if (type === "diagnosticError") {
        if (this.enabledErrorStatus) {
          const error = diagnosticManager.getMixedError(fullpath);
          if (error) {
            return fileHighlights.diagnosticError;
          }
        }
      } else if (type === "git") {
        if (this.enabledGitStatus) {
          const status = gitManager.getMixedStatus(fullpath, isDirectory);
          if (status) {
            return this.getGitHighlight(status);
          }
        }
      }
    }
  }
};

// src/source/sources/buffer/child-columns/git.ts
bufferColumnRegistrar.registerColumn(
  "child",
  "git",
  ({ source, subscriptions }) => {
    const filenameHighlight = new FilenameHighlight(source.config);
    const icons = getStatusIcons(source.config);
    const getHighlight = (fullpath, staged) => {
      if (staged) {
        return gitHighlights.staged;
      } else {
        return filenameHighlight.getHighlight(fullpath, false, ["git"]) ?? gitHighlights.unstaged;
      }
    };
    return {
      init() {
        subscriptions.push(gitManager.bindColumn(source));
      },
      async available() {
        return await gitManager.cmd.available();
      },
      async draw() {
        return {
          async labelVisible({ node }) {
            const status = gitManager.getMixedStatus(node.fullpath, false);
            if (!status) {
              return false;
            }
            return status.x !== " " /* unmodified */ || status.y !== " " /* unmodified */;
          },
          drawNode(row, { node, nodeIndex, isLabeling }) {
            const showFormat = (f, staged) => {
              const hl = getHighlight(node.fullpath, staged);
              if (isLabeling) {
                row.add(`${icons[f].name}(${icons[f].icon})`, {
                  hl
                });
              } else {
                row.add(icons[f].icon, {
                  hl
                });
              }
            };
            const status = gitManager.getMixedStatus(node.fullpath, false);
            if (status) {
              showFormat(status.x, true);
              if (isLabeling) {
                row.add(" ");
              }
              showFormat(status.y, false);
              if (status.x === "!" /* ignored */) {
                source.locator.mark.remove("git", nodeIndex);
                source.locator.mark.remove("gitStaged", nodeIndex);
                source.locator.mark.remove("gitUnstaged", nodeIndex);
              } else {
                source.locator.mark.add("git", nodeIndex);
                if (status.x !== " " /* unmodified */) {
                  source.locator.mark.add("gitStaged", nodeIndex);
                } else {
                  source.locator.mark.remove("gitStaged", nodeIndex);
                }
                if (status.y !== " " /* unmodified */) {
                  source.locator.mark.add("gitUnstaged", nodeIndex);
                } else {
                  source.locator.mark.remove("gitUnstaged", nodeIndex);
                }
              }
            } else {
              source.locator.mark.remove("git", nodeIndex);
              source.locator.mark.remove("gitStaged", nodeIndex);
              source.locator.mark.remove("gitUnstaged", nodeIndex);
            }
          }
        };
      }
    };
  }
);

// src/source/sources/buffer/child-columns/selection.ts
bufferColumnRegistrar.registerColumn("child", "selection", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (source.isSelectedNode(node)) {
          row.add(source.icons.selected);
        }
      }
    };
  }
}));

// src/source/sources/buffer/child-columns/name.ts
bufferColumnRegistrar.registerColumn("child", "name", ({ source }) => {
  const filenameHighlight = new FilenameHighlight(source.config);
  const getHighlight = (fullpath, visible) => {
    return filenameHighlight.getHighlight(fullpath, false, [
      "diagnosticError",
      "diagnosticWarning",
      "git"
    ]) ?? (visible ? bufferHighlights.nameVisible : void 0);
  };
  return {
    draw() {
      return {
        drawNode(row, { node }) {
          row.add(node.name, {
            hl: getHighlight(node.fullpath, node.visible)
          });
        }
      };
    }
  };
});

// src/source/sources/buffer/child-columns/bufname.ts
bufferColumnRegistrar.registerColumn("child", "bufname", () => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(node.bufname, { hl: bufferHighlights.bufname });
      }
    };
  }
}));

// src/source/sources/buffer/child-columns/modified.ts
bufferColumnRegistrar.registerColumn("child", "modified", ({ source }) => ({
  draw() {
    return {
      labelVisible({ node }) {
        return node.modified || !node.modifiable;
      },
      drawNode(row, { node, nodeIndex }) {
        const ch = node.modified ? "+" : node.modifiable ? "" : "-";
        if (ch) {
          row.add(ch, { hl: bufferHighlights.modified });
        }
        node.modified ? source.locator.mark.add("modified", nodeIndex) : source.locator.mark.remove("modified", nodeIndex);
      }
    };
  }
}));

// src/source/sources/buffer/child-columns/bufnr.ts
bufferColumnRegistrar.registerColumn("child", "bufnr", () => {
  let prevMaxBufnrWidth = 0;
  return {
    draw(nodes, { drawAll, abort }) {
      const maxBufnrWidth = max_default(nodes.map((node) => node.bufnrStr.length));
      if (!maxBufnrWidth) {
        return abort();
      }
      if (prevMaxBufnrWidth !== maxBufnrWidth) {
        prevMaxBufnrWidth = maxBufnrWidth;
        drawAll();
      }
      return {
        drawNode(row, { node }) {
          row.add(node.bufnrStr.padStart(prevMaxBufnrWidth), {
            hl: bufferHighlights.bufnr
          });
        }
      };
    }
  };
});

// src/source/sources/buffer/child-columns/diagnosticError.ts
bufferColumnRegistrar.registerColumn(
  "child",
  "diagnosticError",
  ({ source, subscriptions }) => {
    const diagnosticConfig = getDiagnosticConfig(source.config);
    return {
      init() {
        subscriptions.push(diagnosticManager.bindColumn(source, ["error"]));
      },
      draw() {
        return {
          labelVisible: ({ node }) => !!diagnosticManager.getMixedError(node.fullpath),
          drawNode(row, { node, isLabeling }) {
            const errorCount = diagnosticManager.getMixedError(node.fullpath);
            if (isLabeling) {
              row.add((errorCount ?? 0).toString(), {
                hl: diagnosticHighlights.diagnosticError
              });
              return;
            }
            if (!errorCount) {
              return;
            }
            row.add(printDiagnosticCount(errorCount, diagnosticConfig), {
              hl: diagnosticHighlights.diagnosticError
            });
          }
        };
      }
    };
  }
);

// src/source/sources/buffer/child-columns/diagnosticWarning.ts
bufferColumnRegistrar.registerColumn(
  "child",
  "diagnosticWarning",
  ({ source, subscriptions }) => {
    const diagnosticConfig = getDiagnosticConfig(source.config);
    return {
      init() {
        subscriptions.push(diagnosticManager.bindColumn(source, ["warning"]));
      },
      draw() {
        return {
          labelVisible: ({ node }) => !!diagnosticManager.getMixedWarning(node.fullpath),
          drawNode(row, { node, isLabeling }) {
            const warningCount = diagnosticManager.getMixedWarning(
              node.fullpath
            );
            if (isLabeling) {
              row.add((warningCount ?? 0).toString(), {
                hl: diagnosticHighlights.diagnosticWarning
              });
              return;
            }
            if (!warningCount) {
              return;
            }
            row.add(printDiagnosticCount(warningCount, diagnosticConfig), {
              hl: diagnosticHighlights.diagnosticWarning
            });
          }
        };
      }
    };
  }
);

// src/source/sources/buffer/child-columns/readonly.ts
bufferColumnRegistrar.registerColumn("child", "readonly", ({ source }) => ({
  draw() {
    return {
      labelOnly: true,
      labelVisible: ({ node }) => node.readonly,
      drawNode(row, { node }) {
        if (node.readonly) {
          row.add(node.readonly ? source.icons.readonly : "", {
            hl: bufferHighlights.readonly
          });
        }
      }
    };
  }
}));

// src/source/sources/buffer/child-columns/fullpath.ts
bufferColumnRegistrar.registerColumn("child", "fullpath", () => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(displayedFullpath(node.fullpath), {
          hl: bufferHighlights.fullpath
        });
      }
    };
  }
}));

// src/source/sources/buffer/bufferSource.ts
var hlg5 = hlGroupManager.linkGroup.bind(hlGroupManager);
var bufferHighlights = {
  title: hlg5("BufferRoot", "Constant"),
  hidden: hlg5("BufferHidden", internalHighlightGroups.CommentColor),
  expandIcon: hlg5("BufferExpandIcon", "Directory"),
  nameVisible: hlg5("BufferNameVisible", "String"),
  bufname: hlg5("BufferBufname", internalHighlightGroups.CommentColor),
  modified: hlg5("BufferModified", "Operator"),
  bufnr: hlg5("BufferBufnr", "Special"),
  readonly: hlg5("BufferReadonly", "Operator"),
  fullpath: hlg5("BufferFullpath", internalHighlightGroups.CommentColor)
};
var BufferSource = class extends ExplorerSource {
  constructor() {
    super(...arguments);
    this.showHidden = this.config.get("file.showHiddenBuffers");
    this.view = new ViewSource(
      this,
      bufferColumnRegistrar,
      {
        type: "root",
        isRoot: true,
        expandable: true,
        uid: this.helper.getUid("0"),
        bufnr: 0,
        bufnrStr: "0",
        bufname: "",
        fullpath: "",
        name: "",
        unlisted: true,
        current: false,
        previous: false,
        visible: false,
        hidden: false,
        modifiable: false,
        readonly: true,
        terminal: false,
        modified: false,
        readErrors: false
      }
    );
  }
  async init() {
    this.disposables.push(
      this.bufManager.onReloadDebounce(async () => {
        if (!this.explorer.visible()) {
          return;
        }
        await this.load(this.view.rootNode);
      }),
      this.bufManager.onModifiedDebounce(async () => {
        if (!this.explorer.visible()) {
          return;
        }
        await this.load(this.view.rootNode);
      })
    );
    this.tabId = await tabContainerManager.currentTabId();
    loadBufferActions(this.action);
  }
  async open() {
    await this.view.parseTemplate(
      "root",
      await this.explorer.args.value(bufferArgOptions.bufferRootTemplate)
    );
    await this.view.parseTemplate(
      "child",
      await this.explorer.args.value(bufferArgOptions.bufferChildTemplate),
      await this.explorer.args.value(
        bufferArgOptions.bufferChildLabelingTemplate
      )
    );
  }
  async loadChildren(_parentNode, { force = false } = {}) {
    if (force) {
      await this.bufManager.reload();
    }
    const tabOnly = bufferTabOnly();
    const bufferNodes = this.bufManager.bufferNodes;
    if (this.showHidden) {
      return [...bufferNodes];
    } else {
      if (tabOnly) {
        const tabContainer = this.tabId ? tabContainerManager.get(this.tabId) : await tabContainerManager.currentTabContainer();
        let bufnrs = [];
        if (tabContainer == null ? void 0 : tabContainer.bufnrs) {
          bufnrs = [...tabContainer.bufnrs];
        }
        return bufferNodes.filter(
          (it) => bufnrs.includes(it.bufnr) && !it.unlisted
        );
      } else {
        return bufferNodes.filter((it) => !it.unlisted);
      }
    }
  }
};
sourceManager.registerSource("buffer", BufferSource);

// src/source/sources/bookmark/bookmarkSource.ts
var import_coc62 = require("coc.nvim");
var import_path21 = __toESM(require("path"));

// src/source/sources/bookmark/argOptions.ts
var bookmarkArgOptions = {
  bookmarkRootTemplate: Args.registerOption("bookmark-root-template", {
    getDefault: () => config.get("bookmark.root.template")
  }),
  bookmarkChildTemplate: Args.registerOption(
    "bookmark-child-template",
    {
      getDefault: () => config.get("bookmark.child.template")
    }
  ),
  bookmarkChildLabelingTemplate: Args.registerOption(
    "bookmark-child-labeling-template",
    {
      getDefault: () => config.get("bookmark.child.labelingTemplate")
    }
  )
};

// src/source/sources/bookmark/bookmarkColumnRegistrar.ts
var BookmarkColumnRegistrar = class extends ColumnRegistrar {
};
var bookmarkColumnRegistrar = new BookmarkColumnRegistrar();

// src/source/sources/bookmark/root-columns/icon.ts
bookmarkColumnRegistrar.registerColumn("root", "icon", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(
          source.view.isExpanded(node) ? source.icons.expanded : source.icons.collapsed,
          { hl: bookmarkHighlights.expandIcon }
        );
      }
    };
  }
}));

// src/source/sources/bookmark/root-columns/title.ts
bookmarkColumnRegistrar.registerColumn("root", "title", () => ({
  draw() {
    return {
      drawNode(row) {
        row.add("[BOOKMARK]", {
          hl: bookmarkHighlights.title
        });
      }
    };
  }
}));

// src/source/sources/bookmark/root-columns/hidden.ts
bookmarkColumnRegistrar.registerColumn("root", "hidden", ({ source }) => ({
  draw() {
    return {
      drawNode(row) {
        row.add(source.showHidden ? source.icons.hidden : "", {
          hl: bookmarkHighlights.hidden
        });
      }
    };
  }
}));

// src/source/sources/bookmark/child-columns/selection.ts
bookmarkColumnRegistrar.registerColumn("child", "selection", ({ source }) => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (source.isSelectedNode(node)) {
          row.add(source.icons.selected);
        }
      }
    };
  }
}));

// src/source/sources/bookmark/child-columns/position.ts
bookmarkColumnRegistrar.registerColumn("child", "position", () => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(`line: ${node.lnum}`, { hl: bookmarkHighlights.position });
      }
    };
  }
}));

// src/source/sources/bookmark/child-columns/filename.ts
bookmarkColumnRegistrar.registerColumn("child", "filename", () => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(node.name, { hl: bookmarkHighlights.filename });
      }
    };
  }
}));

// src/source/sources/bookmark/child-columns/fullpath.ts
bookmarkColumnRegistrar.registerColumn("child", "fullpath", () => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(displayedFullpath(node.fullpath), {
          hl: bookmarkHighlights.fullpath
        });
      }
    };
  }
}));

// src/source/sources/bookmark/child-columns/line.ts
bookmarkColumnRegistrar.registerColumn("child", "line", () => ({
  draw() {
    return {
      drawNode(row, { node }) {
        row.add(node.line, { hl: bookmarkHighlights.line });
      }
    };
  }
}));

// src/source/sources/bookmark/child-columns/annotation.ts
bookmarkColumnRegistrar.registerColumn("child", "annotation", () => ({
  draw() {
    return {
      drawNode(row, { node }) {
        if (node.annotation) {
          row.add(node.annotation, { hl: bookmarkHighlights.annotation });
        }
      }
    };
  }
}));

// src/source/sources/bookmark/util/db.ts
var import_path20 = __toESM(require("path"));
var BookmarkDB = class {
  constructor(filepath) {
    this.filepath = filepath;
  }
  async load() {
    const dir = import_path20.default.dirname(this.filepath);
    const stat3 = await fsStat(dir).catch(() => null);
    if (!stat3 || !stat3.isDirectory()) {
      return {};
    }
    try {
      const content = await fsReadFile(this.filepath, { encoding: "utf8" });
      return JSON.parse(content.trim());
    } catch {
      return {};
    }
  }
  async fetch(key) {
    let obj = await this.load();
    if (!key) {
      return obj;
    }
    const parts = key.split(".");
    for (const part of parts) {
      if (typeof obj[part] === "undefined") {
        return void 0;
      }
      obj = obj[part];
    }
    return obj;
  }
  async exists(key) {
    let obj = await this.load();
    const parts = key.split(".");
    for (const part of parts) {
      if (typeof obj[part] === "undefined") {
        return false;
      }
      obj = obj[part];
    }
    return true;
  }
  async push(key, data) {
    const origin = await this.load() || {};
    let obj = origin;
    const parts = key.split(".");
    const len = parts.length;
    if (obj === null) {
      const dir = import_path20.default.dirname(this.filepath);
      await fsMkdirp(dir);
      obj = origin;
    }
    for (let i2 = 0; i2 < len; i2++) {
      const key2 = parts[i2];
      if (i2 === len - 1) {
        obj[key2] = data;
        await fsWriteFile(this.filepath, JSON.stringify(origin, null, 2));
        break;
      }
      if (typeof obj[key2] === "undefined") {
        obj[key2] = {};
        obj = obj[key2];
      } else {
        obj = obj[key2];
      }
    }
  }
  async delete(key) {
    let obj = await this.load();
    const origin = obj;
    const parts = key.split(".");
    const len = parts.length;
    for (let i2 = 0; i2 < len; i2++) {
      if (typeof obj[parts[i2]] === "undefined") {
        break;
      }
      if (i2 === len - 1) {
        delete obj[parts[i2]];
        await fsWriteFile(this.filepath, JSON.stringify(origin, null, 2));
        break;
      }
      obj = obj[parts[i2]];
    }
  }
  async clear() {
    const stat3 = await fsStat(this.filepath).catch(() => null);
    if (!stat3 || !stat3.isFile()) {
      return;
    }
    await fsWriteFile(this.filepath, "{}");
  }
};

// src/source/sources/bookmark/util/encodeDecode.ts
function decode(text) {
  return decodeURIComponent(text);
}

// src/source/sources/bookmark/bookmarkSource.ts
var hlg6 = hlGroupManager.linkGroup.bind(hlGroupManager);
var bookmarkHighlights = {
  title: hlg6("BookmarkRoot", "Constant"),
  hidden: hlg6("BookmarkHidden", "Commment"),
  expandIcon: hlg6("BookmarkExpandIcon", "Directory"),
  filename: hlg6("BookmarkFilename", "String"),
  fullpath: hlg6("BookmarkFullpath", "Special"),
  position: hlg6("BookmarkPosition", "Comment"),
  line: hlGroupManager.createGroup(
    "BookmarkLine",
    "ctermbg=27 ctermfg=0 guibg=#1593e5 guifg=#ffffff"
  ),
  annotation: hlg6("BookmarkAnnotation", "Comment")
};
var BookmarkSource = class extends ExplorerSource {
  constructor() {
    super(...arguments);
    this.view = new ViewSource(
      this,
      bookmarkColumnRegistrar,
      {
        type: "root",
        isRoot: true,
        expandable: true,
        uid: this.helper.getUid("0"),
        name: "",
        fullpath: "",
        lnum: -1,
        line: "",
        annotation: void 0
      }
    );
  }
  static get enabled() {
    return import_coc62.extensions.getExtensionState("coc-bookmark") === "activated";
  }
  async init() {
    this.disposables.push(
      internalEvents.on(
        "CocBookmarkChange",
        debounceFn(500, async () => {
          await this.load(this.view.rootNode);
        })
      )
    );
  }
  async open() {
    await this.view.parseTemplate(
      "root",
      await this.explorer.args.value(bookmarkArgOptions.bookmarkRootTemplate)
    );
    await this.view.parseTemplate(
      "child",
      await this.explorer.args.value(bookmarkArgOptions.bookmarkChildTemplate),
      await this.explorer.args.value(
        bookmarkArgOptions.bookmarkChildLabelingTemplate
      )
    );
    this.view.rootNode.fullpath = this.explorer.root;
  }
  async loadChildren(parentNode) {
    var _a;
    const extRoot = import_coc62.workspace.env.extensionRoot;
    const bookmarkPath = import_path21.default.join(
      extRoot,
      "coc-bookmark-data/bookmark.json"
    );
    const db = new BookmarkDB(bookmarkPath);
    const data = await db.load();
    const bookmarkNodes = [];
    for (const [filepath, bookmarks] of Object.entries(data)) {
      const fullpath = normalizePath(decode(filepath));
      if (!this.showHidden && !fullpath.startsWith(parentNode.fullpath) || !await fsExists(fullpath)) {
        continue;
      }
      for (const lnum of Object.keys(bookmarks).map((l) => Number(l)).sort((l1, l2) => l1 - l2)) {
        const bookmark = bookmarks[lnum];
        bookmarkNodes.push({
          type: "child",
          uid: this.helper.getUid(`${fullpath}:${lnum}`),
          fullpath,
          name: import_path21.default.basename(fullpath),
          lnum,
          location: import_coc62.Location.create(fullpath, import_coc62.Range.create(lnum, -1, lnum, -1)),
          line: bookmark.line,
          annotation: (_a = bookmark.annotation) == null ? void 0 : _a.toString()
        });
      }
    }
    return bookmarkNodes;
  }
};
sourceManager.registerSource("bookmark", BookmarkSource);

// src/view/viewExplorer.ts
var ViewExplorer = class {
  constructor(explorer) {
    this.explorer = explorer;
    this.isHelpUI = false;
    this.currentLineIndex = 0;
    this[rendererExplorerSymbol] = new RendererExplorer(this);
  }
  async sync(block) {
    return await block(this[rendererExplorerSymbol]);
  }
  get flattenedNodes() {
    return this.explorer.sources.reduce((ret, cur) => {
      return ret.concat(cur.view.flattenedNodes);
    }, []);
  }
  async refreshLineIndex() {
    const win = await this.explorer.win;
    if (win) {
      const cursor = await win.cursor;
      this.currentLineIndex = cursor[0] - 1;
    }
  }
  async currentSource() {
    return this.explorer.sources[await this.currentSourceIndex()];
  }
  async currentSourceIndex() {
    const lineIndex = this.currentLineIndex;
    return this.explorer.sources.findIndex(
      (source) => lineIndex >= source.view.startLineIndex && lineIndex < source.view.endLineIndex
    );
  }
  async currentNode() {
    const source = await this.currentSource();
    if (source) {
      const nodeIndex = this.currentLineIndex - source.view.startLineIndex;
      return source.view.flattenedNodes[nodeIndex];
    }
  }
  async emitRequestRenderNodes() {
    await this.sync(async (r) => {
      const notifiers = await Promise.all(
        r.rendererSources().map((s3) => s3.emitRequestRenderNodesNotifier())
      );
      await Notifier.runAll(notifiers);
    });
  }
};
rendererExplorerSymbol;

// src/explorer.ts
var Explorer = class {
  constructor(explorerID, explorerManager, bufnr, borderBufnr, config4) {
    this.explorerID = explorerID;
    this.explorerManager = explorerManager;
    this.bufnr = bufnr;
    this.borderBufnr = borderBufnr;
    this.config = config4;
    this.nvim = import_coc63.workspace.nvim;
    this.contentWidth = 0;
    this.action = new ActionExplorer(this);
    this.highlight = new HighlightExplorer(this);
    this.view = new ViewExplorer(this);
    this.locator = new LocatorExplorer(this);
    this.events = new HelperEventEmitter(logger);
    this.firstOpened = false;
    this.disposables = [];
    this.isHide = false;
    this.context = explorerManager.context;
    this.buffer = this.nvim.createBuffer(this.bufnr);
    this.inited = new BuffuerContextVars("inited", this.buffer);
    this.sourceWinid = new BuffuerContextVars(
      "sourceWinid",
      this.buffer
    );
    this.sourceBufnr = new BuffuerContextVars(
      "sourceBufnr",
      this.buffer
    );
    this.floatingPreview = new FloatingPreview(this);
    if (borderBufnr) {
      this.disposables.push(
        onEvent("BufWinLeave", async (curBufnr) => {
          if (curBufnr === bufnr) {
            await closeWinByBufnrNotifier([borderBufnr]).run();
          }
        })
      );
    }
    loadGlobalActions(this.action);
  }
  static genExplorerPosition(args, specialSize) {
    let width = 0;
    let height = 0;
    let left = 0;
    let top = 0;
    if (args.position.name !== "floating") {
      width = (specialSize == null ? void 0 : specialSize.width) ?? args.width;
    } else {
      width = (specialSize == null ? void 0 : specialSize.width) ?? args.floatingWidth;
      height = (specialSize == null ? void 0 : specialSize.height) ?? args.floatingHeight;
      const [vimWidth, vimHeight] = [
        import_coc63.workspace.env.columns,
        import_coc63.workspace.env.lines - import_coc63.workspace.env.cmdheight
      ];
      if (width <= 0) {
        width = vimWidth + width;
      }
      if (height <= 0) {
        height = vimHeight + height;
      }
      const floatingPosition = args.floatingPosition;
      if (floatingPosition === "left-center") {
        left = 0;
        top = (vimHeight - height) / 2;
      } else if (floatingPosition === "center") {
        left = (vimWidth - width) / 2;
        top = (vimHeight - height) / 2;
      } else if (floatingPosition === "right-center") {
        left = vimWidth - width;
        top = (vimHeight - height) / 2;
      } else if (floatingPosition === "center-top") {
        left = (vimWidth - width) / 2;
        top = 0;
      } else {
        [left, top] = floatingPosition;
      }
    }
    return { width, height, top, left };
  }
  static async create(explorerManager, argValues, config4) {
    explorerManager.maxExplorerID += 1;
    const { width, height, top, left } = this.genExplorerPosition(argValues);
    const [bufnr, borderBufnr] = await import_coc63.workspace.nvim.call("coc_explorer#open_explorer", [
      explorerManager.maxExplorerID,
      argValues.position,
      {
        width,
        height,
        left,
        top,
        focus: argValues.focus,
        border_enable: config4.get("floating.border.enable"),
        border_chars: config4.get("floating.border.chars"),
        title: config4.get("floating.border.title")
      }
    ]);
    const explorer = new Explorer(
      explorerManager.maxExplorerID,
      explorerManager,
      bufnr,
      borderBufnr,
      config4
    );
    await explorer.inited.set(true);
    return explorer;
  }
  dispose() {
    this.floatingPreview.dispose();
    this.disposables.forEach((s3) => s3.dispose());
  }
  get root() {
    if (!this.root_) {
      throw Error("Explorer root not initialized yet");
    }
    return this.root_;
  }
  get args() {
    if (!this.args_) {
      throw Error("Explorer args not initialized yet");
    }
    return this.args_;
  }
  get argValues() {
    if (!this.argValues_) {
      throw Error("Explorer argValues not initialized yet");
    }
    return this.argValues_;
  }
  get isFloating() {
    if (this.isFloating_ === void 0) {
      throw Error("Explorer isFloating not initialized yet");
    }
    return this.isFloating_;
  }
  get sources() {
    if (!this.sources_) {
      throw Error("Explorer sources not initialized yet");
    }
    return this.sources_;
  }
  get height() {
    return sum_default(this.sources.map((s3) => s3.height));
  }
  get win() {
    return this.winid.then(winByWinid);
  }
  get winnr() {
    return winnrByBufnr(this.bufnr);
  }
  get winid() {
    return this.winnr.then(winidByWinnr);
  }
  get borderWin() {
    return this.borderWinid.then(winByWinid);
  }
  get borderWinnr() {
    return winnrByBufnr(this.borderBufnr);
  }
  get borderWinid() {
    return this.borderWinnr.then(winidByWinnr);
  }
  async sourceWinnr() {
    const winid = await this.sourceWinid.get();
    if (!winid) {
      return void 0;
    }
    const winnr = await this.nvim.call("win_id2win", [winid]);
    if (winnr <= 0 || (await this.explorerManager.winnrs()).includes(winnr)) {
      return;
    }
    return winnr;
  }
  async sourceBufnrBySourceWinid() {
    const winid = await this.sourceWinid.get();
    if (!winid) {
      return;
    }
    const bufnr = await this.nvim.call("winbufnr", [winid]);
    if (bufnr <= 0) {
      return;
    }
    return bufnr;
  }
  async sourceBuffer() {
    const bufnr = await this.sourceBufnr.get();
    if (!bufnr) {
      return;
    }
    return this.nvim.createBuffer(bufnr);
  }
  visible() {
    const node = this.explorerManager.bufManager.getBufferNode(this.bufnr);
    return node == null ? void 0 : node.visible;
  }
  async refreshWidth() {
    const window9 = await this.win;
    if (!window9) {
      return;
    }
    const setWidth = async (contentWidthType, contentWidth) => {
      if (contentWidth <= 0) {
        let contentBaseWidth;
        if (contentWidthType === "win-width") {
          contentBaseWidth = await window9.width;
          if (await window9.getOption("relativenumber") || await window9.getOption("number")) {
            contentBaseWidth -= await window9.getOption(
              "numberwidth"
            );
          }
        } else if (contentWidthType === "vim-width") {
          contentBaseWidth = await import_coc63.workspace.nvim.eval("&columns");
        }
        if (contentBaseWidth) {
          this.contentWidth = contentBaseWidth + contentWidth;
          return true;
        }
      } else {
        this.contentWidth = contentWidth;
        return true;
      }
      return false;
    };
    if (this.isFloating) {
      if (await setWidth("win-width", this.argValues.floatingContentWidth)) {
        return;
      }
    }
    await setWidth(
      this.argValues.contentWidthType,
      this.argValues.contentWidth
    );
  }
  resizeNotifier(size) {
    return Notifier.create(() => {
      var _a, _b;
      const dimension = Explorer.genExplorerPosition(this.argValues, {
        width: (size == null ? void 0 : size[0]) ?? ((_a = this.storedSize) == null ? void 0 : _a.width),
        height: (size == null ? void 0 : size[1]) ?? ((_b = this.storedSize) == null ? void 0 : _b.height)
      });
      const { top, left, width, height } = dimension;
      this.storedSize = {
        width,
        height
      };
      this.nvim.call(
        "coc_explorer#resize",
        [
          this.bufnr,
          this.argValues.position,
          {
            width,
            height,
            left,
            top,
            border_bufnr: this.borderBufnr,
            border_enable: this.config.get("floating.border.enable"),
            border_chars: this.config.get("floating.border.chars"),
            title: this.config.get("floating.border.title")
          }
        ],
        true
      );
    });
  }
  async resize(size) {
    await this.resizeNotifier(size).run();
  }
  async adjustSize(sizeOffset) {
    var _a, _b;
    const [widthOff = 0, heightOff = 0] = sizeOffset ?? [0, 0];
    const dimension = Explorer.genExplorerPosition(this.argValues, {
      width: (_a = this.storedSize) == null ? void 0 : _a.width,
      height: (_b = this.storedSize) == null ? void 0 : _b.height
    });
    const { width, height } = dimension;
    await this.resize([width + widthOff, height + heightOff]);
  }
  async focus() {
    const win = await this.win;
    if (win) {
      await this.nvim.command(`${await win.number}wincmd w`);
      await this.resize();
      return true;
    }
    return false;
  }
  async resume(argValues) {
    const { width, height, top, left } = Explorer.genExplorerPosition(
      argValues,
      this.storedSize
    );
    await this.nvim.call("coc_explorer#resume", [
      this.bufnr,
      argValues.position,
      {
        width,
        height,
        left,
        top,
        focus: argValues.focus,
        border_bufnr: this.borderBufnr,
        border_enable: this.config.get("floating.border.enable"),
        border_chars: this.config.get("floating.border.chars"),
        title: this.config.get("floating.border.title")
      }
    ]);
  }
  async open(args, rooter, isFirst) {
    let firstOpen;
    if (!this.firstOpened) {
      firstOpen = true;
      this.firstOpened = true;
    } else {
      firstOpen = false;
    }
    if (firstOpen) {
      await this.events.fire("first-open-pre");
    }
    await this.events.fire("open-pre");
    await doUserAutocmd("CocExplorerOpenPre");
    this.rooter = rooter.open(this);
    if (this.view.isHelpUI) {
      await this.quitHelp();
    }
    await this.highlight.bootSyntax();
    const sourcesChanged = await this.initArgs(args, this.rooter);
    for (const source of this.sources) {
      await source.bootOpen(isFirst);
    }
    await this.view.sync(async (r) => {
      const notifiers = [];
      if (sourcesChanged) {
        notifiers.push(this.clearLinesNotifier());
      }
      notifiers.push(
        await this.loadAllNotifier(r),
        ...await Promise.all(
          r.rendererSources().map((rs) => rs.source.openedNotifier(rs, isFirst))
        )
      );
      await Notifier.runAll(notifiers);
      await doUserAutocmd("CocExplorerOpenPost");
      await this.events.fire("open-post");
      if (firstOpen) {
        await this.events.fire("first-open-post");
      }
    });
  }
  async tryQuitOnOpenNotifier() {
    if (this.argValues.quitOnOpen || this.isFloating) {
      return this.quitNotifier();
    }
    return Notifier.noop();
  }
  async tryQuitOnOpen() {
    return Notifier.run(this.tryQuitOnOpenNotifier());
  }
  async hide() {
    this.isHide = true;
    await this.quit(true);
  }
  async show() {
    if (this.isHide) {
      this.isHide = false;
      await this.resume(this.argValues);
    }
  }
  async quitNotifier(isHide = false) {
    if (!isHide) {
      await doUserAutocmd("CocExplorerQuitPre");
    }
    const sourceWinnr = await this.sourceWinnr();
    const bufnr = await currentBufnr();
    return Notifier.create(() => {
      if (sourceWinnr && this.bufnr === bufnr) {
        this.nvim.command(`${sourceWinnr}wincmd w`, true);
      }
      closeWinByBufnrNotifier([this.bufnr]).notify();
      if (!isHide) {
        doUserAutocmdNotifier("CocExplorerQuitPost").notify();
      }
    });
  }
  async quit(isHide = false) {
    return Notifier.run(await this.quitNotifier(isHide));
  }
  async initRoot(argValues, rooter) {
    const root2 = argValues.rootUri;
    if (root2) {
      this.root_ = normalizePath(root2);
      return;
    }
    let reveal;
    if (getRevealWhenOpen(this.config, this.argValues.revealWhenOpen)) {
      reveal = await this.revealPath();
    }
    const resolvedRoot = await rooter.resolveRoot(
      reveal,
      this.argValues.rootStrategies
    );
    if (resolvedRoot) {
      this.root_ = normalizePath(resolvedRoot);
      return;
    }
    this.root_ = normalizePath(import_coc63.workspace.cwd);
  }
  async initArgs(args, rooter) {
    this.args_ = args;
    this.argValues_ = await args.values(argOptions);
    await this.initRoot(this.argValues_, rooter);
    const argSources = await args.value(argOptions.sources);
    if (!argSources) {
      return false;
    }
    const enabledArgSources = await (0, import_p_filter2.default)(
      argSources,
      (s3) => sourceManager.enabled(s3.name)
    );
    const argSourcesEnabledJson = JSON.stringify(enabledArgSources);
    if (this.prevArgSourcesEnabledJson && this.prevArgSourcesEnabledJson === argSourcesEnabledJson) {
      return false;
    }
    this.prevArgSourcesEnabledJson = argSourcesEnabledJson;
    (0, import_coc63.disposeAll)(this.sources_ ?? []);
    this.sources_ = enabledArgSources.map(
      (sourceArg) => sourceManager.createSource(sourceArg.name, this, sourceArg.expand)
    );
    const position = await this.args_.value(argOptions.position);
    this.isFloating_ = position.name === "floating";
    return true;
  }
  async revealPath() {
    var _a;
    const revealPath = await this.args.value(argOptions.reveal);
    if (revealPath) {
      return revealPath;
    } else {
      const buf = await this.sourceBuffer();
      if (buf) {
        return ((_a = this.explorerManager.bufManager.getBufferNode(buf.id)) == null ? void 0 : _a.fullpath) ?? void 0;
      }
    }
  }
  async getSelectedOrCursorLineIndexes(mode) {
    await this.view.refreshLineIndex();
    const lineIndexes = /* @__PURE__ */ new Set();
    if (mode === "v") {
      const range = await import_coc63.window.getSelectedRange("v");
      if (range) {
        const startLine = range.start.line;
        const endLine = range.end.character !== 0 ? range.end.line : range.end.line - 1;
        for (let lineIndex = startLine; lineIndex <= endLine; lineIndex++) {
          lineIndexes.add(lineIndex);
        }
        return lineIndexes;
      }
    }
    lineIndexes.add(this.view.currentLineIndex);
    return lineIndexes;
  }
  findSourceByLineIndex(lineIndex) {
    const sourceIndex = this.sources.findIndex(
      (source) => lineIndex < source.view.endLineIndex
    );
    if (sourceIndex === -1) {
      const index = this.sources.length - 1;
      return { source: this.sources[index], sourceIndex: index };
    } else {
      return { source: this.sources[sourceIndex], sourceIndex };
    }
  }
  lineIndexesGroupBySource(lineIndexes) {
    const groups = /* @__PURE__ */ new Map();
    for (const line of lineIndexes) {
      const { source, sourceIndex } = this.findSourceByLineIndex(line);
      let group = groups.get(sourceIndex);
      if (!group) {
        group = {
          source,
          lineIndexes: [line]
        };
        groups.set(sourceIndex, group);
      }
      group.lineIndexes.push(line);
    }
    return [...groups.values()];
  }
  setLinesNotifier(lines, start, end) {
    return Notifier.create(() => {
      this.nvim.call(
        "coc_explorer#util#buf_set_lines_skip_cursor",
        [this.bufnr, start, end, false, lines],
        true
      );
    });
  }
  clearLinesNotifier() {
    return this.setLinesNotifier([], 0, -1);
  }
  async loadAllNotifier(renderer, { render = true } = {}) {
    this.locator.mark.removeAll();
    const notifiers = await Promise.all(
      renderer.rendererSources().map(
        (r) => r.source.loadNotifier(r, r.view.rootNode, { render: false })
      )
    );
    if (render) {
      notifiers.push(await renderer.renderAllNotifier());
    }
    return Notifier.combine(notifiers);
  }
  async render() {
    return this.view.sync(
      (renderer) => Notifier.run(renderer.renderAllNotifier())
    );
  }
  async showHelp(source) {
    return showHelp(this, source);
  }
  async quitHelp() {
    return quitHelp(this);
  }
};

// src/rooter.ts
var import_coc64 = require("coc.nvim");
var import_path22 = __toESM(require("path"));
var Rooter = class {
  constructor(workspaceRoot) {
    this.workspaceRoot = workspaceRoot;
  }
  open(explorer) {
    return new RooterOpened(this.workspaceRoot, explorer);
  }
};
var RooterOpened = class {
  constructor(workspaceRoot, explorer) {
    this.workspaceRoot = workspaceRoot;
    this.explorer = explorer;
    this.customRoots = {};
    const self2 = this;
    let sourceBufFullpath_ = null;
    const getSourceBufFullpath = async () => {
      if (sourceBufFullpath_ === null)
        sourceBufFullpath_ = await self2.resolveBufFullpath();
      return sourceBufFullpath_;
    };
    this.roots = {
      keep: () => void 0,
      workspace: () => workspaceRoot,
      cwd: () => import_coc64.workspace.cwd,
      sourceBuffer: () => {
        return getSourceBufFullpath();
      },
      reveal: (revealPath) => revealPath ? import_path22.default.dirname(revealPath) : void 0
    };
  }
  async resolveRootByPatterns(dir, patterns, bottomUp) {
    const ndir = normalizePath(dir);
    const parts = ndir.split(import_path22.default.sep);
    if (bottomUp) {
      while (parts.length > 0) {
        const dir2 = parts.join(import_path22.default.sep);
        if (await inDirectory(dir2, patterns)) {
          return dir2;
        }
        parts.pop();
      }
      return void 0;
    } else {
      const curr = [parts.shift()];
      for (const part of parts) {
        curr.push(part);
        const dir2 = curr.join(import_path22.default.sep);
        if (await inDirectory(dir2, patterns)) {
          return dir2;
        }
      }
      return void 0;
    }
  }
  async resolveRootBy(revealPath, strategyStr) {
    const strategy = strategyStr;
    const customPrefix = "custom:";
    if (rootStrategyList.includes(strategy)) {
      return this.roots[strategy](revealPath);
    } else if (strategy.startsWith(customPrefix)) {
      const customStrategy = strategy.slice(customPrefix.length);
      const customRules = this.explorer.config.get("root.customRules");
      const customRule = customRules[customStrategy];
      let dir = import_coc64.workspace.cwd;
      const sourceBufFullpath = await this.roots.sourceBuffer();
      if (sourceBufFullpath) {
        dir = sourceBufFullpath.endsWith(import_path22.default.sep) ? sourceBufFullpath : import_path22.default.dirname(sourceBufFullpath);
      }
      if (customRule) {
        return await this.resolveRootByPatterns(
          dir,
          customRule.patterns,
          customRule.bottomUp ?? false
        );
      }
    }
    logger.error(`${strategyStr} is not supported`);
    return void 0;
  }
  async resolveRoot(reveal, strategies) {
    if (strategies.includes("keep")) {
      return;
    }
    for (const strategy of strategies) {
      const root2 = await this.resolveRootBy(reveal, strategy);
      if (!root2) {
        continue;
      }
      if (!reveal) {
        return root2;
      }
      if (isParentFolder(root2, reveal)) {
        return root2;
      }
    }
  }
  async resolveBufFullpath() {
    var _a;
    const buf = await this.explorer.sourceBuffer();
    if (!buf) {
      return void 0;
    }
    const buftype = await buf.getVar("&buftype");
    if (buftype === "nofile") {
      return void 0;
    }
    const fullpath = (_a = this.explorer.explorerManager.bufManager.getBufferNode(
      buf.id
    )) == null ? void 0 : _a.fullpath;
    if (!fullpath) {
      return void 0;
    }
    return normalizePath(import_path22.default.dirname(fullpath));
  }
};

// src/source/sources/file/clipboard/base.ts
var ClipboardStorage = class {
  constructor(explorerManager) {
    this.explorerManager = explorerManager;
  }
};

// src/source/sources/file/clipboard/global-state.ts
var GlobalStateStorage = class extends ClipboardStorage {
  context() {
    return this.explorerManager.context;
  }
  async setFiles(type, fullpaths) {
    const newClip = {
      type,
      fullpaths
    };
    if (newClip.fullpaths.length === 0) {
      await this.clear();
    } else {
      await this.context().globalState.update("clipboard", newClip);
    }
  }
  async getFiles() {
    const content = this.context().globalState.get("clipboard");
    if (!content)
      return {
        type: "none",
        fullpaths: []
      };
    return content;
  }
  async clear() {
    await this.context().globalState.update("clipboard", void 0);
  }
};

// src/source/sources/file/clipboard/clipboard.ts
function getClipboard(explorerManager) {
  return new GlobalStateStorage(explorerManager);
}

// src/explorerManager.ts
var ExplorerManager = class {
  constructor(context2, bufManager) {
    this.context = context2;
    this.bufManager = bufManager;
    this.filetype = "coc-explorer";
    this.previousBufnr = new GlobalContextVars("previousBufnr");
    this.previousWindowID = new GlobalContextVars("previousWindowID");
    this.maxExplorerID = 0;
    this.nvim = import_coc65.workspace.nvim;
    this.events = new HelperEventEmitter(logger);
    this.waitInited = firstValueFrom(fromHelperEvent(this.events, "inited"));
    this.clipboardStorage = getClipboard(this);
    currentBufnr().then(this.updatePrevCtxVars.bind(this)).catch(logger.error);
    this.context.subscriptions.push(
      onBufEnter(async (bufnr) => {
        await this.updatePrevCtxVars(bufnr);
      }, 0)
    );
    this.context.subscriptions.push(
      import_coc65.Disposable.create(() => (0, import_coc65.disposeAll)(this.explorers()))
    );
  }
  async updatePrevCtxVars(bufnr) {
    if (isTest)
      return;
    if (!this.bufnrs().includes(bufnr)) {
      const bufname = await this.nvim.call("bufname");
      if (bufname.startsWith("list://") || bufname.startsWith("[coc-explorer]")) {
        return;
      }
      const filetype = await this.nvim.getVar("&filetype");
      if (filetype !== this.filetype) {
        await this.previousBufnr.set(bufnr);
        const winid = await this.nvim.call("win_getid");
        await this.previousWindowID.set(winid === -1 ? void 0 : winid);
      }
    }
  }
  async prevWinnrByPrevBufnr() {
    const previousBufnr = await this.previousBufnr.get();
    if (!previousBufnr) {
      return;
    }
    const winnr = await this.nvim.call("bufwinnr", [previousBufnr]);
    if (winnr <= 0 || (await this.winnrs()).includes(winnr)) {
      return;
    }
    return winnr;
  }
  async prevWinnrByPrevWindowID() {
    const previousWindowID = await this.previousWindowID.get();
    if (!previousWindowID) {
      return;
    }
    const winnr = await this.nvim.call("win_id2win", [
      previousWindowID
    ]);
    if (winnr <= 0 || (await this.winnrs()).includes(winnr)) {
      return;
    }
    return winnr;
  }
  bufnrs() {
    return this.explorers().map((explorer) => explorer.bufnr);
  }
  async winids() {
    return compactI2(
      await Promise.all(this.explorers().map((explorer) => explorer.winid))
    );
  }
  async winnrs() {
    const container = await tabContainerManager.currentTabContainer();
    const explorers = container == null ? void 0 : container.all();
    if (explorers) {
      const winnrs = await Promise.all(
        explorers.map((explorer) => explorer.winnr)
      );
      return winnrs.filter((winnr) => winnr !== void 0);
    } else {
      return [];
    }
  }
  explorers() {
    const explorers = [];
    for (const container of tabContainerManager.values()) {
      explorers.push(...container.all());
    }
    return explorers;
  }
  async currentExplorer() {
    return this.explorerByBufnr(await currentBufnr());
  }
  async explorerByWinid(winid) {
    for (const e2 of this.explorers()) {
      if (await e2.winid === winid) {
        return e2;
      }
    }
  }
  explorerByBufnr(bufnr) {
    return this.explorers().find((e2) => e2.bufnr === bufnr);
  }
  async inExplorer() {
    return await this.currentExplorer() !== void 0;
  }
  async checkResume(explorer, argValues) {
    var _a;
    if (argValues.position.name !== "floating") {
      return true;
    }
    if (!await ((_a = await explorer.sourceBuffer()) == null ? void 0 : _a.loaded)) {
      await this.nvim.command(`bwipeout! ${explorer.bufnr}`);
      return false;
    }
    if (!await explorer.buffer.valid) {
      return false;
    }
    if (!await this.nvim.call("bufexists", [explorer.borderBufnr])) {
      await this.nvim.command(`bwipeout! ${explorer.bufnr}`);
      return false;
    }
    return true;
  }
  async open(argStrs) {
    await this.waitInited;
    let isFirst = true;
    const config4 = configLocal();
    const explorerConfig = buildExplorerConfig(config4);
    const args = await Args.parse(argStrs, config4);
    const argValues = await args.values(argOptions);
    const position = argValues.position;
    if (position.name === "floating") {
      if (!supportedNvimFloating()) {
        throw new Error("not support floating position in vim");
      }
    }
    const quit = argValues.quit;
    const tabid = position.name === "tab" ? await tabContainerManager.currentTabMaxId() + 1 : await tabContainerManager.currentTabId();
    const tabContainer = tabContainerManager.get(tabid);
    let explorer = tabContainer.getExplorer(position);
    if (explorer && quit) {
      await explorer.quit();
      return;
    }
    const sourceWinid = await this.nvim.call("win_getid");
    const sourceBufnr = await currentBufnr();
    const rooter = new Rooter(import_coc65.workspace.root);
    if (!explorer || !await this.nvim.call("bufexists", [explorer.bufnr])) {
      explorer = await Explorer.create(this, argValues, explorerConfig);
      tabContainer.setExplorer(position, explorer);
    } else if (!await explorer.inited.get()) {
      await this.nvim.command(`bwipeout! ${explorer.bufnr}`);
      explorer = await Explorer.create(this, argValues, explorerConfig);
      tabContainer.setExplorer(position, explorer);
    } else {
      const win = await explorer.win;
      if (!win) {
        if (await this.checkResume(explorer, argValues)) {
          await explorer.resume(argValues);
        } else {
          explorer = await Explorer.create(this, argValues, explorerConfig);
          tabContainer.setExplorer(position, explorer);
        }
      } else {
        if (await args.value(argOptions.toggle)) {
          await explorer.quit();
          return;
        }
        if (await args.value(argOptions.focus)) {
          await explorer.focus();
          return;
        }
      }
      isFirst = false;
    }
    await explorer.sourceWinid.set(sourceWinid);
    await explorer.sourceBufnr.set(sourceBufnr);
    await explorer.open(args, rooter, isFirst);
  }
};

// src/lists/presets.ts
var import_coc66 = require("coc.nvim");
var PresetList = class extends import_coc66.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "explPresets";
    this.defaultAction = "do";
    this.description = "explorer presets";
    this.addAction("do", async (item) => {
      this.nvim.command(`CocCommand explorer --preset ${item.data.name}`).catch(logger.error);
    });
  }
  async loadItems(_context) {
    const presets = await getPresets(configLocal());
    return [...presets.keys()].map((name) => ({
      label: name,
      data: {
        name
      }
    }));
  }
  doHighlight() {
    const { nvim } = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocExplorerPreset /.*/", true);
    nvim.command("highlight default link CocExplorerPreset PreProc", true);
    nvim.resumeNotification().catch(logger.error);
  }
};

// src/vimApi.ts
var import_coc67 = require("coc.nvim");
var import_path23 = __toESM(require("path"));
function registerApi(id, execute) {
  return import_coc67.commands.registerCommand(
    id,
    logger.asyncCatch(execute),
    void 0,
    true
  );
}
async function getExplorer(explorerFinder, explorerManager) {
  if (explorerFinder === "closest") {
    const winFinder = await WinLayoutFinder.create();
    const curWinid = await import_coc67.workspace.nvim.eval(
      "win_getid(winnr())"
    );
    if (curWinid <= -1) {
      return;
    }
    const curNode = winFinder.findWinid(curWinid);
    if (!curNode) {
      return;
    }
    const winids = await explorerManager.winids();
    if (!winids.length) {
      return;
    }
    const node = winFinder.findClosest(curNode, winids);
    if (node) {
      return explorerManager.explorerByWinid(node.winid);
    } else {
      const current = await tabContainerManager.currentTabContainer();
      const explorer = current == null ? void 0 : current.floating;
      if (await (explorer == null ? void 0 : explorer.winnr) !== void 0) {
        return explorer;
      }
    }
  } else {
    return explorerFinder === 0 ? explorerManager.currentExplorer() : explorerManager.explorerByBufnr(explorerFinder);
  }
}
async function getLineIndexByPosition(position, explorer) {
  if (position === "current") {
    return explorer.view.currentLineIndex;
  } else if (typeof position === "number") {
    return position;
  } else if (Array.isArray(position)) {
    const [mode, lineIndex, type] = position;
    if (mode === "relative") {
      const source = type ? explorer.sources.find((s3) => s3.sourceType === type) : await explorer.view.currentSource();
      if (source) {
        return source.view.startLineIndex + lineIndex;
      }
    }
  }
}
async function getSourceAndNodeByPosition(position, explorer) {
  const lineIndex = await getLineIndexByPosition(position, explorer);
  if (!lineIndex) {
    return [void 0, void 0];
  }
  const source = explorer.sources.find(
    (source2) => lineIndex >= source2.view.startLineIndex && lineIndex < source2.view.endLineIndex
  );
  if (!source) {
    return [void 0, void 0];
  }
  const nodeIndex = lineIndex - source.view.startLineIndex;
  return [source, source.view.flattenedNodes[nodeIndex] ?? void 0];
}
function registerVimApi(context2, explorerManager) {
  async function doAction(explorerFinder, actionExp, positions = ["current"], mode = "n", count = 1) {
    const explorer = await getExplorer(explorerFinder, explorerManager);
    if (!explorer) {
      return;
    }
    await explorer.view.refreshLineIndex();
    const lineIndexes = compactI2(
      await Promise.all(
        positions.map(
          async (position) => await getLineIndexByPosition(position, explorer)
        )
      )
    );
    await explorer.action.doActionExp(parseOriginalActionExp(actionExp), {
      mode,
      count,
      lineIndexes
    }).catch(logger.error);
  }
  context2.subscriptions.push(
    registerApi("explorer.doAction", doAction),
    registerApi(
      "explorer.doCodeAction",
      async (name, action, getArgs) => {
        const result = await doAction(0, {
          name: action,
          args: await getArgs()
        });
        await actionListMru.add(name);
        return result;
      }
    ),
    registerApi(
      "explorer.getNodeInfo",
      async (explorerFinder, position = "current") => {
        const explorer = await getExplorer(explorerFinder, explorerManager);
        if (!explorer) {
          return void 0;
        }
        await explorer.view.refreshLineIndex();
        const [, node] = await getSourceAndNodeByPosition(position, explorer);
        if (!node) {
          return void 0;
        }
        return {
          ...node,
          compactedNodes: void 0,
          parent: void 0,
          children: void 0,
          prevSiblingNode: void 0,
          nextSiblingNode: void 0
        };
      }
    ),
    registerApi(
      "explorer.getIcon",
      async (filepath, isDirectory = false, isExpanded) => {
        const basename2 = import_path23.default.basename(filepath);
        const type = isDirectory ? "directories" : "files";
        const nodes = [
          {
            fullname: basename2,
            isDirectory,
            expanded: isExpanded,
            hidden: false
          }
        ];
        const icons = await loadIcons("builtin", nodes);
        return icons == null ? void 0 : icons[type].get(basename2);
      }
    ),
    registerApi(
      "explorer.getIcons",
      async (paths) => {
        const fullname2filepath = {};
        const targets = paths.map((it) => {
          const fullname = import_path23.default.basename(it.filepath);
          fullname2filepath[fullname] = it.filepath;
          return {
            fullname,
            isDirectory: it.isDirectory,
            expanded: it.isExpanded,
            hidden: false
          };
        });
        const icons = await loadIcons("builtin", targets);
        if (!icons) {
          return;
        }
        const result = {
          files: {},
          directories: {}
        };
        for (const [fullname, file] of icons.files) {
          result.files[fullname2filepath[fullname]] = file;
        }
        for (const [fullname, directory] of icons.directories) {
          result.directories[fullname2filepath[fullname]] = directory;
        }
        return result;
      }
    )
  );
}

// src/index.ts
var activate = (context2) => {
  const { subscriptions } = context2;
  const { nvim } = import_coc68.workspace;
  const debug = config.get("debug");
  logger.level = debug ? "debug" : "info";
  hlGroupManager.createGroup(
    "SelectUI",
    "ctermbg=27 ctermfg=0 guibg=#1593e5 guifg=#ffffff"
  );
  const normalFloat = hlGroupManager.linkGroup("NormalFloat", "NormalFloat");
  hlGroupManager.linkGroup("NormalFloatBorder", normalFloat.group);
  import_coc68.listManager.registerList(new PresetList(nvim));
  const bufManager = new BufManager(context2);
  const explorerManager = new ExplorerManager(context2, bufManager);
  registerVimApi(context2, explorerManager);
  GitCommand.preload().catch(logger.error);
  subscriptions.push(
    import_coc68.commands.registerCommand(
      "explorer",
      logger.asyncCatch((...args) => {
        explorerManager.open(args).catch(logger.error);
      })
    ),
    import_coc68.languages.registerCodeActionProvider(
      ["coc-explorer"],
      new ActionMenuCodeActionProvider(explorerManager),
      "coc-explorer"
    )
  );
  (async () => {
    await activateHelper(context2);
    registerInternalEvents(context2);
    await registerRuntimepath(context2);
    await nvim.command("runtime plugin/coc_explorer.vim");
    registerGitHighlights(subscriptions);
    registerInternalColors(subscriptions);
    await registerMappings(context2, explorerManager);
    await explorerManager.events.fire("inited");
    await tabContainerManager.initedEmitter.fire();
    bufManager.reload().catch(logger.error);
    await tabContainerManager.register();
  })().catch(logger.error);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
